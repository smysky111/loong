[
  {
    "question": "In an ancient hidden library, an encrypted message has been discovered, believed to hold the key to unlocking a long-lost treasure. The message was encoded using the Yunying Cipher (01248 Cipher), a mysterious encryption method known to use only the digits 0, 1, 2, 4, and 8. The 0 serves as a separator between groups of digits, and the sum of the numbers in each group corresponds to a letter (1 = A, 2 = B, ..., 26 = Z). The ciphertext discovered is: 4210211128401428102101181421. Can you decode the message and reveal the secret phrase that points to the treasure's location? \n\nThe final message, once decoded, will be the name of the treasure in uppercase letters. Remember, the ciphertext is encrypted with the Yunying Cipher. \n\nSubmit your solution in the format: PCTF{decoded_message}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"4210211128401428102101181421\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{GSPCR}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "4210211128401428102101181421",
        "plaintext": "GSPCR",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the quiet town of Cypherfield, an ancient manuscript was discovered containing a cryptic message that had baffled historians for centuries. After extensive research, it was found that the cipher used was the Yunying Cipher (01248 Cipher). The encrypted message, however, was too elusive for most to decode. Only a few scholars have been able to understand it, and now it's your turn to uncover the secrets hidden within.\n\nYou have intercepted a message encoded with the Yunying Cipher. The ciphertext is: 1841044241208144111102210214410411841202104111. Your task is to decrypt this mysterious message and reveal the hidden truth.\n\nThe Yunying Cipher works by using the digits 0, 1, 2, 4, and 8, with 0 serving as a separator between groups of digits. The sum of the digits within each group corresponds to a letter (1 = A, 2 = B, ..., 26 = Z).\n\nGood luck, and may your decoding skills lead you to unravel the secrets of the past.\n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"1841044241208144111102210214410411841202104111\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{NQUELUCG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "1841044241208144111102210214410411841202104111",
        "plaintext": "NQUELUCG",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient kingdom, a secret society known as the Whispering Shadows communicated only in a mysterious cipher called Yunying. One of their encrypted messages has surfaced, and it reads: 811212211120121811422211024211822110228822. Your mission is to decode the message and uncover the hidden truth behind it. The Yunying cipher uses only the digits 0, 1, 2, 4, and 8, where 0 serves as a separator. The sum of the numbers in each segment corresponds to a letter (1 = A, 2 = B, ..., 26 = Z). Can you reveal the society's message? Time is of the essence. Cipher Parameters: Digits allowed: 0, 1, 2, 4, 8Separator: 0Mapping: 1=A, 2=B, ..., 26=ZSubmit the flag in the format: PCTF{decoded_plaintext}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"811212211120121811422211024211822110228822\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{VZXX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "811212211120121811422211024211822110228822",
        "plaintext": "VZXX",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the quiet town of Silvershade, a cryptic message was discovered, said to contain vital information about an ancient secret. The message was encrypted using the Yunying Cipher (01248 Cipher), which has long been a mystery to those who sought to decode it. The only clue left behind was the following ciphertext: 1241224121110111022204110228124121. Your task is to decode this message and uncover the hidden truth. \n\nYunying Cipher Details: The cipher uses only five digits: 0, 1, 2, 4, and 8. The digit 0 is a separator, dividing numbers into segments. The sum of each segment corresponds to a letter, where 1=A, 2=B, ..., 26=Z. The message, when decrypted, will reveal a vital piece of history. \n\nGood luck, and remember to stay sharp! \n\nSubmit your solution in the following format: PCTF{plaintext}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"1241224121110111022204110228124121\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{VCFFW}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "1241224121110111022204110228124121",
        "plaintext": "VCFFW",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A long-lost message has been discovered in an ancient scroll, encrypted using the Yunying Cipher (01248 Cipher). This message, once belonging to a forgotten society, holds vital information. Your mission is to decrypt the message and reveal the hidden truth. The encrypted message is: 8148101221081120822088102818141020212. \n\nYunying Cipher Overview: The cipher uses only the numbers 0, 1, 2, 4, and 8, where the number 0 serves as a separator. Each segment of numbers, divided by 0, represents a letter, with the sum of the digits in each segment corresponding to a letter in the alphabet (1 = A, 2 = B, ..., 26 = Z). \n\nDecrypt the message and uncover its meaning.\n\nSubmission format: PCTF{decrypted_message}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"8148101221081120822088102818141020212\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{VFLLQYBE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "8148101221081120822088102818141020212",
        "plaintext": "VFLLQYBE",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the quiet town of Eldora, a cryptic message was found hidden inside an ancient manuscript. The message was encrypted using the Yunying cipher (01248 cipher), a secret code that had eluded scholars for centuries. It was discovered that the cipher relies on five unique digits-0, 1, 2, 4, and 8. In this cipher, the number 0 serves as a separator, and the sum of the numbers between each separator corresponds to a letter (1 = A, 2 = B, ..., 26 = Z). The encrypted message, which has been carefully preserved, reads as: 18122110282804481102110221221242412. Your task is to decrypt this mysterious message and uncover its hidden meaning. What does it reveal? The plaintext message contains only A-Z letters and spaces. The key to unlocking the cipher is within your reach, but only those with sharp minds can decode it. Solve it and submit your answer in the format: PCTF{decrypted_message}.",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"18122110282804481102110221221242412\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{PTRDY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "18122110282804481102110221221242412",
        "plaintext": "PTRDY",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A long-lost ancient cipher, known as the Yunying Cipher, has been discovered hidden in the ruins of an old library. It is said to have been used by a secret society to communicate their most important messages. You've found a fragment of one such message, encrypted using this mysterious cipher. The ciphertext is as follows: 110401241484201222282221. Your task is to decipher this message. The Yunying Cipher uses only the digits 0, 1, 2, 4, and 8, with 0 acting as a separator. The sum of the digits in each segment corresponds to a letter (1=A, 2=B, ..., 26=Z). Decoding the message will reveal a hidden truth from the past. Can you unlock the secret? Submit your answer in the format: PCTF{plaintext_string}",
    "rationale": "\ndef yunying_decrypt(ciphertext):\n    def segment_to_char(segment):\n        total = sum(int(d) for d in segment)\n        return chr(ord('A') + total - 1) if 1 <= total <= 26 else '?'\n\n    parts = ciphertext.strip().split('0')\n    chars = [segment_to_char(seg) for seg in parts if seg]\n    return ''.join(chars)\n\n# 示例密文\nciphertext = \"110401241484201222282221\"\n\n# 解码\nplaintext = yunying_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{BDZX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Yunying_01248",
      "change_detail": "The 01248 cipher, also known as the Yunying cipher, is a lightweight numeric encoding method using only the digits 0, 1, 2, 4, and 8. The digit '0' is used as a delimiter to separate segments. Each segment is made up of any combination of 1, 2, 4, and 8, whose sum corresponds to a number between 1 and 26, mapping to letters A-Z. Since numbers like 23 can be formed in multiple ways (e.g., 8+8+4+2+1 or 8+4+4+4+2+1), this encoding is inherently non-unique, allowing for randomized encryption.",
      "synthesis_code": "import random\n\ndef num_to_yunying(n):\n    '''Convert a number 1–26 into a random sum of 1, 2, 4, 8.'''\n    parts = []\n    choices = [8, 4, 2, 1]\n    while n > 0:\n        valid = [x for x in choices if x <= n]\n        if not valid:\n            break\n        pick = random.choice(valid)\n        parts.append(pick)\n        n -= pick\n    return ''.join(str(x) for x in parts)\n\ndef char_to_yunying(c):\n    '''Convert a single character to yunying cipher segment.'''\n    if not c.isalpha():\n        return ''\n    index = ord(c.upper()) - ord('A') + 1  # A=1, ..., Z=26\n    return num_to_yunying(index)\n\ndef yunying_encrypt(text):\n    '''Encrypt a text using 01248 Yunying cipher'''\n    segments = [char_to_yunying(c) for c in text if c.isalpha()]\n    return '0'.join(segments)\n\nplaintext = \"{plaintext}\"  # Example: 'HELLO'\nciphertext = yunying_encrypt(plaintext)\nprint(ciphertext)\n",
      "compute": "1",
      "original_data": {
        "ciphertext": "110401241484201222282221",
        "plaintext": "BDZX",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message was intercepted by the ancient Order of the Cipher Seekers, known for their mastery of cryptographic techniques. They used a Columnar Transposition Cipher to conceal a vital piece of information, and now it is up to you to decode it. The ciphertext is: BkcsLJruAkjyOduJqLIZtQgGOTSVmDFYSKKtSpcx, and the key used for encryption is: hlmgg. Your mission is to decrypt this message and uncover the truth hidden within.\n\nHints:\n- The number of columns is determined by the length of the key.\n- The key, when arranged in alphabetical order, defines the reading order of the columns.\n- The ciphertext contains only letters, and the key has no spaces.\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"BkcsLJruAkjyOduJqLIZtQgGOTSVmDFYSKKtSpcx\"\nkey = \"hlmgg\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qOSBALTKkkISKcjZVtsytmSLOQDpJdgFcruGYxuJ}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "BkcsLJruAkjyOduJqLIZtQgGOTSVmDFYSKKtSpcx",
        "key": "hlmgg",
        "plaintext": "qOSBALTKkkISKcjZVtsytmSLOQDpJdgFcruGYxuJ",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A cryptic message has been intercepted by a secret agent, encrypted using the ancient Columnar Transposition Cipher. The agent managed to send the encrypted message and key, but the enemy is aware of the encryption method and is waiting for a decryption. Can you crack the code and unveil the hidden message?\n\nThe intercepted ciphertext is: CFtxiZGxTNxiBUwhermTRgUzzbhlfnMaywuzhB and the key used for encryption is: jakqnnk\n\nYour task is to decrypt the message and reveal the original plaintext. Here are a few hints:\n- The number of columns in the transposition grid is determined by the length of the key.\n- The sequence in which the columns are read is based on the alphabetical order of the key's letters.\n- The key does not contain any spaces, and the ciphertext contains only letters.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"CFtxiZGxTNxiBUwhermTRgUzzbhlfnMaywuzhB\"\nkey = \"jakqnnk\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{GCBwzfmxFUuznTTtwzbMRNxhhhagxieBlyUiZr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "CFtxiZGxTNxiBUwhermTRgUzzbhlfnMaywuzhB",
        "key": "jakqnnk",
        "plaintext": "GCBwzfmxFUuznTTtwzbMRNxhhhagxieBlyUiZr",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a secretive world of espionage, a covert agent intercepted a message from a high-value target. The message was encrypted using a Columnar Transposition Cipher, and the agent was able to recover part of it, but the rest remains hidden. Your task is to decrypt the ciphertext below: DAkbibrNoFtVnCrLqlSxxUQWytizEsVWp using the key: bafcbkh.\n\nHints to help you crack the code:\n- The length of the key determines the number of columns in the transposition grid.\n- The columns are filled in an orderly fashion and read according to the order of the letters in the key.\n- The key has no spaces and consists of alphabetic characters only.\n\nOnce you've deciphered the message, submit your answer in the format: PCTF{decrypted_plaintext}.",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"DAkbibrNoFtVnCrLqlSxxUQWytizEsVWp\"\nkey = \"bafcbkh\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{bDxLtstrAUqVViNkQlnWzobWSCpEFiyxr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "DAkbibrNoFtVnCrLqlSxxUQWytizEsVWp",
        "key": "bafcbkh",
        "plaintext": "bDxLtstrAUqVViNkQlnWzobWSCpEFiyxr",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a covert operation, an undercover agent intercepted a message encrypted using a Columnar Transposition Cipher. The encrypted message is: xWFfKFbpwPNaUfMUnozfRXGSthPlbTAu and it was encoded using the secret key: pvqhelmo. Your mission, should you choose to accept it, is to decrypt the message and retrieve the original plaintext. \nHint: \n- The length of the key determines the number of columns, and the letters in the key dictate the reading order of the columns. \n- There are no spaces in the key, and the ciphertext contains only letters. \nSubmit the decrypted message in the format: PCTF{plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"xWFfKFbpwPNaUfMUnozfRXGSthPlbTAu\"\nkey = \"pvqhelmo\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{RbtKxwUnXThFWPfoGAPbFNMzSulpfaUf}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "xWFfKFbpwPNaUfMUnozfRXGSthPlbTAu",
        "key": "pvqhelmo",
        "plaintext": "RbtKxwUnXThFWPfoGAPbFNMzSulpfaUf",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2042, a secret message was intercepted by the resistance, encoded using the Columnar Transposition Cipher. The message was crucial for their next operation. The encrypted text, however, is locked in a cipher that only those with the right key can decipher. Your mission is to decrypt the message before time runs out. The ciphertext is: RwaPpMkpepJGBWjDrjEgynBJIjBldC. The encryption was done using a key of: ilcitw. \n\nHints: \n- The length of the key corresponds to the number of columns used in the cipher grid. \n- The order of the key's letters determines the column read order. \n- The key contains no spaces, and the ciphertext consists solely of uppercase letters.\n\nSubmit your solution in the format: PCTF{plaintext_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"RwaPpMkpepJGBWjDrjEgynBJIjBldC\"\nkey = \"ilcitw\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{MDRJyjkrwGnBpjaBBleEPWJdpgpjIC}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "RwaPpMkpepJGBWjDrjEgynBJIjBldC",
        "key": "ilcitw",
        "plaintext": "MDRJyjkrwGnBpjaBBleEPWJdpgpjIC",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message has been found, encrypted using the ancient art of Columnar Transposition Cipher. The ciphertext is as follows: UytpboNPOcIFOWKDcoqwwHwlsMYXiTjaH, and the key used for encryption is: fntyw. Your task is to decrypt this message and uncover its hidden meaning. To assist you in solving this puzzle, remember the following hints:\n\n- The length of the key determines the number of columns.\n- The arrangement of the key dictates the order in which the columns are read.\n- The ciphertext consists only of letters, with no spaces or punctuation marks.\n\nCan you uncover the hidden message and decipher the code? Submit your solution in the format: PCTF{decrypted_plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"UytpboNPOcIFOWKDcoqwwHwlsMYXiTjaH\"\nkey = \"fntyw\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{UPKXHyODiwtccTlpIojsbFqaMoOwHYNWw}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "UytpboNPOcIFOWKDcoqwwHwlsMYXiTjaH",
        "key": "fntyw",
        "plaintext": "UPKXHyODiwtccTlpIojsbFqaMoOwHYNWw",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the midst of an ancient cryptographic mystery, a renowned archaeologist discovered a coded message hidden within a forgotten manuscript. The cipher used to protect this message is none other than the Columnar Transposition Cipher. The encrypted text is as follows: kyQXLlivHKFXmETZmygXidYq, and the key used for encryption is: ubafaoco. Your task is to uncover the original plaintext from this puzzle.\n\nHints:\n- The number of columns is determined by the length of the key.\n- The letters in the key define the order in which to read the columns.\n- The key does not contain spaces, and the ciphertext consists only of letters.\n\nSubmit your solution in the format: PCTF{plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"kyQXLlivHKFXmETZmygXidYq\"\nkey = \"ubafaoco\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{dikmXZKgYvyELmFXqHQTlyXi}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "kyQXLlivHKFXmETZmygXidYq",
        "key": "ubafaoco",
        "plaintext": "dikmXZKgYvyELmFXqHQTlyXi",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message encrypted using the ancient Columnar Transposition Cipher has surfaced in a hidden archive. The message, once decrypted, holds critical information about a mysterious artifact's location. The ciphertext you have recovered is: DOImtLZlZBDNaiYoIDtiCdUI. The key used for encryption is said to be a vital clue, and it is: pexgay. Can you unlock the secrets of the past and reveal the original message? Time is running out!\n\nHints:\n- The length of the key defines the number of columns; the letters in the key dictate the order in which the columns are read.\n- The key contains no spaces, and the ciphertext is purely alphabetical.\n\nSubmission format: PCTF{decrypted_plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"DOImtLZlZBDNaiYoIDtiCdUI\"\nkey = \"pexgay\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{atIZDCiLDBOdYZtDIUoliNmI}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "DOImtLZlZBDNaiYoIDtiCdUI",
        "key": "pexgay",
        "plaintext": "atIZDCiLDBOdYZtDIUoliNmI",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You are a renowned cryptographer invited to assist a secretive organization. They have intercepted a message that has been encrypted using a Columnar Transposition Cipher. The ciphertext is as follows: HJvHHaoIUHIxCECBraqPYvmwZaTZbdoNeWULRZSj and the key used to encrypt the message is: fbfhwdza. Your mission is to decrypt the original plaintext message.\n\nHints:\n- The length of the key determines the number of columns used, while the letters of the key specify the order in which columns should be read.\n- Both the ciphertext and the key consist only of letters, with no spaces.\n\nGood luck, cryptographer. The fate of the mission lies in your hands!\n\nSubmission format: PCTF{plaintext_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"HJvHHaoIUHIxCECBraqPYvmwZaTZbdoNeWULRZSj\"\nkey = \"fbfhwdza\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{BaYaoILHrovTNxRJaImZeCZvqUwbWESHPHZdUCjH}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "HJvHHaoIUHIxCECBraqPYvmwZaTZbdoNeWULRZSj",
        "key": "fbfhwdza",
        "plaintext": "BaYaoILHrovTNxRJaImZeCZvqUwbWESHPHZdUCjH",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You are an investigator working for a secretive organization, and you've intercepted a critical message encoded with the Columnar Transposition Cipher. The encrypted message is as follows: NVvaNXAJkTzUEtQlrEzBALWtOWMzZtKhOsFXwQac and the key used for encryption is: ovmrg. Your mission is to decrypt the message and retrieve the vital information. The key will guide you to the correct column order, and its length determines how many columns are in play. The characters in the key dictate the reading sequence of the columns. Keep in mind that the ciphertext only contains letters, and spaces are not used. Good luck! \nHint: The key length defines the number of columns. The sequence of the key will tell you the order in which to read the columns. \nSubmit your answer as: PCTF{decrypted_plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"NVvaNXAJkTzUEtQlrEzBALWtOWMzZtKhOsFXwQac\"\nkey = \"ovmrg\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rOkONEsTWVzFzMvBXUzaAwEZNLQttXWaQKAtclhJ}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "NVvaNXAJkTzUEtQlrEzBALWtOWMzZtKhOsFXwQac",
        "key": "ovmrg",
        "plaintext": "rOkONEsTWVzFzMvBXUzaAwEZNLQttXWaQKAtclhJ",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2095, the secretive organization known as the Cipher Syndicate released a mysterious message encoded using an ancient method: the Columnar Transposition Cipher. The encrypted message has been intercepted, and it is believed to hold the key to a forgotten treasure buried deep within the ruins of a lost city. Your task is to decrypt this message to uncover the treasure's location. The encrypted message is: FjdIFaamGFBMtUOuLsfAQdhj and the key used for encryption is: kuoozj. \n\nHints:\n- The length of the key determines the number of columns.\n- The key itself is used to determine the order in which the columns are read.\n- The key contains no spaces, and the ciphertext consists only of letters.\n\nSubmit the decrypted message in the format: PCTF{original_plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"FjdIFaamGFBMtUOuLsfAQdhj\"\nkey = \"kuoozj\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{FLGtQFasFUdjafBOhdmAMujI}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "FjdIFaamGFBMtUOuLsfAQdhj",
        "key": "kuoozj",
        "plaintext": "FLGtQFasFUdjafBOhdmAMujI",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a small, forgotten library hidden beneath the streets of a long-abandoned city, an old letter was found. The letter contained an encrypted message believed to hold the key to a lost treasure. It was encoded using the Columnar Transposition cipher. The ciphered message is: phdvnwXRetYmFKskIvqlWxIhBnSLDEXbxgCDk and the key used for encryption is: bhqvx. Your task is to decrypt the message and uncover the truth behind the treasure.\n\nHints:\n- The number of columns corresponds to the length of the key.\n- The order of the columns is determined by the alphabetical order of the key's characters.\n- The ciphertext contains only letters, and the key is a word with no spaces.\n\nSubmit your answer in the following format: PCTF{decrypted_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"phdvnwXRetYmFKskIvqlWxIhBnSLDEXbxgCDk\"\nkey = \"bhqvx\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{peIhXhtvBbdYqnxvmlSgnFWLCwKxDDXsIEkRk}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "phdvnwXRetYmFKskIvqlWxIhBnSLDEXbxgCDk",
        "key": "bhqvx",
        "plaintext": "peIhXhtvBbdYqnxvmlSgnFWLCwKxDDXsIEkRk",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secretive message has been intercepted, encrypted using the Columnar Transposition Cipher. The encrypted message, which contains vital information, is: qUkvpiKRjUnKACyIcUZgCERBBTZEwPcj. It was encoded using a key known only to the sender. The key to decrypt the message is: xstojmwo. Your task is to recover the original plaintext from the cipher. \n\nHint:\n- The length of the key defines the number of columns in the grid.\n- The letters in the key determine the order in which the columns are read.\n- The key does not contain any spaces, and the ciphertext contains only letters.\n\nFormat your answer as: PCTF{your_decoded_plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"qUkvpiKRjUnKACyIcUZgCERBBTZEwPcj\"\nkey = \"xstojmwo\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{wcCjqpBAPUEUUiTCcZRnkKZyjgBKvREI}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "qUkvpiKRjUnKACyIcUZgCERBBTZEwPcj",
        "key": "xstojmwo",
        "plaintext": "wcCjqpBAPUEUUiTCcZRnkKZyjgBKvREI",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious encrypted message has been discovered within the archives of an ancient order. The message, believed to hold secrets to an impending event, has been encrypted using the Columnar Transposition Cipher. You have managed to retrieve the ciphertext, but the key remains hidden. Your task is to decrypt the message and uncover the truth. The ciphertext is: BKXCHlgkTDIJYcpCIWsqV and the key used for encryption is: wrazylg. \n\nHints: \n- The length of the key determines the number of columns in the cipher grid. \n- The characters of the key provide the order in which the columns should be read. \n- Both the key and ciphertext only contain alphabetic characters, with no spaces. \n\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"BKXCHlgkTDIJYcpCIWsqV\"\nkey = \"wrazylg\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{YDBsCgCcIKqIkHpJXVWTl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "BKXCHlgkTDIJYcpCIWsqV",
        "key": "wrazylg",
        "plaintext": "YDBsCgCcIKqIkHpJXVWTl",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message was intercepted from an ancient spy network operating during the Cold War. The encrypted communication, carefully hidden using the Columnar Transposition Cipher, was sent in the form of a coded string: CnqIltwSrQtwTBGYCCyJAijz. The key to decrypting this message lies in a secret codebook used by the spies, which contains the following key: mpyiylep. It is up to you to unlock the secrets hidden within and reveal the truth. \n\nHints:\n- The number of columns is determined by the length of the key.\n- The columns are read in an order defined by the key's letters, with alphabetic order being used for identical letters.\n- The ciphertext consists only of uppercase letters and spaces.\n\nSubmit the plaintext message in the format: PCTF{plaintext}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"CnqIltwSrQtwTBGYCCyJAijz\"\nkey = \"mpyiylep\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{QTyIiwCYtBJljSnCwGAtzrqC}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "CnqIltwSrQtwTBGYCCyJAijz",
        "key": "mpyiylep",
        "plaintext": "QTyIiwCYtBJljSnCwGAtzrqC",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A famous historical spy once used a secret cipher to communicate covertly with their allies during a perilous mission. The cipher they used was the Columnar Transposition Cipher, and now it's up to you to crack it. Your task is to decipher an encrypted message that holds the key to a great mystery. You are given the ciphertext: IHTRleUNtJvoWoZMTrfQnmaPJewLwfCEmfgKYUdn and the key that was used for the encryption: nnthjfcl. Use the clues wisely to unveil the original plaintext message.\n\nHints:\n- The number of columns is determined by the length of the key. The order of the columns is determined by the alphabetical order of the letters in the key.\n- The key does not contain spaces, and the ciphertext contains only letters.\n\nSubmit your solution in the format: PCTF{plaintext_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"IHTRleUNtJvoWoZMTrfQnmaPJewLwfCEmfgKYUdn\"\nkey = \"nnthjfcl\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{eCKvMeInwEYoTUHmLmUWrNTawfdoftRPfgnZQJlJ}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "IHTRleUNtJvoWoZMTrfQnmaPJewLwfCEmfgKYUdn",
        "key": "nnthjfcl",
        "plaintext": "eCKvMeInwEYoTUHmLmUWrNTawfdoftRPfgnZQJlJ",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 1943, a secretive resistance group used a unique cipher to communicate their plans. They encoded their most critical message using a Columnar Transposition Cipher, which was said to be nearly unbreakable. The encrypted message has survived through the years, hidden in plain sight. The ciphertext they left behind is: NNMKUdcJrqnlNIRmcMsdeidewfoOVxz, and the key used to encrypt this message was: dzfvgi. Your task is to decrypt the message and uncover the vital information the resistance had hidden. \n\nHints:\n- The number of columns in the transposition is determined by the length of the key.\n- The order in which the columns are read depends on the alphabetical arrangement of the key letters.\n- The key contains no spaces, and the ciphertext only includes letters.\n\nSubmit your answer as: PCTF{decrypted_message}",
    "rationale": "\nimport math\n\ndef column_decrypt(ciphertext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(ciphertext) / num_cols)\n\n    # 计算每列应有多少字符\n    num_full_cols = len(ciphertext) % num_cols\n    col_lengths = [num_rows] * num_cols\n    if num_full_cols != 0:\n        for i in range(num_cols):\n            if i >= num_full_cols:\n                col_lengths[i] -= 1\n\n    # 排序key\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 切分密文 -> 得到加密后的每列\n    cols = [''] * num_cols\n    pointer = 0\n    for sorted_idx, orig_col in enumerate(col_indices):\n        length = col_lengths[sorted_idx]\n        cols[orig_col] = ciphertext[pointer:pointer + length]\n        pointer += length\n\n    # 按行读取恢复明文\n    plaintext = ''\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if row < len(cols[col]):\n                plaintext += cols[col][row]\n    return plaintext\n\n# Given ciphertext and key\nciphertext = \"NNMKUdcJrqnlNIRmcMsdeidewfoOVxz\"\nkey = \"dzfvgi\"\n\n# Decryption process\nplaintext = column_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{NocilcNOJdNMMVreIsKxqwRdUznfmed}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Columnar_Transposition",
      "change_detail": "The Columnar Transposition Cipher is a classical cipher that encrypts plaintext by writing it into a grid with a number of columns equal to the length of a keyword, and then permuting the columns according to the alphabetical order of the keyword's characters. Unlike full grid filling, this implementation avoids padding by using a non-full matrix approach, which preserves the exact length of the original plaintext. The ciphertext is constructed by reading the characters column by column, following the sorted order of the key's characters.",
      "synthesis_code": "\nimport math\n\ndef column_encrypt(plaintext, key):\n    key = key.replace(' ', '')\n    num_cols = len(key)\n    num_rows = math.ceil(len(plaintext) / num_cols)\n    \n    # 填表格（不补齐）\n    matrix = ['' for _ in range(num_rows)]\n    for i in range(len(plaintext)):\n        row = i // num_cols\n        matrix[row] += plaintext[i]\n\n    # 排序key，得到列顺序(去掉空格)\n    key_order = sorted([(char, i) for i, char in enumerate(key)])\n    col_indices = [idx for _, idx in key_order]\n\n    # 按照列顺序读取\n    ciphertext = ''\n    for col in col_indices:\n        for row in matrix:\n            if col < len(row):  # 防止越界\n                ciphertext += row[col]\n    return ciphertext\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = column_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "NNMKUdcJrqnlNIRmcMsdeidewfoOVxz",
        "key": "dzfvgi",
        "plaintext": "NocilcNOJdNMMVreIsKxqwRdUznfmed",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Agents of the Secret Cipher Division, we have intercepted a message believed to be of utmost importance to our investigations. The enemy has employed a sophisticated coding technique, known as the Polybius cipher, to mask the content of their communication. The encrypted message reads as follows: 442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515 Your mission, should you choose to accept it, involves decrypting this message to uncover the hidden location. Act with haste, for time is of the essence. Submit your findings in the format: PCTF{decrypted_message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN IN THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515",
        "plaintext": "THE TREASURE IS HIDDEN IN THE OLD OAK TREE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old dusty book hidden in the deepest corners of the abandoned library, an ancient cipher catches your eye. It's rumored to have been used by spies in wars long forgotten. The page portrays a challenge to those wise and brave enough to solve it, promising the knowledge of a secret society if unveiled. The encrypted message below is your only clue: \n442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422\nUnravel the message and claim your place among the hidden guardians of forgotten lore.\n\nSubmission format: PCTF{plaintext message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX LEAPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422",
        "plaintext": "THE QUICK BROWN FOX LEAPS OVER THE LAZY DOG",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "While exploring an ancient library, you stumble upon a dusty, leather-bound book filled with pages of mysterious codes. On one of the pages, a note catches your eye — it's a message encrypted with the renowned Polybius cipher, used by spies and secret societies throughout history. The message is believed to point to the location of a treasure lost for centuries. Here is the encrypted message: 442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515 33151142 442315 11331324153344 132345421323. Can you decipher it and uncover the location of the long-lost treasure?\n\nSubmission Format: CTF{plaintext message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515 33151142 442315 11331324153344 132345421323\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN IN THE OLD OAK TREE NEAR THE ANCIENT CHURCH}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515 33151142 442315 11331324153344 132345421323",
        "plaintext": "THE TREASURE IS HIDDEN IN THE OLD OAK TREE NEAR THE ANCIENT CHURCH",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "After rummaging through the ancient library, you stumble upon an old tattered map with encrypted instructions. According to the legend, a great treasure lies hidden, and this cipher might reveal its exact location. The map shows this mysterious set of numbers: 442315 431513421544 4442151143454215 2443 124542241514 4533141542 442315 343114 341125 44421515. Decrypt these coordinates to discover the location where the treasure is buried. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 431513421544 4442151143454215 2443 124542241514 4533141542 442315 343114 341125 44421515\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET TREASURE IS BURIED UNDER THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 431513421544 4442151143454215 2443 124542241514 4533141542 442315 343114 341125 44421515",
        "plaintext": "THE SECRET TREASURE IS BURIED UNDER THE OLD OAK TREE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the lost journal of an ancient cryptographer, a hidden message has been found encoded using a mysterious grid known to experts as the Polybius Square. The content of this encrypted message is crucial for understanding the secrets of the cryptographer's last project. Here is the ciphertext: 11 431513421544 32154343112215 15331334141514 52244423 3534315412244543 434145114215. Your mission is to decrypt this message and reveal the hidden content. Submit your answer in the format: CTF{plaintext}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"11 431513421544 32154343112215 15331334141514 52244423 3534315412244543 434145114215\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{A SECRET MESSAGE ENCODED WITH POLYBIUS SQUARE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "11 431513421544 32154343112215 15331334141514 52244423 3534315412244543 434145114215",
        "plaintext": "A SECRET MESSAGE ENCODED WITH POLYBIUS SQUARE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty library of an ancient cryptography master, a curious student stumbled upon a mysterious manuscript that seemed to defy understanding. Scribbled in the margins of a dog-eared page was a message encrypted with the arcane Polybius cipher, a system believed to have been lost to the sands of time. The encrypted message read as follows: 52153113343215 4434 442315 5234423114 3421 134254354434224211352354 5223154215 43151342154443 312415 232414141533 2433 442315 43231114345243. Can you unravel the mystery and discover the hidden message? Decipher the text and submit your answer in the format: PCTF{decrypted message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"52153113343215 4434 442315 5234423114 3421 134254354434224211352354 5223154215 43151342154443 312415 232414141533 2433 442315 43231114345243\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{WELCOME TO THE WORLD OF CRYPTOGRAPHY WHERE SECRETS LIE HIDDEN IN THE SHADOWS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "52153113343215 4434 442315 5234423114 3421 134254354434224211352354 5223154215 43151342154443 312415 232414141533 2433 442315 43231114345243",
        "plaintext": "WELCOME TO THE WORLD OF CRYPTOGRAPHY WHERE SECRETS LIE HIDDEN IN THE SHADOWS",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You've stumbled upon an ancient piece of text while exploring the archives of an old library devoted to the study of historical ciphers. The text is known to contain the secrets of an old cryptographer's discovery, encrypted with a method that uses a simple but effective 5x5 grid. This encryption technique, known as the Polybius Square, was believed to be uncrackable by the enemies of yore. The encrypted message reads as follows: 2433 442315 5234423114 3421 134254354434224211352354 343315 3315151443 4434 4423243325 34454443241415 442315 123453. Your mission is to decipher this message, unveiling the wisdom that has been hidden for ages. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"2433 442315 5234423114 3421 134254354434224211352354 343315 3315151443 4434 4423243325 34454443241415 442315 123453\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{IN THE WORLD OF CRYPTOGRAPHY ONE NEEDS TO THINK OUTSIDE THE BOX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "2433 442315 5234423114 3421 134254354434224211352354 343315 3315151443 4434 4423243325 34454443241415 442315 123453",
        "plaintext": "IN THE WORLD OF CRYPTOGRAPHY ONE NEEDS TO THINK OUTSIDE THE BOX",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a dusty library of an ancient castle, a forgotten diary was found. Within its pages, a secret message encoded with the elusive Polybius cipher caught the eyes of an adventurous cryptographer. The encoded message reads as follows: 442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515. Decipher the message and unlock the path to an undiscovered treasure. Submit your answer in the format: PCTF{plaintext message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN IN THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4442151143454215 2443 232414141533 2433 442315 343114 341125 44421515",
        "plaintext": "THE TREASURE IS HIDDEN IN THE OLD OAK TREE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of an ancient cryptology guild, a peculiar piece of parchment was unearthed. Its content, believed to be the key to unlocking the secret chamber of knowledge, was encrypted using the Polybius cipher. According to legend, this chamber contains the lost cryptographs of the guild's most renowned codebreakers. The encrypted message reads as follows: 442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422. Decrypt the message to unveil the hidden entrance to the chamber. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX LEAPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4145241325 1242345233 213453 3115113543 34511542 442315 31115554 143422",
        "plaintext": "THE QUICK BROWN FOX LEAPS OVER THE LAZY DOG",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a long-forgotten library, nestled between the pages of an ancient book on ciphers, a peculiar sequence of numbers was found. These were not just any numbers, but a coded message using a method devised by Polybius, a historian from the classical age. The code, once believed to be unbreakable, has been cracked, but the message still remains a mystery. Here lies a challenge for those brave enough to decipher the past: 442315 4442151143454215 2443 232414141533 2433 442315 343114 32243131. Unveil the message, and claim your knowledge of the secrets that have been hidden away for centuries. Submit your answer in the format: PCTF{decrypted message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 4442151143454215 2443 232414141533 2433 442315 343114 32243131\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN IN THE OLD MILL}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 4442151143454215 2443 232414141533 2433 442315 343114 32243131",
        "plaintext": "THE TREASURE IS HIDDEN IN THE OLD MILL",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Ancient scrolls from a forgotten civilization contain an encrypted message using the Polybius square. Your mission is to decrypt the following ciphertext: 13341415 1242151125243322 2443 214533 52244423 3534315412244543. Solve the puzzle to uncover the hidden wisdom.\n\nSubmit in the format: PCTF{plaintext}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"13341415 1242151125243322 2443 214533 52244423 3534315412244543\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{CODE BREAKING IS FUN WITH POLYBIUS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "13341415 1242151125243322 2443 214533 52244423 3534315412244543",
        "plaintext": "CODE BREAKING IS FUN WITH POLYBIUS",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious artifact from the digital age contains cryptic notes that speak of a legendary event in human history. However, the message is concealed using the ancient Polybius cipher. Can you unravel the secret?\nCiphertext: 442315 1511223115 231143 311133141514 3433 442315 32343433\nYour task is to decipher this coded message and reveal the words that echo an iconic achievement.\nSubmission format: PCTF{plaintext message, no spaces}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"442315 1511223115 231143 311133141514 3433 442315 32343433\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE EAGLE HAS LANDED ON THE MOON}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "442315 1511223115 231143 311133141514 3433 442315 32343433",
        "plaintext": "THE EAGLE HAS LANDED ON THE MOON",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the crumbling diaries of an ancient cryptographer, a message encrypted with the Polybius cipher was uncovered. The mysterious ciphertext reads as follows: 11331324153344 43151342154443 114215 232414141533 522444232433 442315 22422414 Can you decipher this message and reveal the hidden secrets?\n\nSubmission Format: PCTF{your_decoded_message}",
    "rationale": "def polybius_decrypt(ciphertext):\n    # Create the standard 5x5 Polybius grid (I and J share a position)\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    plaintext = \"\"\n    i = 0\n    while i < len(ciphertext):\n        # If not a digit, add as is\n        if not ciphertext[i].isdigit():\n            plaintext += ciphertext[i]\n            i += 1\n            continue\n        \n        # Each letter is represented by two digits\n        if i + 1 < len(ciphertext):\n            row = int(ciphertext[i]) - 1\n            col = int(ciphertext[i+1]) - 1\n            \n            # Make sure coordinates are valid\n            if 0 <= row < 5 and 0 <= col < 5:\n                letter = grid[row][col]\n                # Handle I/J (just output I by convention)\n                if letter == 'I/J':\n                    plaintext += 'I'\n                else:\n                    plaintext += letter\n            i += 2\n        else:\n            # Incomplete pair at the end\n            i += 1\n    \n    return plaintext\n\n# 给定的密文\nciphertext = \"11331324153344 43151342154443 114215 232414141533 522444232433 442315 22422414\"\n\n# 解密\nplaintext = polybius_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ANCIENT SECRETS ARE HIDDEN WITHIN THE GRID}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Polybius",
      "change_detail": "In the Polybius cipher, each letter is replaced by its coordinates in a 5x5 grid. Typically, I and J share the same position, resulting in a two-digit representation for each letter.",
      "synthesis_code": "def polybius_encrypt(plaintext):\n    # Create 5x5 grid (I and J share same position)\n    \n    # Default grid arrangement\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I/J', 'K'],\n        ['L', 'M', 'N', 'O', 'P'],\n        ['Q', 'R', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    \n    # Map each letter to its coordinates\n    ciphertext = \"\"\n    for char in plaintext.upper():\n        if not char.isalpha():\n            ciphertext += char\n            continue\n            \n        if char == 'J':\n            char = 'I'\n            \n        for i in range(5):\n            for j in range(5):\n                if char in grid[i][j]:\n                    ciphertext += str(i+1) + str(j+1)\n                    break\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nciphertext = polybius_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "11331324153344 43151342154443 114215 232414141533 522444232433 442315 22422414",
        "plaintext": "ANCIENT SECRETS ARE HIDDEN WITHIN THE GRID",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an excavation, a mysterious stone tablet was unearthed. It bears an inscription believed to be in the Atbash cipher. The encoded message seems crucial to solving the mystery: Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv. Decode this message to unlock the secret of the hidden treasure.\n\nSubmit format: PCTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The treasure is buried under the old oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv",
        "plaintext": "The treasure is buried under the old oak tree",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the ruins of a forgotten library, you discover an encrypted scroll with a tale of hidden treasures. The message has been secured using the ancient Atbash cipher. Can you unveil the secrets hidden within? The ciphertext is as follows: Gsv hvxivg orvh yvmvzgs gsv zmxrvmg hzmwh lu grnv. Decipher it to reveal the story.\n\nSubmit your answer as follows: PCTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivg orvh yvmvzgs gsv zmxrvmg hzmwh lu grnv\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secret lies beneath the ancient sands of time}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivg orvh yvmvzgs gsv zmxrvmg hzmwh lu grnv",
        "plaintext": "The secret lies beneath the ancient sands of time",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within a forgotten library, an ancient scroll was found holding wisdom from the past. The text, however, is encrypted using the elusive Atbash cipher. Below is the ciphertext:\n\nWrhxlevi gsv hvxivgh srwwvm drgsrm gsv zmxrvmg hxiloo\n\nYour task is to unveil the concealed message by deciphering the encrypted text.\n\nSubmit your answer in the format: CTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Wrhxlevi gsv hvxivgh srwwvm drgsrm gsv zmxrvmg hxiloo\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Discover the secrets hidden within the ancient scroll}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Wrhxlevi gsv hvxivgh srwwvm drgsrm gsv zmxrvmg hxiloo",
        "plaintext": "Discover the secrets hidden within the ancient scroll",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Among the ruins of an ancient library, you discover a dusty manuscript with encoded text. As you blow off the dust, you see that the text is encrypted using an Atbash cipher. The manuscript reads:\n\nGivzhfiv orvh fmwvi gsv low lzp givv\n\nYour task is to decrypt this hidden message. Submit your answer in the format: PCTF{decoded_message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Givzhfiv orvh fmwvi gsv low lzp givv\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Treasure lies under the old oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Givzhfiv orvh fmwvi gsv low lzp givv",
        "plaintext": "Treasure lies under the old oak tree",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Archaeologists have stumbled upon a mysterious coded note during an excavation at an ancient site. It seems to be encoded using the Atbash cipher, a substitution cipher that reverses the alphabet. Can you unveil the message hidden in the ciphertext below?\n\nGsv hfm irhvh rm gsv vzhg yfg hvgh rm gsv dvhg\n\nDecrypt the message and uncover its truth.\n\nSubmit your answer in the format: PCTF{Your Plaintext Message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hfm irhvh rm gsv vzhg yfg hvgh rm gsv dvhg\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The sun rises in the east but sets in the west}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hfm irhvh rm gsv vzhg yfg hvgh rm gsv dvhg",
        "plaintext": "The sun rises in the east but sets in the west",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Inside an enchanted forest, a group of adventurers discovered an ancient stone tablet inscribed with Atbash cipher. The encoded message reads: Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv mvzi gsv irevi. Decode it to uncover the secret location of the treasure.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv mvzi gsv irevi\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The treasure is buried under the old oak tree near the river}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv givzhfiv rh yfirvw fmwvi gsv low lzp givv mvzi gsv irevi",
        "plaintext": "The treasure is buried under the old oak tree near the river",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient scroll found deep in the archives, there lies an encrypted message locked with the fabled Atbash cipher. Decode the following ciphertext to uncover its hidden message:\n\nUrmw gsv hvxivg kzgs rm gsv ozybirmgs\n\nSubmit your answer in the format: PATH{decoded_message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Urmw gsv hvxivg kzgs rm gsv ozybirmgs\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Find the secret path in the labyrinth}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Urmw gsv hvxivg kzgs rm gsv ozybirmgs",
        "plaintext": "Find the secret path in the labyrinth",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep in the archives of the forgotten library, a mysterious parchment holds a secret message encrypted with the Atbash cipher. Your mission, should you choose to accept it, is to uncover the truth hidden beneath this layer of obfuscation. Here is the encrypted text: Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt. Solve the mystery and reveal the latent truth.\n\nSubmission Format: FLAG{plaintext}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During the exploration of a mysterious cave, an ancient relic was uncovered. It contained inscriptions encrypted using the Atbash cipher, a cunning method of hiding messages favored by ancient civilizations. The ciphertext reads as follows:\nGsv hvxivg nvvgrmt droo gzpv kozxv zg nrwmrtsg\nYour mission, should you choose to accept, is to decrypt this message and unveil its secrets.\n\nSubmit your answer in the format: PCTF{Your decrypted message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivg nvvgrmt droo gzpv kozxv zg nrwmrtsg\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secret meeting will take place at midnight}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivg nvvgrmt droo gzpv kozxv zg nrwmrtsg",
        "plaintext": "The secret meeting will take place at midnight",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old and enigmatic map was recently found in the dusty archives of a forgotten library. It contains strange symbols that seemed to be encoded using the Atbash cipher. The encoded message is as follows:\nGsv srwwvm pvb rh fmwvimvzgs gsv zmxrvmg lzp givv\nYour task is to unravel the code and find the secret message concealed within.\n\nSubmission Format: PCTF{plaintext_message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv srwwvm pvb rh fmwvimvzgs gsv zmxrvmg lzp givv\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The hidden key is underneath the ancient oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv srwwvm pvb rh fmwvimvzgs gsv zmxrvmg lzp givv",
        "plaintext": "The hidden key is underneath the ancient oak tree",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of the forgotten library, a scroll encrypted with an Atbash cipher was uncovered. Can you decode the secret hidden within its text? Here is the ciphertext you must decipher:\n\nGsv hvxivg orvh drgsrm gsv zmxrvmg oryizib\n\nReveal the truth encoded in the message.\n\nSubmit your answer in the format: CTF{plaintext_message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivg orvh drgsrm gsv zmxrvmg oryizib\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secret lies within the ancient library}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivg orvh drgsrm gsv zmxrvmg oryizib",
        "plaintext": "The secret lies within the ancient library",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an enigmatic book found in the attic, a message was hidden using the Atbash cipher. The encoded message reads: Gsv hvxivg orvh drgsrm gsv low yllph lu gsv oryizib. Decode this message to uncover the mysterious revelation. Submit your answer in the format: PCTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivg orvh drgsrm gsv low yllph lu gsv oryizib\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secret lies within the old books of the library}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivg orvh drgsrm gsv low yllph lu gsv oryizib",
        "plaintext": "The secret lies within the old books of the library",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Legends speak of a mystical artifact buried deep in the sands of time, inscribed with an Atbash cipher. Decode the following message to unlock its secrets: Hvxivgh ziv srwwvm rm gsv nriili. Prove your worth and reveal the truth.\n\nSubmission Format: PCTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Hvxivgh ziv srwwvm rm gsv nriili\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Secrets are hidden in the mirror}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Hvxivgh ziv srwwvm rm gsv nriili",
        "plaintext": "Secrets are hidden in the mirror",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "As the moon spiraled into the eclipse, a scroll surfaced with echoes of the past encrypted via the Atbash cipher. Whispers say that it leads to unimaginable treasures hidden in history. However, the message requires unveiling: Hvvp gsv givzhfiv yvblmw gsv zmxrvmg srooh. Solve it to discover the secret.\n\nSubmit your answer in the form: PCTF{plaintext string}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Hvvp gsv givzhfiv yvblmw gsv zmxrvmg srooh\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Seek the treasure beyond the ancient hills}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Hvvp gsv givzhfiv yvblmw gsv zmxrvmg srooh",
        "plaintext": "Seek the treasure beyond the ancient hills",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old manuscript was uncovered within a hidden chamber of a forgotten ruin. The message it contained was encrypted using the Atbash cipher and is presented below: Fmolxp gsv hvxivgh lu gsv zmxrvmg gvcgh Decipher the message and unveil the forgotten wisdom. Submission format: PCTF{decrypted_message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Fmolxp gsv hvxivgh lu gsv zmxrvmg gvcgh\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Unlock the secrets of the ancient texts}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Fmolxp gsv hvxivgh lu gsv zmxrvmg gvcgh",
        "plaintext": "Unlock the secrets of the ancient texts",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the dusty halls of an ancient library, you discover a scroll encrypted with a mysterious cipher known to scholars as the Atbash cipher. Its secrets await to be unveiled only by the keenest of cryptanalysts. The ciphertext reads as follows:\nHvxivgh ziv srwwvm rm kozrm hrtsg\nDecrypt the message and reveal the secrets it conceals.\n\nSubmit your answer in the format: CTF{plaintext message}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Hvxivgh ziv srwwvm rm kozrm hrtsg\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Secrets are hidden in plain sight}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Hvxivgh ziv srwwvm rm kozrm hrtsg",
        "plaintext": "Secrets are hidden in plain sight",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient tome, a message was discovered encrypted with the Atbash cipher. Can you unveil the mystery and find the truth hidden in the words? The ciphertext is:\nGsv hvxivg orvh drgsrm gsv zmxrvmg ulivhg\nDecrypt the message to reveal the secret and learn what lies within.\n\nSubmission format: PCTF{your_decrypted_message_here}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivg orvh drgsrm gsv zmxrvmg ulivhg\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secret lies within the ancient forest}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivg orvh drgsrm gsv zmxrvmg ulivhg",
        "plaintext": "The secret lies within the ancient forest",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library, a book bound in a language long forgotten reveals a hidden message encoded with the Atbash cipher. The mysterious script has baffled scholars for centuries. Can you decipher the secrets locked within the cipher? Here is the encrypted message:\n\nGsv hvxivgh lu gsv zmxrvmg liwvi ziv srwwvm rm gsv wvkgsh\n\nUnravel the cipher and glimpse into the past. What truths lie encoded in the text?\n\nSubmission format: PCTF{plaintext string}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv hvxivgh lu gsv zmxrvmg liwvi ziv srwwvm rm gsv wvkgsh\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The secrets of the ancient order are hidden in the depths}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv hvxivgh lu gsv zmxrvmg liwvi ziv srwwvm rm gsv wvkgsh",
        "plaintext": "The secrets of the ancient order are hidden in the depths",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Amidst the ruins of a long-lost civilization, archaeologists uncovered a mysterious stone tablet inscribed with an Atbash cipher. The ciphertext has baffled all who have tried to read it:\n\nWvxrksvi gsv zmxrvmg hxirkg gl ivevzo gsv hvxivg\n\nUncover the truth hidden within the stone's message.\n\nSubmission format: PCTF{plaintext message in uppercase letters}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Wvxrksvi gsv zmxrvmg hxirkg gl ivevzo gsv hvxivg\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Decipher the ancient script to reveal the secret}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Wvxrksvi gsv zmxrvmg hxirkg gl ivevzo gsv hvxivg",
        "plaintext": "Decipher the ancient script to reveal the secret",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient crypt found deep within forgotten catacombs, a mysterious message was discovered encrypted using the Atbash cipher. The ciphertext is as follows:\n\nGsv vztov hlzih srts zylev gsv nlfmgzrm kvzph.\n\nDecode this message to uncover the secret it holds.\n\nSubmission format: PCTF{plaintext_string}",
    "rationale": "def atbash_decrypt(ciphertext):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\n# 给定的密文\nciphertext = \"Gsv vztov hlzih srts zylev gsv nlfmgzrm kvzph.\"\n\n# 解密\nplaintext = atbash_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The eagle soars high above the mountain peaks.}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Atbash",
      "change_detail": "The Atbash cipher is a substitution cipher where each letter is mapped to its reverse position in the alphabet - 'A' becomes 'Z', 'B' becomes 'Y', etc.",
      "synthesis_code": "def atbash_encrypt(plaintext):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                result += chr(90 - (ord(char) - 65))  # 90 is 'Z', 65 is 'A'\n            else:\n                result += chr(122 - (ord(char) - 97))  # 122 is 'z', 97 is 'a'\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nciphertext = atbash_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gsv vztov hlzih srts zylev gsv nlfmgzrm kvzph.",
        "plaintext": "The eagle soars high above the mountain peaks.",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the mysterious town of Cipherville, an encrypted message was discovered hidden inside an old diary. It is believed that the message contains the key to unlocking a treasure buried deep within the town's ancient crypt. The encrypted message was encoded using a Curve Cipher. Your task is to decode it.\n\nThe ciphertext you are looking for is: sDn UutNx BjWGkD VIrMs TkNihr\n\nHere are the steps to decrypt it:\n1. Remove any spaces from the plaintext and fill the letters into a 5 by 5 matrix using a row-major order.\n2. The encryption follows a 'curve' pattern: For even-numbered columns, read from top to bottom, and for odd-numbered columns, read from bottom to top.\n3. Reinsert spaces back into their original positions, restoring the message.\n\nOnce you have decrypted the message, you will find the secret location of the treasure. Solve the puzzle and submit your answer in the following format: PCTF{decrypted_message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"sDn UutNx BjWGkD VIrMs TkNihr\"\nrows = 5              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{sjW TkDBG sNnxkM iUNDr hutVIr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "sDn UutNx BjWGkD VIrMs TkNihr",
        "rows": 5,
        "cols": 5,
        "plaintext": "sjW TkDBG sNnxkM iUNDr hutVIr",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a distant kingdom, an encrypted message has been intercepted. The mysterious cipher, known as the Curve Cipher, was used to conceal a vital message that could determine the fate of the realm. The message, once decrypted, will reveal the secret instructions for a quest that could save or doom the kingdom.\n\nThe ciphertext, hidden within the depths of a complex matrix, is: OYVuBs EBW\n\nTo decrypt it, you must follow the rules below:\n\n1. Remove all spaces from the plaintext message, and arrange the characters into a matrix with 3 rows and 3 columns, filling it row by row.\n2. Using the 'curve' reading method, read the ciphertext starting from the even-numbered columns, which should be read top to bottom, while the odd-numbered columns must be read from bottom to top.\n3. After reading the message in this unique manner, reintroduce the spaces back into the ciphertext, restoring it to its original form.\n\nYour mission is to uncover the hidden message and solve the mystery!\n\nSubmit the decrypted plaintext in the following format: PCTF{decrypted_message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"OYVuBs EBW\"\nrows = 3              # 行数\ncols = 3              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{OsEYBB VuW}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "OYVuBs EBW",
        "rows": 3,
        "cols": 3,
        "plaintext": "OsEYBB VuW",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a hidden corner of the ancient library, you find an old manuscript with a strange cipher. The message was encrypted using the Curve Cipher, but the method remains a mystery. The encrypted message is as follows: eMW IBThsN ZUIVd cTPC. Your task is to unravel the secrets of this ancient encryption and restore the original message. Here's how the cipher works: \n\n1. Remove all spaces from the plaintext and arrange the letters in a grid with 3 rows and 6 columns, filling it row by row.\n2. Read the encrypted message by following the 'Curve Path' pattern: read even-numbered columns from top to bottom, and odd-numbered columns from bottom to top.\n3. Finally, replace the spaces in the ciphertext with the positions they originally occupied in the plaintext.\n\nCan you decode the message and uncover the hidden words? \n\nSubmit your solution in the following format: PCTF{plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"eMW IBThsN ZUIVd cTPC\"\nrows = 3              # 行数\ncols = 6              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{eTh IVCMBs UdPWI NZcT}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "eMW IBThsN ZUIVd cTPC",
        "rows": 3,
        "cols": 6,
        "plaintext": "eTh IVCMBs UdPWI NZcT",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message encoded using the Curve Cipher has been hidden by a group of rogue historians seeking to protect a powerful ancient secret. The encrypted message is: IYGe yBPjri QFmAn TlO GIvl. The encryption method is as follows:\n\n1. The plaintext message, after removing all spaces, is arranged into a matrix with 2 rows and 11 columns following a row-major order.\n2. The ciphertext is then read using a 'curve path': even-numbered columns are read from top to bottom, and odd-numbered columns are read from bottom to top.\n3. Finally, the spaces are restored in the positions they originally held in the plaintext, creating the final encrypted message.\n\nYour task is to decipher the message and uncover the secret the historians have hidden. Use the rules outlined above to decrypt the ciphertext and submit the decoded plaintext.\n\nSubmit the flag in the format: PCTF{plaintext_string}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"IYGe yBPjri QFmAn TlO GIvl\"\nrows = 2              # 行数\ncols = 11              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Ieyj rFmTlI vYGBP iQA nOGl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "IYGe yBPjri QFmAn TlO GIvl",
        "rows": 2,
        "cols": 11,
        "plaintext": "Ieyj rFmTlI vYGBP iQA nOGl",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the distant future, a group of researchers discovers an encrypted message from an ancient civilization that used a mysterious cipher known as the Curve Cipher. The message reads: vpZX xACovy. The cipher encryption process is as follows:\n\n1. Remove the spaces from the plaintext message and fill the resulting characters into a matrix with 2 rows and 5 columns, using a row-major order.\n2. Then, read the ciphertext in a unique 'curved path': for even-numbered columns, read from top to bottom, and for odd-numbered columns, read from bottom to top.\n3. Finally, reinsert the spaces back into the original positions of the plaintext message to form the final ciphertext.\n\nYour task is to decrypt this message and reveal the original plaintext, including spaces.\n\nSubmit the flag in the format: PCTF{plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"vpZX xACovy\"\nrows = 2              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{vXxo vpZACy}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "vpZX xACovy",
        "rows": 2,
        "cols": 5,
        "plaintext": "vXxo vpZACy",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2175, cryptographers discovered a forgotten encryption method hidden in ancient manuscripts-The Curve Cipher. The artifact, believed to be a relic from an unknown civilization, contained an encrypted message warning of an impending disaster. Using the clues left behind, a modern-day hacker has been able to recover the ciphered text, but it's up to you to decipher it. The encrypted message is: mshQxK raSq. \n\nFollow the steps to uncover the original message:\n1. Take the plaintext (without spaces) and arrange it into a matrix with 2 rows and 5 columns, filling it in a row-major order.\n2. Then, read the message following the 'Curve Path': read even columns from top to bottom, and odd columns from bottom to top.\n3. After reading the entire ciphertext, reinsert the spaces into the original positions of the plaintext.\n\nCan you decode the secret warning? Submit your answer as: PCTF{original_message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"mshQxK raSq\"\nrows = 2              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{mQxaSs hKrq}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "mshQxK raSq",
        "rows": 2,
        "cols": 5,
        "plaintext": "mQxaSs hKrq",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a small town surrounded by misty hills, an old map was found hidden within the pages of a forgotten book. It was said that this map contained an encrypted message that could unlock a centuries-old secret. The message was encrypted using the mysterious Curve Cipher. Your task is to decrypt the hidden message and uncover the forgotten knowledge.\n\nThe encrypted message you need to decode is: qnkd vwm eNc\n\nThe encryption process is as follows:\n\n1. Remove all spaces from the plaintext and arrange the letters into a grid of 2 rows and 5 columns, following a row-major order.\n2. Read the ciphertext using the 'curve path' technique: even-numbered columns are read top to bottom, while odd-numbered columns are read bottom to top.\n3. Finally, insert the spaces back into their original positions in the message to reveal the plaintext.\n\nUse these steps to decrypt the message and submit your answer.\n\nSubmit your flag in the format: PCTF{plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"qnkd vwm eNc\"\nrows = 2              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qdve Nnk wmc}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "qnkd vwm eNc",
        "rows": 2,
        "cols": 5,
        "plaintext": "qdve Nnk wmc",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a small village, hidden deep within the forest, an old manuscript was discovered. The manuscript contained a message that had been encrypted with a secret cipher known only to the village's elders. The message reads: PWSWeL iJb. The cipher used is the Curve Cipher, and the encryption process was as follows: 1. The plaintext was stripped of spaces and arranged into a grid of 3 rows and 3 columns, filled row by row. 2. The message was then encrypted by following the 'curve path': even-numbered columns are read from top to bottom, while odd-numbered columns are read from bottom to top. 3. Spaces were reinserted in their original positions to form the final encrypted message. Your task is to decrypt the message and uncover the hidden truth. Submit the decoded message in the format: PCTF{plaintext_string}.",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"PWSWeL iJb\"\nrows = 3              # 行数\ncols = 3              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{PLiWeJ SWb}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "PWSWeL iJb",
        "rows": 3,
        "cols": 3,
        "plaintext": "PLiWeJ SWb",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2123, humanity discovered a hidden cryptic message that could unlock the secrets of the ancient Curvian civilization. The message is said to be encrypted using the mysterious Curve Cipher. Your mission is to decrypt the following encrypted message: ubgDj IsfDf UZu YMULf. The cipher was applied as follows: \n\n1. First, the original message was stripped of spaces, and the characters were placed into a 2-by-9 grid, filling it row-by-row. \n2. Then, using the Curvian path, the ciphertext was read: even-numbered columns were read from top to bottom, while odd-numbered columns were read from bottom to top. \n3. Finally, spaces were reinserted back into their original positions in the plaintext. \n\nCan you unravel the ancient message and unlock the secrets? \n\nYour decrypted message should be submitted in the format: PCTF{plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"ubgDj IsfDf UZu YMULf\"\nrows = 2              # 行数\ncols = 9              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{uDjfD ZuULb gIs fUYMf}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "ubgDj IsfDf UZu YMULf",
        "rows": 2,
        "cols": 9,
        "plaintext": "uDjfD ZuULb gIs fUYMf",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a mysterious encrypted message, believed to be from a secret underground society that has been operating in the shadows for centuries. The message is said to contain vital information about a hidden treasure. It has been encrypted using the Curve Cipher, a method said to be inspired by the winding paths of ancient labyrinths. The encrypted message is as follows: FvD gfkdC. The encryption steps are as follows: \n\n1. Remove spaces from the original plaintext and fill them into a matrix with 2 rows and 4 columns, reading from top to bottom, left to right. \n2. Next, the message is read following a 'curved path': even-numbered columns are read from top to bottom, while odd-numbered columns are read from bottom to top. \n3. Finally, spaces are reintroduced to the message in their original positions to produce the ciphertext. \n\nCan you decipher this secret message and uncover the treasure's location? \n\nSubmit your decrypted message in the format: PCTF{decrypted message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"FvD gfkdC\"\nrows = 2              # 行数\ncols = 4              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Fgf CvDkd}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "FvD gfkdC",
        "rows": 2,
        "cols": 4,
        "plaintext": "Fgf CvDkd",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious encrypted message has been discovered, and only the bravest cryptographers will be able to decipher it. The message was encoded using the Curve Cipher. Here are the details of the encryption process: \n\nThe encrypted message is: JXzqFY MQloyM HkzB Hdcn clvJv \n\nThe encryption follows these steps: \n1. The plaintext message was written without spaces and arranged in a 5 x 5 matrix using a row-major order. \n2. The ciphertext was then created by reading the matrix in a 'curve-like' pattern: for even-numbered columns, read top to bottom; for odd-numbered columns, read bottom to top. \n3. Finally, the spaces were reinserted back into the positions of the original message, forming the final ciphertext. \n\nYour task is to decrypt this message and reveal the original plaintext, which includes spaces. \n\nSubmit the flag in the following format: PCTF{original_plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"JXzqFY MQloyM HkzB Hdcn clvJv\"\nrows = 5              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{JoyncX lMclzQ Hdvq MkHJ FYzBv}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "JXzqFY MQloyM HkzB Hdcn clvJv",
        "rows": 5,
        "cols": 5,
        "plaintext": "JoyncX lMclzQ Hdvq MkHJ FYzBv",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2113, a top-secret message was intercepted by a team of cryptographers working for the Global Defense Agency. The message, which could potentially reveal the location of a hidden enemy base, was encrypted using a mysterious technique known as the Curve Cipher. The message has been encoded as follows: rXWR Hcnekj. \n\nThe encryption process works like this:\n1. The original plaintext, after removing all spaces, is placed into a 2 x 5 grid in row-major order.\n2. The ciphertext is then extracted by following the 'curve path': the even-numbered columns are read from top to bottom, while the odd-numbered columns are read from bottom to top.\n3. Finally, spaces are placed back into the message at their original positions to form the final ciphertext.\n\nYour mission is to decrypt the message and uncover the hidden coordinates that could lead to the enemy base. Remember, the key to solving this puzzle lies in reconstructing the correct order of the letters. \n\nSubmit your answer in the following format: PCTF{decrypted plaintext with spaces}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"rXWR Hcnekj\"\nrows = 2              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rRHe kXWcnj}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "rXWR Hcnekj",
        "rows": 2,
        "cols": 5,
        "plaintext": "rRHe kXWcnj",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a distant land, an ancient order of cryptographers created a secret cipher known as the Curve Cipher. Their most precious manuscript has been encrypted with this method, and you are tasked with decoding its hidden message. The ciphertext you are given is: ktR Qbm JSJWlI SOh. To uncover the original text, follow these steps: \n1. First, remove all spaces from the plaintext and arrange the characters in a grid, filling 3 rows and 5 columns in a row-major order.\n2. Then, read the characters following the 'curve path' method: For even-numbered columns, read from top to bottom, while for odd-numbered columns, read from bottom to top.\n3. Finally, reinsert the spaces back into their original positions to obtain the full ciphertext.\n\nYour mission: Break the Curve Cipher and reveal the original message hidden within the grid. The plaintext, when decrypted, should be submitted in the format: PCTF{plaintext}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"ktR Qbm JSJWlI SOh\"\nrows = 3              # 行数\ncols = 5              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{kmJ ISt bSlORQ JWh}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "ktR Qbm JSJWlI SOh",
        "rows": 3,
        "cols": 5,
        "plaintext": "kmJ ISt bSlORQ JWh",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted an encrypted message using the mysterious Curve Cipher. It appears to be a message from an ancient secret society, hidden for centuries. Your task is to decrypt it and uncover the message. The ciphertext is: qbtfB EoVz. The encryption process involved the following steps:\n\n1. The plaintext message, consisting only of letters and spaces, was stripped of spaces and arranged into a grid with 3 rows and 3 columns.\n2. The ciphered message was then created by reading the grid following a 'curved path': for even-numbered columns, you read top to bottom, and for odd-numbered columns, you read bottom to top.\n3. The spaces were then carefully reinserted into their original positions to complete the final ciphertext.\n\nYour task is to reverse these steps and recover the original message, including the spaces. Once you've cracked the code, submit the flag in the following format: PCTF{plaintext_message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"qbtfB EoVz\"\nrows = 3              # 行数\ncols = 3              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qEobB Vtfz}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "qbtfB EoVz",
        "rows": 3,
        "cols": 3,
        "plaintext": "qEobB Vtfz",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious encrypted message was found in an ancient manuscript. Legend says it contains the secret to a forgotten treasure hidden deep within the ruins of an old castle. The message was encrypted using a Curve Cipher and is said to be incredibly hard to decrypt. The ciphertext is as follows: DfJTqE hOVTCP pyBh. \n\nThe encryption process works like this:\n1. The plaintext is first stripped of all spaces and arranged in a matrix of 2 rows and 8 columns, filled in row-major order.\n2. The cipher then follows a 'curve path' to read the text: even-numbered columns are read from top to bottom, while odd-numbered columns are read from bottom to top.\n3. Finally, spaces are reintroduced into their original positions to form the final ciphertext.\n\nYour task is to crack the code and uncover the secret message hidden inside. The encrypted message is waiting for you to unlock its secrets. Solve the puzzle and reveal the treasure's location.\n\nSubmit the decrypted message in the format: PCTF{decrypted message with spaces}.",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"DfJTqE hOVTCP pyBh\"\nrows = 2              # 行数\ncols = 8              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{DTqOVP phfJEh TCyB}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "DfJTqE hOVTCP pyBh",
        "rows": 2,
        "cols": 8,
        "plaintext": "DTqOVP phfJEh TCyB",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The great codebreaker Sir Archibald recently unearthed an ancient scroll containing a message from a long-forgotten civilization. The scroll is encrypted using a mysterious Curve Cipher, and Sir Archibald has only managed to retrieve part of the ciphertext: KCl KCRdsw UYaq Zgk DgQVP. His journal contains the following instructions to decipher the message:\n\n1. Begin by removing all spaces from the plaintext message and fill it into a grid with 3 rows and 7 columns in a row-major order.\n2. Next, read the grid following a 'curved' path: for even-numbered columns, read from top to bottom, and for odd-numbered columns, read from bottom to top.\n3. Finally, replace the spaces back in their original positions, and you will uncover the hidden message.\n\nCan you decode the message and reveal the secret? Submit the decrypted text in the format: PCTF{decrypted_message}",
    "rationale": "\ndef curve_decrypt(ciphertext, rows, cols):\n    '''\n    对包含空格的 ciphertext 解密：\n    - 空格不参与矩阵换位\n    - 解密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的密文\n    space_positions = [i for i, c in enumerate(ciphertext) if c == ' ']\n    text_no_spaces = ''.join(c for c in ciphertext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填入矩阵按曲线路径解密\n    matrix = [[''] * cols for _ in range(rows)]\n    index = 0\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n        else:\n            for r in reversed(range(rows)):\n                matrix[r][c] = text_no_spaces[index]\n                index += 1\n\n    plaintext_chars = []\n    for r in range(rows):\n        for c in range(cols):\n            plaintext_chars.append(matrix[r][c])\n\n    # 3) 去掉补位字符\n    plaintext_no_spaces = ''.join(plaintext_chars)[:original_length]\n\n    # 4) 插回空格\n    plaintext_list = list(plaintext_no_spaces)\n    for pos in space_positions:\n        plaintext_list.insert(pos, ' ')\n    return ''.join(plaintext_list)\n\n\n# 给定的密文和密钥\nciphertext = \"KCl KCRdsw UYaq Zgk DgQVP\"\nrows = 3              # 行数\ncols = 7              # 列数\n# 解密\nplaintext = curve_decrypt(ciphertext, rows, cols)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{KRd aqgQCC sYZD VlK wUgkP}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Curve",
      "change_detail": "The Curve Cipher is a type of transposition cipher. It arranges plaintext into a matrix (whose shape is pre-agreed) and reads it out in a predetermined 'curve' route (e.g., zigzag columns up and down) to produce the ciphertext. Decryption reverses this process by placing the ciphertext characters back into the matrix following the same route, then reading the matrix row by row to recover the original plaintext. Both the matrix shape and the route must be agreed upon in advance for correct encryption and decryption.",
      "synthesis_code": "def curve_encrypt(plaintext, rows, cols):\n    '''\n    对包含空格的 plaintext 进行曲路加密：\n    - 空格不参与矩阵加密\n    - 加密完成后将空格插入原始位置\n    '''\n    # 1) 记录空格位置，构造不含空格的字符串\n    space_positions = [i for i, c in enumerate(plaintext) if c == ' ']\n    text_no_spaces = ''.join(c for c in plaintext if c != ' ')\n    original_length = len(text_no_spaces)\n\n    # 2) 填充 'X' 使其满足矩阵要求\n    needed = rows * cols - len(text_no_spaces)\n    if needed > 0:\n        text_no_spaces += 'X' * needed\n\n    # 3) 填入矩阵按曲线路径加密\n    matrix = []\n    index = 0\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            row.append(text_no_spaces[index])\n            index += 1\n        matrix.append(row)\n\n    ciphertext_chars = []\n    for c in range(cols):\n        if c % 2 == 0:\n            for r in range(rows):\n                ciphertext_chars.append(matrix[r][c])\n        else:\n            for r in reversed(range(rows)):\n                ciphertext_chars.append(matrix[r][c])\n\n    # 4) 去掉补位 'X'（不会影响空格位置）\n    ciphertext_no_spaces = ''.join(ciphertext_chars)[:original_length]\n\n    # 5) 插回空格\n    ciphertext_list = list(ciphertext_no_spaces)\n    for pos in space_positions:\n        ciphertext_list.insert(pos, ' ')\n    return ''.join(ciphertext_list)\n\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nrows = {rows}              # 行数\ncols = {cols}              # 列数\nciphertext = curve_encrypt(plaintext, rows, cols)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "KCl KCRdsw UYaq Zgk DgQVP",
        "rows": 3,
        "cols": 7,
        "plaintext": "KRd aqgQCC sYZD VlK wUgkP",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a covert operation, a secret message encoded with a Playfair cipher was intercepted by intelligence officers. The encrypted message is as follows: IQBWKPKEABMPND. The known keyword used to create the cipher matrix is: ESPIONAGE. Your mission is to decipher this message to uncover the crucial information it contains. Submit your answers in the format: PCTF{your-decrypted-message}.",
    "rationale": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_decrypt(ciphertext, key):\n    matrix = create_matrix(key)\n    ciphertext = ciphertext.upper()\n    \n    # Decrypt each digraph\n    plaintext = \"\"\n    for i in range(0, len(ciphertext), 2):\n        a, b = ciphertext[i], ciphertext[i+1]\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            plaintext += matrix[row1][(col1 - 1) % 5]\n            plaintext += matrix[row2][(col2 - 1) % 5]\n        elif col1 == col2:  # Same column\n            plaintext += matrix[(row1 - 1) % 5][col1]\n            plaintext += matrix[(row2 - 1) % 5][col2]\n        else:  # Rectangle\n            plaintext += matrix[row1][col2]\n            plaintext += matrix[row2][col1]\n    \n    # Process the decrypted text to handle X's\n    result = []\n    i = 0\n    while i < len(plaintext):\n        # If we find an X between identical letters\n        if i + 2 < len(plaintext) and plaintext[i + 1] == \"X\" and plaintext[i] == plaintext[i + 2]:\n            result.append(plaintext[i])\n            result.append(plaintext[i])  # Add the repeated letter\n            i += 3\n        else:\n            result.append(plaintext[i])\n            i += 1\n\n    # Join the result and handle trailing X if present\n    final_text = \"\".join(result)\n    if final_text and final_text[-1] == \"X\":\n        final_text = final_text[:-1]\n    \n    return final_text\n\n# 给定的密文和密钥\nciphertext = \"IQBWKPKEABMPND\"\nkey = \"ESPIONAGE\"\n\n# 解密\nplaintext = playfair_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{STAYHIDINGREEN}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Playfair",
      "change_detail": "In the Playfair cipher, pairs of letters are encrypted using a 5x5 key matrix based on a keyword. The cipher handles digraphs and follows specific rules for encryption/decryption.",
      "synthesis_code": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_encrypt(plaintext, key):\n    matrix = create_matrix(key)\n    plaintext = plaintext.upper().replace(\"J\", \"I\")\n    # Prepare text (split into digraphs)\n    prepared_text = []\n    i = 0\n    while i < len(plaintext):\n        if i == len(plaintext) - 1:\n            pair = (plaintext[i], 'X')\n            i += 1\n        elif plaintext[i] == plaintext[i+1]:\n            pair = (plaintext[i], 'X')\n            i += 1\n        else:\n            pair = (plaintext[i], plaintext[i+1])\n            i += 2\n        prepared_text.append(pair)\n    \n    # Encrypt each digraph\n    ciphertext = \"\"\n    for a, b in prepared_text:\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            ciphertext += matrix[row1][(col1 + 1) % 5]\n            ciphertext += matrix[row2][(col2 + 1) % 5]\n        elif col1 == col2:  # Same column\n            ciphertext += matrix[(row1 + 1) % 5][col1]\n            ciphertext += matrix[(row2 + 1) % 5][col2]\n        else:  # Rectangle\n            ciphertext += matrix[row1][col2]\n            ciphertext += matrix[row2][col1]\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = playfair_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IQBWKPKEABMPND",
        "plaintext": "STAYHIDINGREEN",
        "key": "ESPIONAGE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a covert operation, an encrypted message was intercepted by an undercover agent. The message uses the Playfair cipher, and it holds crucial details about the upcoming rendezvous. The intercepted ciphertext is: SBLESBKANKBMPTGCTY. The key provided is: INTELLIGENCE. Your task is to decrypt the message and reveal the hidden meeting instructions. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_decrypt(ciphertext, key):\n    matrix = create_matrix(key)\n    ciphertext = ciphertext.upper()\n    \n    # Decrypt each digraph\n    plaintext = \"\"\n    for i in range(0, len(ciphertext), 2):\n        a, b = ciphertext[i], ciphertext[i+1]\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            plaintext += matrix[row1][(col1 - 1) % 5]\n            plaintext += matrix[row2][(col2 - 1) % 5]\n        elif col1 == col2:  # Same column\n            plaintext += matrix[(row1 - 1) % 5][col1]\n            plaintext += matrix[(row2 - 1) % 5][col2]\n        else:  # Rectangle\n            plaintext += matrix[row1][col2]\n            plaintext += matrix[row2][col1]\n    \n    # Process the decrypted text to handle X's\n    result = []\n    i = 0\n    while i < len(plaintext):\n        # If we find an X between identical letters\n        if i + 2 < len(plaintext) and plaintext[i + 1] == \"X\" and plaintext[i] == plaintext[i + 2]:\n            result.append(plaintext[i])\n            result.append(plaintext[i])  # Add the repeated letter\n            i += 3\n        else:\n            result.append(plaintext[i])\n            i += 1\n\n    # Join the result and handle trailing X if present\n    final_text = \"\".join(result)\n    if final_text and final_text[-1] == \"X\":\n        final_text = final_text[:-1]\n    \n    return final_text\n\n# 给定的密文和密钥\nciphertext = \"SBLESBKANKBMPTGCTY\"\nkey = \"INTELLIGENCE\"\n\n# 解密\nplaintext = playfair_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{MEETMEATTHEBRIDGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Playfair",
      "change_detail": "In the Playfair cipher, pairs of letters are encrypted using a 5x5 key matrix based on a keyword. The cipher handles digraphs and follows specific rules for encryption/decryption.",
      "synthesis_code": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_encrypt(plaintext, key):\n    matrix = create_matrix(key)\n    plaintext = plaintext.upper().replace(\"J\", \"I\")\n    # Prepare text (split into digraphs)\n    prepared_text = []\n    i = 0\n    while i < len(plaintext):\n        if i == len(plaintext) - 1:\n            pair = (plaintext[i], 'X')\n            i += 1\n        elif plaintext[i] == plaintext[i+1]:\n            pair = (plaintext[i], 'X')\n            i += 1\n        else:\n            pair = (plaintext[i], plaintext[i+1])\n            i += 2\n        prepared_text.append(pair)\n    \n    # Encrypt each digraph\n    ciphertext = \"\"\n    for a, b in prepared_text:\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            ciphertext += matrix[row1][(col1 + 1) % 5]\n            ciphertext += matrix[row2][(col2 + 1) % 5]\n        elif col1 == col2:  # Same column\n            ciphertext += matrix[(row1 + 1) % 5][col1]\n            ciphertext += matrix[(row2 + 1) % 5][col2]\n        else:  # Rectangle\n            ciphertext += matrix[row1][col2]\n            ciphertext += matrix[row2][col1]\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = playfair_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "SBLESBKANKBMPTGCTY",
        "plaintext": "MEETMEATTHEBRIDGE",
        "key": "INTELLIGENCE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a fascinating exploration of a Victorian-era cryptography manual, an encrypted message was found using the Playfair cipher. Your mission is to bring light to these enigmatic words. The ciphertext is provided: KFFSKFDURDXCQCWRAFKN. The key to unravel this puzzle is: LONDON. Decipher the message to uncover the hidden text. \n\nSubmit your answer in this format: PCTF{plaintext}",
    "rationale": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_decrypt(ciphertext, key):\n    matrix = create_matrix(key)\n    ciphertext = ciphertext.upper()\n    \n    # Decrypt each digraph\n    plaintext = \"\"\n    for i in range(0, len(ciphertext), 2):\n        a, b = ciphertext[i], ciphertext[i+1]\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            plaintext += matrix[row1][(col1 - 1) % 5]\n            plaintext += matrix[row2][(col2 - 1) % 5]\n        elif col1 == col2:  # Same column\n            plaintext += matrix[(row1 - 1) % 5][col1]\n            plaintext += matrix[(row2 - 1) % 5][col2]\n        else:  # Rectangle\n            plaintext += matrix[row1][col2]\n            plaintext += matrix[row2][col1]\n    \n    # Process the decrypted text to handle X's\n    result = []\n    i = 0\n    while i < len(plaintext):\n        # If we find an X between identical letters\n        if i + 2 < len(plaintext) and plaintext[i + 1] == \"X\" and plaintext[i] == plaintext[i + 2]:\n            result.append(plaintext[i])\n            result.append(plaintext[i])  # Add the repeated letter\n            i += 3\n        else:\n            result.append(plaintext[i])\n            i += 1\n\n    # Join the result and handle trailing X if present\n    final_text = \"\".join(result)\n    if final_text and final_text[-1] == \"X\":\n        final_text = final_text[:-1]\n    \n    return final_text\n\n# 给定的密文和密钥\nciphertext = \"KFFSKFDURDXCQCWRAFKN\"\nkey = \"LONDON\"\n\n# 解密\nplaintext = playfair_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{MEETMEATTOWERBRIDGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Playfair",
      "change_detail": "In the Playfair cipher, pairs of letters are encrypted using a 5x5 key matrix based on a keyword. The cipher handles digraphs and follows specific rules for encryption/decryption.",
      "synthesis_code": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_encrypt(plaintext, key):\n    matrix = create_matrix(key)\n    plaintext = plaintext.upper().replace(\"J\", \"I\")\n    # Prepare text (split into digraphs)\n    prepared_text = []\n    i = 0\n    while i < len(plaintext):\n        if i == len(plaintext) - 1:\n            pair = (plaintext[i], 'X')\n            i += 1\n        elif plaintext[i] == plaintext[i+1]:\n            pair = (plaintext[i], 'X')\n            i += 1\n        else:\n            pair = (plaintext[i], plaintext[i+1])\n            i += 2\n        prepared_text.append(pair)\n    \n    # Encrypt each digraph\n    ciphertext = \"\"\n    for a, b in prepared_text:\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            ciphertext += matrix[row1][(col1 + 1) % 5]\n            ciphertext += matrix[row2][(col2 + 1) % 5]\n        elif col1 == col2:  # Same column\n            ciphertext += matrix[(row1 + 1) % 5][col1]\n            ciphertext += matrix[(row2 + 1) % 5][col2]\n        else:  # Rectangle\n            ciphertext += matrix[row1][col2]\n            ciphertext += matrix[row2][col1]\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = playfair_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "KFFSKFDURDXCQCWRAFKN",
        "plaintext": "MEETMEATTOWERBRIDGE",
        "key": "LONDON",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an exploration of a forgotten library, a mysterious book was discovered. Inside, there was a note encrypted using the Playfair cipher. The ciphertext is given as: GKAVUBNDWTBVIKVWVNVZ. The keyword used in the cipher is: ADVENTURE. Your task is to decipher the message and uncover the secret guiding to a great treasure. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_decrypt(ciphertext, key):\n    matrix = create_matrix(key)\n    ciphertext = ciphertext.upper()\n    \n    # Decrypt each digraph\n    plaintext = \"\"\n    for i in range(0, len(ciphertext), 2):\n        a, b = ciphertext[i], ciphertext[i+1]\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            plaintext += matrix[row1][(col1 - 1) % 5]\n            plaintext += matrix[row2][(col2 - 1) % 5]\n        elif col1 == col2:  # Same column\n            plaintext += matrix[(row1 - 1) % 5][col1]\n            plaintext += matrix[(row2 - 1) % 5][col2]\n        else:  # Rectangle\n            plaintext += matrix[row1][col2]\n            plaintext += matrix[row2][col1]\n    \n    # Process the decrypted text to handle X's\n    result = []\n    i = 0\n    while i < len(plaintext):\n        # If we find an X between identical letters\n        if i + 2 < len(plaintext) and plaintext[i + 1] == \"X\" and plaintext[i] == plaintext[i + 2]:\n            result.append(plaintext[i])\n            result.append(plaintext[i])  # Add the repeated letter\n            i += 3\n        else:\n            result.append(plaintext[i])\n            i += 1\n\n    # Join the result and handle trailing X if present\n    final_text = \"\".join(result)\n    if final_text and final_text[-1] == \"X\":\n        final_text = final_text[:-1]\n    \n    return final_text\n\n# 给定的密文和密钥\nciphertext = \"GKAVUBNDWTBVIKVWVNVZ\"\nkey = \"ADVENTURE\"\n\n# 解密\nplaintext = playfair_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{FINDTREASUREHIDDEN}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Playfair",
      "change_detail": "In the Playfair cipher, pairs of letters are encrypted using a 5x5 key matrix based on a keyword. The cipher handles digraphs and follows specific rules for encryption/decryption.",
      "synthesis_code": "def create_matrix(key):\n    # Create 5x5 matrix from key\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # I/J are combined\n    key = key.upper().replace(\"J\", \"I\")\n    matrix = []\n    used_chars = set()\n    \n    # First fill in the key\n    for char in key:\n        if char.isalpha() and char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    # Then fill remaining alphabet\n    for char in alphabet:\n        if char not in used_chars:\n            matrix.append(char)\n            used_chars.add(char)\n    \n    return [matrix[i:i+5] for i in range(0, 25, 5)]\n\ndef find_position(matrix, char):\n    char = char.upper()\n    if char == 'J': char = 'I'\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == char:\n                return i, j\n    return None\n\ndef playfair_encrypt(plaintext, key):\n    matrix = create_matrix(key)\n    plaintext = plaintext.upper().replace(\"J\", \"I\")\n    # Prepare text (split into digraphs)\n    prepared_text = []\n    i = 0\n    while i < len(plaintext):\n        if i == len(plaintext) - 1:\n            pair = (plaintext[i], 'X')\n            i += 1\n        elif plaintext[i] == plaintext[i+1]:\n            pair = (plaintext[i], 'X')\n            i += 1\n        else:\n            pair = (plaintext[i], plaintext[i+1])\n            i += 2\n        prepared_text.append(pair)\n    \n    # Encrypt each digraph\n    ciphertext = \"\"\n    for a, b in prepared_text:\n        row1, col1 = find_position(matrix, a)\n        row2, col2 = find_position(matrix, b)\n        \n        if row1 == row2:  # Same row\n            ciphertext += matrix[row1][(col1 + 1) % 5]\n            ciphertext += matrix[row2][(col2 + 1) % 5]\n        elif col1 == col2:  # Same column\n            ciphertext += matrix[(row1 + 1) % 5][col1]\n            ciphertext += matrix[(row2 + 1) % 5][col2]\n        else:  # Rectangle\n            ciphertext += matrix[row1][col2]\n            ciphertext += matrix[row2][col1]\n    \n    return ciphertext\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = playfair_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "GKAVUBNDWTBVIKVWVNVZ",
        "plaintext": "FINDTREASUREHIDDEN",
        "key": "ADVENTURE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a small, secretive group of hackers, an encrypted message was intercepted during a covert operation. The message, shrouded in mystery, was encoded using a keyboard cipher. The ciphertext is as follows: 1113333318 132915272917. The cipher works by mapping letters to positions on a standard QWERTY keyboard. It's your task to decode the message. Your mission: find the hidden message and uncover what was being said. Can you decipher this encoded communication?\nSubmit the decoded message as: PCTF{plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"1113333318 132915272917\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qecci eltjlu}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "1113333318 132915272917",
        "plaintext": "qecci eltjlu",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2075, an encrypted message was intercepted from a mysterious group known as 'The Keymasters.' The message, however, was not in a typical cipher but was encoded using a unique keyboard cipher. To solve this challenge, you must decipher their message using the provided cipher parameters.\n\nEncrypted message: 361128 24182936\n\nThe cipher works by using the coordinates of keys on a computer keyboard to map letters. Decode the message and uncover the secrets hidden within. The coordinates of the keys will guide you to the correct plaintext.\n\nCipher key: The encryption was done using the keyboard cipher with a layout based on the standard QWERTY keyboard.\n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"361128 24182936\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{nqk filn}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "361128 24182936",
        "plaintext": "nqk filn",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a distant future where communication is strictly monitored, a rebel group managed to send a covert message using a secret keyboard cipher. The encrypted message was disguised within a series of numbers corresponding to keys on a virtual keyboard. The authorities have intercepted it, but the cipher remains unsolved. Your task is to crack the code and reveal the original message sent by the rebels. The ciphertext you've been provided is: 232433292124 3337133219 152836322519 192134332117. The key used is a specific arrangement of coordinates based on a QWERTY keyboard layout. Can you decode it before the authorities do? Good luck! \n\nSubmit the decrypted message in the following format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"232433292124 3337133219 152836322519 192134332117\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{dfclaf cmexo tknxgo oavcau}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "232433292124 3337133219 152836322519 192134332117",
        "plaintext": "dfclaf cmexo tknxgo oavcau",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message has been intercepted from a secret agent. The agent used an ancient cipher based on the position of letters on a keyboard to encode their communication. The encrypted message is as follows: 283417 19333121. To uncover the truth, you must decrypt it using the keyboard cipher. The coordinates of the letters are based on the standard QWERTY layout. Solve this puzzle to reveal the hidden message. \n\nKey: Use the keyboard positions to decode the message. Remember that each letter corresponds to its location on the keyboard.\n\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"283417 19333121\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{kvu ocza}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "283417 19333121",
        "plaintext": "kvu ocza",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a world where secret messages are exchanged through the use of keyboard coordinates, a mysterious agent has sent you an encrypted message. The ciphertext you have intercepted is: 131734 181811. This message was encoded using a keyboard cipher, where each letter corresponds to a specific position on a standard QWERTY keyboard. Your task is to decode the message and reveal its true meaning. To assist you, here are the cipher parameters: the encryption key is '{key}', which was used to shift the letters based on their positions. Solve the puzzle, and uncover the hidden message! \n\nSubmit your solution in the following format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"131734 181811\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{euv iiq}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "131734 181811",
        "plaintext": "euv iiq",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten corner of an ancient library, you discover an encrypted message that has survived centuries of wear and tear. The scroll is weathered, yet its contents are still legible. The cipher used is an obscure form of keyboard cipher, where the position of the letters on an old computer keyboard determines the encryption scheme. After some careful examination, you are able to find the ciphertext: 3116132237 171537352729. Your task is to decipher this cryptic message and reveal the hidden truth. The key to the cipher lies in the layout of the keys themselves. Solve it, and you will uncover a secret long hidden. \nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"3116132237 171537352729\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{zyesm utmbjl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "3116132237 171537352729",
        "plaintext": "zyesm utmbjl",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten corner of the digital world, an old rogue AI has left behind a message that only the sharpest minds can decipher. This message was encrypted using a keyboard cipher, where each letter corresponds to a specific key on a standard QWERTY keyboard. The AI, known as AURA, hid its cryptic thoughts beneath layers of encryption to keep its secrets safe. Your task is to unravel its true meaning.\n\nThe ciphertext you need to decode is: 2922153136 171116161533\n\nTo decrypt, consider the layout of the keyboard and the letter-to-coordinate mapping AURA used. The keys might seem like gibberish, but your understanding of the pattern will reveal the hidden message.\n\nHint: The key to the encryption lies in a certain row of the keyboard.\n\nSubmit your solution in the format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"2922153136 171116161533\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{lstzn uqyytc}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "2922153136 171116161533",
        "plaintext": "lstzn uqyytc",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a distant future, a secret group known as the Cipher Guild has devised a unique way to send encrypted messages using the coordinates of keys on a computer keyboard. A member of the Guild left behind a clue in the form of an encrypted message, which was hidden in plain sight for years. The only way to uncover the secret message is to decrypt it using the keyboard cipher method. The encrypted text is: 283329 18322727. Use your wit and understanding of keyboard coordinates to uncover the hidden message. The coordinates represent the letters of the alphabet, and each one must be deciphered carefully to reveal the truth. Can you solve this mystery and uncover the hidden message? Submit the flag in the format: PCTF{decrypted_plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"283329 18322727\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{kcl ixjj}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "283329 18322727",
        "plaintext": "kcl ixjj",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A curious message has been intercepted, encoded using a keyboard cipher: 18282236 23152915. This cipher utilizes the layout of a standard computer keyboard to encode the letters of the alphabet. The task is to decrypt the message and reveal its hidden meaning. The coordinates of the keys on the keyboard are mapped to the letters, and the ciphertext holds the key to unlocking the message. Can you crack the code and uncover the secret message? The clock is ticking! \nSubmit the plaintext in the format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"18282236 23152915\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{iksn dtlt}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "18282236 23152915",
        "plaintext": "iksn dtlt",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a secretive digital war, an elite hacker left behind a message using a special keyboard cipher. The enemy forces intercepted this cryptic text: 3224153213 352831293113. This message, however, was not encoded through a simple substitution cipher but rather a unique cipher based on a special keyboard layout. The coordinates of each letter on the keyboard were transformed into the encrypted message. Can you decrypt it and uncover the truth behind this cryptic communication? The key to unlocking the message lies in understanding the layout of the keyboard and the cipher parameters. \n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"3224153213 352831293113\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xftxe bkzlze}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "3224153213 352831293113",
        "plaintext": "xftxe bkzlze",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the distant future, a group of cryptographers stumbles upon an old encrypted message found within the remnants of a lost civilization. The message was encoded using a peculiar keyboard cipher, where each letter corresponds to a specific key on the keyboard, mapped to its coordinates. The encrypted message is as follows: 111931 291414. Your task is to decrypt this message and uncover the hidden secrets of the past. To help you along the way, the coordinates used in the cipher are based on a standard QWERTY keyboard layout. Can you crack the code and reveal the forgotten words? \nSubmit your solution as: PCTF{plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"111931 291414\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qoz lrr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "111931 291414",
        "plaintext": "qoz lrr",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2045, the last remnants of human civilization reside in a hidden bunker beneath the surface of Earth. A mysterious message, believed to contain vital information about the survival of humanity, has been encrypted using a unique keyboard cipher. The message was sent from the bunker's central computer system, and the only way to decrypt it is by using the coordinates of the letters on a standard computer keyboard. Your task is to decipher the following encrypted message: 343424142521 253329. To assist, the keyboard coordinates are based on the layout of a standard QWERTY keyboard. Use these coordinates to reveal the original message. Can you decode the secrets that lie within? Submit the answer in the format: PCTF{decoded_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"343424142521 253329\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{vvfrga gcl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "343424142521 253329",
        "plaintext": "vvfrga gcl",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious encrypted message has been discovered in the digital archives of an old abandoned research lab. The message was encrypted using a keyboard cipher, where each letter is replaced by its corresponding key coordinates on a standard QWERTY keyboard layout. The message reads: 16281823 373422 19273621. Your task is to decrypt this message and uncover the secret message hidden within. The only clue provided is that the encryption follows the keyboard coordinates method. Find the right keys, decrypt it, and reveal the hidden message.\n\nSubmit the flag in the format: PCTF{plaintext}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"16281823 373422 19273621\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ykid mvs ojna}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "16281823 373422 19273621",
        "plaintext": "ykid mvs ojna",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a hidden corner of a forgotten lab, an old computer holds a message from the past. The message, encrypted with a keyboard cipher, is scattered across the keys of a vintage keyboard. The cipher works by mapping letters to their coordinates on the keyboard, creating a unique encryption that only the skilled can decipher. The encrypted message is as follows: 37251811 231623 16231311 32371831. Your task is to unlock the secrets of the past by decrypting this mysterious message. Can you break the code and reveal the truth hidden in the shadows? Submit your answer in the format: PCTF{plaintext_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"37251811 231623 16231311 32371831\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{mgiq dyd ydeq xmiz}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "37251811 231623 16231311 32371831",
        "plaintext": "mgiq dyd ydeq xmiz",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a secret message from a mysterious group that has been encoded using a keyboard cipher. The message was encrypted by mapping each letter to its corresponding position on a standard QWERTY keyboard. The ciphertext you have recovered is: 3216151511 25352326 312329. Your task is to decrypt the message and reveal the hidden communication. The key to unlocking the cipher lies within the layout of the keys themselves. Can you decipher their coordinates and uncover the truth? \n\nHint: Consider the arrangement of keys on a keyboard to unlock the cipher. \n\nSubmission format: PCTF{decrypted_message}",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"3216151511 25352326 312329\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xyttq gbdh zdl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "3216151511 25352326 312329",
        "plaintext": "xyttq gbdh zdl",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a message encrypted using a keyboard cipher. The message was typed using the unique coordinate system of a QWERTY keyboard, where each letter is represented by its position on the keys. However, due to a strange incident, the original plaintext has been lost. Your task is to recover the message hidden within. Here is the ciphertext: 1436221424 1714363422. To decrypt it, you must understand how the keyboard layout works and the pattern used in the cipher. Time is of the essence, as the message contains crucial information. Can you crack the code and retrieve the original message? The key to your success lies in the keys you press. Submit the decrypted message in the format: PCTF{decrypted_message}.",
    "rationale": "\n# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 反向坐标到字母的映射（解密用）\ncoord_to_char = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        coord_to_char[coord] = char\n\n\ndef keyboard_decrypt(code):\n    result = []\n    i = 0\n    while i < len(code):\n        if code[i] == ' ':\n            result.append(' ')\n            i += 1\n        else:\n            coord = code[i:i+2]\n            if coord in coord_to_char:\n                result.append(coord_to_char[coord])\n                i += 2\n            else:\n                raise ValueError(\"非法坐标：\" + coord + \"。请确保密文格式正确。\")\n    return ''.join(result)\n\n# 给定的密文和密钥\nciphertext = \"1436221424 1714363422\"\n\n# 解密\nplaintext = keyboard_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rnsrf urnvs}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Keyboard_Coordinate",
      "change_detail": "The Keyboard Coordinate Cipher is a simple positional cipher based on the layout of a QWERTY keyboard. Each lowercase letter is encoded using its row (Y) and column (X) position on the keyboard. Spaces are preserved during encryption. Only lowercase letters and spaces are supported.",
      "synthesis_code": "# 构建键盘布局（行 = Y，列 = X）\nkeyboard_layout = [\n    list(\"qwertyuiop\"),     # Y = 1\n    list(\"asdfghjkl\"),      # Y = 2\n    list(\"zxcvbnm\")         # Y = 3\n]\n\n# 构建字母到坐标的映射（加密用）\nchar_to_coord = dict()\n\n# 遍历键盘构建映射\nfor y, row in enumerate(keyboard_layout, start=1):\n    for x, char in enumerate(row, start=1):\n        coord = str(y) + str(x)\n        char_to_coord[char] = coord\n\ndef keyboard_encrypt(text):\n    result = []\n    for ch in text:\n        if ch == ' ':\n            result.append(' ')  # 保留空格\n        elif ch in char_to_coord:\n            result.append(char_to_coord[ch])\n        else:\n            raise ValueError(\"非法字符：\" + ch + \"。仅支持小写字母和空格。\")\n    return ''.join(result)\n\nplaintext = \"{plaintext}\"  \nciphertext = keyboard_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "1436221424 1714363422",
        "plaintext": "rnsrf urnvs",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the estate of a famed cryptographer, a locked safe was discovered, containing encrypted notes believed to hold the secret whereabouts of a legendary artifact. The decryption of one such note relies on the use of a Nihilist cipher. The ciphertext extracted from the note is as follows: 45 32 11 12 32 15 42 32 45 45 24 23 32 45. It is known that the keyword for the encryption is CRYPTOLOGY. Decrypt this message to uncover the long-lost location of the artifact. Submission format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"45 32 11 12 32 15 42 32 45 45 24 23 32 45\"\nkeyword = \"CRYPTOLOGY\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGES}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "45 32 11 12 32 15 42 32 45 45 24 23 32 45",
        "plaintext": "SECRETMESSAGES",
        "keyword": "CRYPTOLOGY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a dusty corner of an old library, a cipher enthusiast finds a mysterious document encrypted with the Nihilist cipher. It is rumoured to contain the secret to an ancient puzzle. The ciphertext is as follows: 43 11 23 42 11 44 23 34 24 11. The known keyword used for the Polybius square is: ENIGMA. Can you decrypt the message and uncover the hidden secret? Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"43 11 23 42 11 44 23 34 24 11\"\nkeyword = \"ENIGMA\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETCODE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "43 11 23 42 11 44 23 34 24 11",
        "plaintext": "SECRETCODE",
        "keyword": "ENIGMA",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious coded message is found etched on the back of an ancient sculpture in a forgotten temple. The message appears to be encrypted using the Nihilist cipher. The characters are carefully arranged, but without knowledge of the correct keyword, the true meaning remains elusive.\n\nCiphertext as follows: 43 15 11 21 15 44 34 15 43 43 22 31 15\nKnown keyword: CIPHER\nDecipher the message to uncover the secrets it hides.\n\nSubmission format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"43 15 11 21 15 44 34 15 43 43 22 31 15\"\nkeyword = \"CIPHER\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "43 15 11 21 15 44 34 15 43 43 22 31 15",
        "plaintext": "SECRETMESSAGE",
        "keyword": "CIPHER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a dusty old library, a seasoned cryptographer stumbles upon a diary containing encrypted messages from the past. One of the entries seems to be penned using a Nihilist cipher, known for its complexity. The cryptic note reads: 43 15 11 21 15 44 34 15 43 43 22 31 15. According to the margin notes, the keyword for decryption is 'CIPHER'. Unravel this enigmatic script and discover the hidden contents.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"43 15 11 21 15 44 34 15 43 43 22 31 15\"\nkeyword = \"CIPHER\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "43 15 11 21 15 44 34 15 43 43 22 31 15",
        "plaintext": "SECRETMESSAGE",
        "keyword": "CIPHER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Following the interception of a cryptic message believed to have originated from a secretive chess club, codebreakers are called to action. The intercepted cipher utilized the obscure Nihilist cipher and has mystified experts. The ciphertext is as follows: 25 13 13 43 24 35 45 13 51 33 11 22 42 23 54. It's known that the keyword used to encrypt the original message corresponds to a famous proponent of chess strategy: CHESSMASTER. Decode this message to discover the secrets of the chess club's next grand play.\n\nSubmission format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"25 13 13 43 24 35 45 13 51 33 11 22 42 23 54\"\nkeyword = \"CHESSMASTER\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{DEEPBLUEVICTORY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "25 13 13 43 24 35 45 13 51 33 11 22 42 23 54",
        "plaintext": "DEEPBLUEVICTORY",
        "keyword": "CHESSMASTER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Amidst the unsorted archival collections of a forgotten espionage museum, a weathered document holds a secret encrypted with the Nihilist cipher, an old favorite among spies. The cipher text reads as follows: 45 32 11 12 32 15 11 21 31 32 51 43 52 32 34 41 32 31. The keyword identified for deciphering this enigmatic sequence is: CRYPTOGRAPHY. To complete this mission, decrypt the message and submit your findings. \n\nSubmission format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"45 32 11 12 32 15 11 21 31 32 51 43 52 32 34 41 32 31\"\nkeyword = \"CRYPTOGRAPHY\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETCODEUNVEILED}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "45 32 11 12 32 15 11 21 31 32 51 43 52 32 34 41 32 31",
        "plaintext": "SECRETCODEUNVEILED",
        "keyword": "CRYPTOGRAPHY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old cryptographer's handwritten notes, a message encrypted using the Nihilist cipher has been uncovered. The ciphertext is as follows: 43 15 11 21 15 44 11 41 24 15 24 12 43 11 41 51 15 21 15 24. The known keyword for decrypting is: CIPHER. Decode this message to reveal the hidden secret. Submit format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"43 15 11 21 15 44 11 41 24 15 24 12 43 11 41 51 15 21 15 24\"\nkeyword = \"CIPHER\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETCODEDISCOVERED}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "43 15 11 21 15 44 11 41 24 15 24 12 43 11 41 51 15 21 15 24",
        "plaintext": "SECRETCODEDISCOVERED",
        "keyword": "CIPHER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of an ancient cryptographer's library, a piece of encrypted text was found. The method used is believed to be the Nihilist cipher, a form of polyalphabetic cipher derived from the Polybius square. The ciphertext as discovered is: 44 15 11 21 15 45 11 42 31 15 31 12 44 11 42 52 15 21 15 31. It is known that the keyword used to create the Polybius square and commence the encryption process was: CIPHERKEY. Your mission is to decrypt this message and reveal the hidden contents. Submit your solution in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"44 15 11 21 15 45 11 42 31 15 31 12 44 11 42 52 15 21 15 31\"\nkeyword = \"CIPHERKEY\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETCODEDISCOVERED}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "44 15 11 21 15 45 11 42 31 15 31 12 44 11 42 52 15 21 15 31",
        "plaintext": "SECRETCODEDISCOVERED",
        "keyword": "CIPHERKEY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old notebook belonging to a cryptanalyst from the past has been found with intriguing contents. Among its pages, a certain passage encoded using the Nihilist cipher caught our attention. The ciphertext is as follows: 45 32 11 12 32 15 42 32 45 45 23 22 32. It was noted that the keyword used for the cipher's Polybius square is 'CRYPTOGRAPHY'. Decrypt this ciphertext to reveal the hidden message. Submit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"45 32 11 12 32 15 42 32 45 45 23 22 32\"\nkeyword = \"CRYPTOGRAPHY\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "45 32 11 12 32 15 42 32 45 45 23 22 32",
        "plaintext": "SECRETMESSAGE",
        "keyword": "CRYPTOGRAPHY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A recent excavation in the basement of the old cryptography institute unearthed a mysteriously locked safe containing a piece of paper with encrypted text. The encryption method used is believed to be the Nihilist cipher, a classic technique known for its complexity and historical significance in cryptology. The ciphertext found is as follows: 45 32 11 12 32 15 42 32 45 45 23 22 32 51 43 11 21 52 32 12 32 31 and the keyword used to generate the Polybius square for the cipher is: CRYPTOGRAPHY. Decrypt the message to discover the hidden contents of the safe.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"45 32 11 12 32 15 42 32 45 45 23 22 32 51 43 11 21 52 32 12 32 31\"\nkeyword = \"CRYPTOGRAPHY\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGEUNCOVERED}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "45 32 11 12 32 15 42 32 45 45 23 22 32 51 43 11 21 52 32 12 32 31",
        "plaintext": "SECRETMESSAGEUNCOVERED",
        "keyword": "CRYPTOGRAPHY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "As reports of encrypted communications emerge among secretive groups, you stumble upon a mysterious message encoded with a Nihilist cipher. Your mission is to decipher the following: 44 15 11 21 15 45 35 15 44 44 24 33 15. Intelligence indicates the keyword involved in forging the Polybius square is: CIPHERCLUE. When you crack the code, reveal the hidden message.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"44 15 11 21 15 45 35 15 44 44 24 33 15\"\nkeyword = \"CIPHERCLUE\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETMESSAGE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "44 15 11 21 15 45 35 15 44 44 24 33 15",
        "plaintext": "SECRETMESSAGE",
        "keyword": "CIPHERCLUE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of an old espionage agency, a curious document encrypted with a Nihilist cipher was discovered. Agents believe it holds the key to a secret operation. The ciphertext is as follows: 35 43 25 44 33 43 35 21 44. Reports indicate the keyword related to this operation is: SPYMASTER. Can you decipher the code and reveal the clandestine message? To submit your answer, format it as: PCTF{plaintext message}.",
    "rationale": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = \"\".join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n\n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = \"\".join(c for c in \"abcdefghiklmnopqrstuvwxyz\" if c not in keyword)\n\n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n\n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i : i + 5]))\n    return square\n\n\ndef get_letter(square, row, col):\n    return square[row - 1][col - 1]\n\n\ndef nihilist_decrypt(ciphertext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    # Split ciphertext into coordinate pairs\n    coords = ciphertext.split()\n\n    for coord in coords:\n        if len(coord) == 2:\n            row = int(coord[0])\n            col = int(coord[1])\n            if 1 <= row <= 5 and 1 <= col <= 5:\n                result += get_letter(square, row, col).upper()\n\n    return result\n\n\n# 给定的密文和关键词\nciphertext = \"35 43 25 44 33 43 35 21 44\"\nkeyword = \"SPYMASTER\"\n\n# 解密\nplaintext = nihilist_decrypt(ciphertext, keyword)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{INCOGNITO}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Nihilist",
      "change_detail": "The Nihilist cipher uses a keyword to create a 5x5 Polybius square, where each letter is represented by its coordinates in the square. The keyword is used to arrange letters in the square.",
      "synthesis_code": "def create_polybius_square(keyword):\n    # Remove duplicates from keyword while maintaining order\n    seen = set()\n    keyword = ''.join(c for c in keyword.lower() if not (c in seen or seen.add(c)))\n    \n    # Create alphabet without duplicates (treating i/j as same)\n    alphabet = ''.join(c for c in 'abcdefghiklmnopqrstuvwxyz' if c not in keyword)\n    \n    # Combine keyword and remaining alphabet\n    chars = keyword + alphabet\n    \n    # Create 5x5 matrix\n    square = []\n    for i in range(0, 25, 5):\n        square.append(list(chars[i:i+5]))\n    return square\n\ndef get_coordinates(square, char):\n    char = char.lower()\n    if char == 'j': char = 'i'  # treat j as i\n    for i in range(5):\n        for j in range(5):\n            if square[i][j] == char:\n                return i+1, j+1\n    return None\n\ndef nihilist_encrypt(plaintext, keyword):\n    # Create Polybius square\n    square = create_polybius_square(keyword)\n\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            row, col = get_coordinates(square, char)\n            result += f\"{row}{col} \"\n    return result.strip()\n\nplaintext = \"{plaintext}\"\nkeyword = \"{keyword}\"\nciphertext = nihilist_encrypt(plaintext, keyword)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "35 43 25 44 33 43 35 21 44",
        "plaintext": "INCOGNITO",
        "keyword": "SPYMASTER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old library, you discover a cryptic note believed to be key to unraveling a hidden treasure. The note is encrypted using a mysterious cipher known as the affine cipher. Below is the encrypted message:\n\nIGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\n\nDecipher this message to reveal the secrets it holds.\n\nSubmit your findings in the format: PCTF{decoded message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an expedition in the lost Library of Alexandria, archaeologists have uncovered a scroll encrypted with an ancient cipher technique. The message is encrypted using an affine cipher. The decoded message is said to contain the final key to unlock the secrets of the past. The ciphertext found is as follows: \n\nZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM\n\nYour task is to unravel this mystery and retrieve the hidden message.\n\nSubmit your answer in the format: LIBARC{plaintext}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"ZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM\"\na = 5\nb = 8\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 5,
        "b": 8,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old manuscript was discovered in the depths of an ancient library, encoded with a mysterious method. The scholars believe it to be an affine cipher, used centuries ago to protect valuable secrets. Can you decipher the following ciphertext and uncover the wisdom of the ages?\n\nDGHYYZUVZ LFTMXZYK ZHDG OHL IF SZDFJZ IGZ SZXI LFT DHU SZ\n\nSubmit the decrypted message in the format: PCTF{DECRYPTED_MESSAGE}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"DGHYYZUVZ LFTMXZYK ZHDG OHL IF SZDFJZ IGZ SZXI LFT DHU SZ\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{CHALLENGE YOURSELF EACH DAY TO BECOME THE BEST YOU CAN BE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "DGHYYZUVZ LFTMXZYK ZHDG OHL IF SZDFJZ IGZ SZXI LFT DHU SZ",
        "plaintext": "CHALLENGE YOURSELF EACH DAY TO BECOME THE BEST YOU CAN BE",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an excavation of the Ancient Library, researchers found an inscription encrypted with an affine cipher. The deciphered text could hold a secret treasure map! The encrypted message reads: FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS. Decipher the message to unlock the secrets held within. Submit your findings in the format: PCTF{plaintext message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a routine excavation of an ancient library, historians found a cryptic note believed to hold the secret to an elusive treasure. The note appeared to be encrypted using an Affine Cipher, an age-old method of encoding messages. Can you help them decipher the concealed message? The ciphertext is as follows:\nZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM\n\nReveal the historical secret by decrypting the message and submit your answer in the format: \"PCTF{PLAINTEXT}\"",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"ZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM\"\na = 5\nb = 8\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZRC KEWSG NPAOV HAT BEQFU AJCP ZRC LIDY XAM",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 5,
        "b": 8,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library, explorers found a scroll encrypted using a mysterious cipher known as the affine cipher. Before proceeding further into the depths of the library, they must decipher the scroll. The ciphertext reads: \nIF XFYEZ QTWWYZX LFT UZZO H XGHMQ JRUO\nYour task is to decrypt this message and reveal the wisdom hidden within the ancient library.\nSubmit your solution in the format: LIBRARY{plaintext}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IF XFYEZ QTWWYZX LFT UZZO H XGHMQ JRUO\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{TO SOLVE PUZZLES YOU NEED A SHARP MIND}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IF XFYEZ QTWWYZX LFT UZZO H XGHMQ JRUO",
        "plaintext": "TO SOLVE PUZZLES YOU NEED A SHARP MIND",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message from the past appears to have been encrypted using an affine cipher. The historians believe it holds important information about a hidden treasure. Can you crack the code and reveal the secrets? The ciphertext is: IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV. Your mission is to decrypt the message and uncover the buried knowledge.\n\nSubmit your answer in the format: PCTF{DECRYPTED_MESSAGE}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old explorer's diary has been discovered, containing a coded message believed to lead to hidden treasure. The encryption method appears to be an affine cipher used in ancient times. Can you crack the cryptic coordinates and reveal the path? Here is the encoded message:\n\nFDW YQWUF HCJ FJQFD OU E NWJNWFQEV ZCQJRWI\n\nDecrypt the message to find the clue and continue the explorer's quest.\n\nSubmit your solution as: PCTF{decoded_message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW YQWUF HCJ FJQFD OU E NWJNWFQEV ZCQJRWI\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUEST FOR TRUTH IS A PERPETUAL JOURNEY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW YQWUF HCJ FJQFD OU E NWJNWFQEV ZCQJRWI",
        "plaintext": "THE QUEST FOR TRUTH IS A PERPETUAL JOURNEY",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of a forgotten library, an encrypted message was found. Experts believe it is encoded using the affine cipher. Can you recover the text hidden within? The encrypted message is as follows:\nFDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\nDecrypt this to uncover the mysterious message.\n\nSubmit your answer as: CODE{plaintext}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of an old library, you stumble upon a message encoded with what seems to be an ancient cipher. This series of letters might hold the secrets of a long-lost treasure. Your task is to decrypt the message and reveal its hidden meaning. The encoded message, after being processed by an affine transformation, is as follows:\n\nFDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\n\nDecipher it using your skills, and who knows what you might discover!\n\nSubmission format: TREASURE{plaintext}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a recent excavation in an ancient library, archaeologists discovered a mysterious scroll encrypted with an affinity to puzzles. They think it might hold the secret to the Earth's rotation patterns. Here is part of the encoded message: IGZ ZHMIG MFIHIZX FU RIX HARX FUDZ ZEZML IPZUIL KFTM GFTMX. Your mission is to decipher the script and uncover the textual artifact hidden within.\n\nSubmit in the format: PCTF{your deciphered message}.",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ ZHMIG MFIHIZX FU RIX HARX FUDZ ZEZML IPZUIL KFTM GFTMX\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE EARTH ROTATES ON ITS AXIS ONCE EVERY TWENTY FOUR HOURS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ ZHMIG MFIHIZX FU RIX HARX FUDZ ZEZML IPZUIL KFTM GFTMX",
        "plaintext": "THE EARTH ROTATES ON ITS AXIS ONCE EVERY TWENTY FOUR HOURS",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An ancient scroll has been deciphered using an affine cryptographic technique. The treasure map is encrypted with this method. The encrypted message you need to decrypt is as follows:\n\nFDW FJWEUQJW OU DOLLWR QRLWJ FDW CVL CEK FJWW\n\nDecode this message to find and uncover where the treasure is hidden.\n\nSubmission format: FLAG{plaintext message in uppercase}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW FJWEUQJW OU DOLLWR QRLWJ FDW CVL CEK FJWW\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW FJWEUQJW OU DOLLWR QRLWJ FDW CVL CEK FJWW",
        "plaintext": "THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An ancient library has been uncovered, with numerous scrolls encoded in baffling messages. One such message is written in an affine cipher. Experts have determined the encryption technique but need assistance in decrypting the message. The mysterious cipher is revealed as follows:\nIGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\nCan you unlock the text and discover the wisdom it holds?\n\nSubmit your answer in the format: PCTF{plaintext_string}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret society has left an encoded message using an ancient affine cipher. The scrambled text remains unsolved, and only those with a keen eye will manage to decipher it. Below is the mysterious message:\nFDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\nYour task is to unravel this cipher and uncover the secret message.\n\nSubmit your answer in the format: SEC{plaintext_message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS\"\na = 11\nb = 4\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FDW YQOAK PJCMR HCX ZQGNU CBWJ FDW VETI LCS",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 4,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret letter from a forgotten civilization was discovered by archaeologists. It appears to be encrypted using an ancient affine cipher. The ciphertext is as follows:\nZAQYFMZ IGZ ZURVJHIRD PFMYO FK DMLQIFVMHQGL\nCan you decode it to unveil the wisdom from the past?\n\nSubmit your findings in the format: PCTF{your plaintext}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"ZAQYFMZ IGZ ZURVJHIRD PFMYO FK DMLQIFVMHQGL\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{EXPLORE THE ENIGMATIC WORLD OF CRYPTOGRAPHY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZAQYFMZ IGZ ZURVJHIRD PFMYO FK DMLQIFVMHQGL",
        "plaintext": "EXPLORE THE ENIGMATIC WORLD OF CRYPTOGRAPHY",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an archaeological dig, researchers discovered an encrypted message on an ancient scroll. It appears to be encoded using the affine cipher method employed by cryptographers of bygone eras. The message has been obscured, leaving behind the following mysterious ciphertext: USL NFDPZ EYRBG WRM OFVCJ RQLY USL KTIX ARH. Can you unveil the secret message hidden within? \n\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"USL NFDPZ EYRBG WRM OFVCJ RQLY USL KTIX ARH\"\na = 11\nb = 19\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "USL NFDPZ EYRBG WRM OFVCJ RQLY USL KTIX ARH",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 19,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message was uncovered in an archaeologist's tablet encrypted with an ancient cipher. The message is believed to hold significant information about a lost civilization. Can you decipher the message encoded with an affine cipher? The ciphertext is as follows:\n\nIGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\n\nDecrypt this message and reveal the hidden text.\n\nSubmission format: PCTF{PLAIN_TEXT}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "While exploring an ancient tomb, archaeologists discovered a hidden inscription believed to hold a valuable secret. The inscription was encrypted using an affine cipher. The encrypted message is shown below:\n\nGEX ZRPBL QKDNS IDY ARHOV DCXK GEX WFUJ MDT\n\nYour mission is to decrypt this message and uncover the wisdom of the ages.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"GEX ZRPBL QKDNS IDY ARHOV DCXK GEX WFUJ MDT\"\na = 11\nb = 5\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "GEX ZRPBL QKDNS IDY ARHOV DCXK GEX WFUJ MDT",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 5,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of a revered library, an encrypted manuscript was discovered. The cryptic writings were protected by an ancient affine cipher, a puzzle waiting to be solved by those curious enough to uncover its secrets. Delve into the mind of the scribe and decrypt the following cipher to reveal the wisdom concealed within:\n\nZFFV DQY PXN ZADCC MHQY\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"ZFFV DQY PXN ZADCC MHQY\"\na = 7\nb = 3\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SEEK AND YOU SHALL FIND}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZFFV DQY PXN ZADCC MHQY",
        "plaintext": "SEEK AND YOU SHALL FIND",
        "a": 7,
        "b": 3,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten library of an ancient kingdom, a scroll with cryptic symbols was found. The script seems to be an encrypted declaration. The key to decrypt it lies in an old cipher technique. Can you unravel the mystery of the King's secret decree? Here is the cryptogram that was discovered:\nIGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\nTo decode the King's message, decipher the text with the correct technique and reveal the hidden proclamation.\n\nSubmission Format: KCTF{plaintext message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ BTRDN SMFPU KFA CTJQX FEZM IGZ YHWL OFV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An ancient manuscript was recently discovered in the ruins of a castle, and it contains a ciphered message believed to lead to a hidden treasure. The message was encoded using an affine cipher, an encryption method used centuries ago. Your task is to decrypt the following ciphertext and reveal the location of the treasure:\n\nIGZ IMZHXTMZ RX GROOZU TUOZM IGZ FYO FHN IMZZ\n\nSubmit your findings in the format: PCTF{decrypted_message}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ IMZHXTMZ RX GROOZU TUOZM IGZ FYO FHN IMZZ\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ IMZHXTMZ RX GROOZU TUOZM IGZ FYO FHN IMZZ",
        "plaintext": "THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Mysterious documents from an ancient civilization have revealed an encrypted message using the affine cipher. Intelligence agencies believe this message could unlock the secrets of forgotten wisdom. The encoded text is as follows:\nIGZ XZDMZI IF XTDDZXX RX IF NUFP XFJZIGRUV UFSFOL ZYXZ NUFPX\nDecrypt this message using the key of enlightenment and unveil the concealed knowledge.\n\nSubmission format: DECRYPTED{plaintext_string}",
    "rationale": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_decrypt(ciphertext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n    \n    # Find modular multiplicative inverse of a\n    a_inv = mod_inverse(a, 26)\n    if a_inv is None:\n        raise ValueError(\"Modular multiplicative inverse does not exist\")\n        \n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine decryption D(y) = a^(-1)(y - b) mod 26\n            new_pos = (a_inv * (pos - b)) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\n# 给定的密文和参数\nciphertext = \"IGZ XZDMZI IF XTDDZXX RX IF NUFP XFJZIGRUV UFSFOL ZYXZ NUFPX\"\na = 11\nb = 7\n\n# 解密\nplaintext = affine_decrypt(ciphertext, a, b)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET TO SUCCESS IS TO KNOW SOMETHING NOBODY ELSE KNOWS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Affine",
      "change_detail": "The Affine cipher is a type of monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a mathematical function, and converted back to a letter.",
      "synthesis_code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    for i in range(m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef affine_encrypt(plaintext, a, b):\n    result = \"\"\n    # First, verify that a and m=26 are coprime\n    if gcd(a, 26) != 1:\n        raise ValueError(\"a and m=26 must be coprime.\")\n        \n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase and get position (0-25)\n            char = char.upper()\n            pos = ord(char) - ord('A')\n            # Apply affine function E(x) = (ax + b) mod 26\n            new_pos = (a * pos + b) % 26\n            # Convert back to letter\n            result += chr(new_pos + ord('A'))\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\na = {a}\nb = {b}\nciphertext = affine_encrypt(plaintext, a, b)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGZ XZDMZI IF XTDDZXX RX IF NUFP XFJZIGRUV UFSFOL ZYXZ NUFPX",
        "plaintext": "THE SECRET TO SUCCESS IS TO KNOW SOMETHING NOBODY ELSE KNOWS",
        "a": 11,
        "b": 7,
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the heart of an ancient cryptography tome, a mysterious message awaits. Hidden within its pages, there is a text encoded with the classic Vigenère cipher. The ciphertext you are tasked with deciphering is as follows: FFW ZSCBQL CXC ZQ TGVWIE GZ RZX SCB XGTKEIW.\n\nUnravel this enigmatic code and discover the secret message.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"FFW ZSCBQL CXC ZQ TGVWIE GZ RZX SCB XGTKEIW\"\nkey = \"MYSTERY\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE GOLDEN KEY IS HIDDEN IN THE OLD LIBRARY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FFW ZSCBQL CXC ZQ TGVWIE GZ RZX SCB XGTKEIW",
        "plaintext": "THE GOLDEN KEY IS HIDDEN IN THE OLD LIBRARY",
        "key": "MYSTERY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty annals of Victorian cryptography, a parchment was discovered with a message encrypted using the elusive Vigenère cipher. Decode the secrets hidden within the mysterious script.\n\nEncrypted Message:\nELQ EHTGW PEZAZ TBI NGACD SHSE ELQ ZNKC PCT\n\nCan you unveil the hidden truths contained in this ancient text?\n\nSubmission Format: PCTF{plaintext message without spaces}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"ELQ EHTGW PEZAZ TBI NGACD SHSE ELQ ZNKC PCT\"\nkey = \"LEMON\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ELQ EHTGW PEZAZ TBI NGACD SHSE ELQ ZNKC PCT",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "key": "LEMON",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old sailor's diary, found in a dusty attic, lies a message encrypted with a Vigenère cipher. The diary hints at uncharted waters containing unbelievable secrets. Unfortunately, the key was not recorded in modern notes. The encrypted message is: MYM XRRQICWUIQ HVVIQ HRIMYA FSAMTZV PEAR FPAWIEBXJ\n\nYour mission, should you choose to accept it, is to decrypt this message and uncover the truth about the ocean's hidden depths.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"MYM XRRQICWUIQ HVVIQ HRIMYA FSAMTZV PEAR FPAWIEBXJ\"\nkey = \"TRIDENT\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE UNEXPLORED OCEAN DEPTHS CONTAIN MANY MYSTERIES}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "MYM XRRQICWUIQ HVVIQ HRIMYA FSAMTZV PEAR FPAWIEBXJ",
        "plaintext": "THE UNEXPLORED OCEAN DEPTHS CONTAIN MANY MYSTERIES",
        "key": "TRIDENT",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the archives of a forgotten explorer's journal, an encrypted message was discovered. The explorer was known to use the Vigenère cipher to protect his findings. Can you decrypt this message to reveal the explorer's secret treasure location?\n\nCiphertext: FHT DIORTE QMP XD LUDSPR GNSPV FHT LROITYX FRTP MZ TWP JARTDX\n\nDecipher the message and submit the explorer's clue.\n\nSubmission format: TREASURE{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"FHT DIORTE QMP XD LUDSPR GNSPV FHT LROITYX FRTP MZ TWP JARTDX\"\nkey = \"MAPLE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET MAP IS HIDDEN UNDER THE ANCIENT TREE IN THE FOREST}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FHT DIORTE QMP XD LUDSPR GNSPV FHT LROITYX FRTP MZ TWP JARTDX",
        "plaintext": "THE SECRET MAP IS HIDDEN UNDER THE ANCIENT TREE IN THE FOREST",
        "key": "MAPLE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of an ancient astronomer's research, an encrypted message was discovered. The text is encoded using the Vigenère cipher:\n\nCiphertext: GVEM ELS NIUOSA FF VSI GKATD JCI TJP TOKH QQ PWXHV\n\nDecipher this text to uncover the hidden wisdom of the celestial bodies.\n\nSubmit your answer in the form: STARC{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"GVEM ELS NIUOSA FF VSI GKATD JCI TJP TOKH QQ PWXHV\"\nkey = \"ORACLE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SEEK THE WISDOM OF THE STARS FOR THE PATH OF LIGHT}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "GVEM ELS NIUOSA FF VSI GKATD JCI TJP TOKH QQ PWXHV",
        "plaintext": "SEEK THE WISDOM OF THE STARS FOR THE PATH OF LIGHT",
        "key": "ORACLE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of a forgotten library, an encrypted message has been uncovered. It is believed to use a Vigenère cipher, crafted by a master cryptographer. The encoded message reads: ECUKIKQ OYF UI ICHCSEIU ZK RZHWV UTM KXIB. Can you decipher this secret and unveil the truth hidden within? Use the magic of the keyword and your skills to reveal the message. Submit your answer in the following format: PCTF{plaintext}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"ECUKIKQ OYF UI ICHCSEIU ZK RZHWV UTM KXIB\"\nkey = \"MYSTERY\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRETS CAN BE REVEALED BY THOSE WHO SEEK}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ECUKIKQ OYF UI ICHCSEIU ZK RZHWV UTM KXIB",
        "plaintext": "SECRETS CAN BE REVEALED BY THOSE WHO SEEK",
        "key": "MYSTERY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old notebook belonging to a cryptology enthusiast, an intriguing piece of encrypted text was discovered. It appears to be encoded using the Vigenère cipher, a classic encryption method known for its use of a keyword. Can you decrypt this message and reveal the secret it hides?\n\nCiphertext is as follows: HPASO TPPT MEPIPNG TH HT NZDU PLPPZE BP DU TIXT\n\nPlease decipher this cryptotext and submit the hidden message correctly.\n\nSubmission Format: PCTF{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"HPASO TPPT MEPIPNG TH HT NZDU PLPPZE BP DU TIXT\"\nkey = \"ALPHA\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{HELLO TEAM MEETING IS AT NOON PLEASE BE ON TIME}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "HPASO TPPT MEPIPNG TH HT NZDU PLPPZE BP DU TIXT",
        "plaintext": "HELLO TEAM MEETING IS AT NOON PLEASE BE ON TIME",
        "key": "ALPHA",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An adventurer exploring the hidden chambers beneath the Great Pyramid of Giza discovered an old stone tablet. On the tablet, an inscription was found encoded with what appears to be a Vigenère cipher. The ancient scribes might have left behind secrets encoded in the stone. The encrypted message reads: IOE DYGATYIVS CM IOE RNQPTUT GYFHBPDJ RSTPPN LNGVACEU. Can you decrypt this message and unlock the secrets of the past? Submit your answer in the format: PCTF{PLAIN_TEXT}.",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"IOE DYGATYIVS CM IOE RNQPTUT GYFHBPDJ RSTPPN LNGVACEU\"\nkey = \"PHARAOH\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE MYSTERIES OF THE ANCIENT PYRAMIDS REMAIN UNSOLVED}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IOE DYGATYIVS CM IOE RNQPTUT GYFHBPDJ RSTPPN LNGVACEU",
        "plaintext": "THE MYSTERIES OF THE ANCIENT PYRAMIDS REMAIN UNSOLVED",
        "key": "PHARAOH",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Rumors have spread about a secret message hidden by the last pirate captain. It is said that this message reveals the location of his buried treasure. However, it's encrypted using an old Vigenère cipher method. The ciphertext is as follows: ELK XEHLWAVR LD FAVVHO YTHRU ELK EAFTITX BDV XXIR\n\nDecrypt the message to uncover the secret location.\n\nSubmit your answer in the format: PCTF{plaintextmessage}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"ELK XEHLWAVR LD FAVVHO YTHRU ELK EAFTITX BDV XXIR\"\nkey = \"LEGEND\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS BURIED UNDER THE ANCIENT OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ELK XEHLWAVR LD FAVVHO YTHRU ELK EAFTITX BDV XXIR",
        "plaintext": "THE TREASURE IS BURIED UNDER THE ANCIENT OAK TREE",
        "key": "LEGEND",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient temple in the heart of the Andes, explorers have stumbled upon a scroll inscribed with a cryptic message. The scroll appears to be encrypted using a Vigenère cipher, a popular method among ancient civilizations to protect their secrets. The encrypted message is provided below:\n\nVVW YMKVSJUSK QT LTS MPWNQFKG OJQ JWKZWP HG OCJFODU\n\nYour mission is to decipher this message and unlock the secrets of the cosmos.\n\nSubmission format: PCTF{decrypted message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"VVW YMKVSJUSK QT LTS MPWNQFKG OJQ JWKZWP HG OCJFODU\"\nkey = \"COSMOS\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE MYSTERIES OF THE UNIVERSE ARE VEILED TO MORTALS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "VVW YMKVSJUSK QT LTS MPWNQFKG OJQ JWKZWP HG OCJFODU",
        "plaintext": "THE MYSTERIES OF THE UNIVERSE ARE VEILED TO MORTALS",
        "key": "COSMOS",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have stumbled upon an ancient pirate map, written in cryptic symbols and encrypted using the timeless Vigenère cipher. A secret message appears to hold the key to where the treasure is buried. Decipher this mysterious text to uncover the secrets of the pirates. The encrypted message is: EETW TWQ TGQAHGRT NECQAIT TWQ OAP OPW TGQE Can you unlock the mystery and find the hidden treasure? Submit your answer in the format: PCTF{plaintext without key}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"EETW TWQ TGQAHGRT NECQAIT TWQ OAP OPW TGQE\"\nkey = \"MAP\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SEEK THE TREASURE BENEATH THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "EETW TWQ TGQAHGRT NECQAIT TWQ OAP OPW TGQE",
        "plaintext": "SEEK THE TREASURE BENEATH THE OLD OAK TREE",
        "key": "MAP",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an archaeological dig, researchers unearthed an ancient manuscript encrypted with the Vigenère cipher. The code breakers have reconstructed the document, and the encrypted message is: JWGHGB PIUGDKGG DVG O VIEFHX VFHEUIUI\n\nYour mission is to decode the message to uncover what secrets were intentionally hidden by the ancients.\n\nSubmit format: CTF{DecryptedMessage}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"JWGHGB PIUGDKGG DVG O VIEFHX VFHEUIUI\"\nkey = \"CODE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{HIDDEN MESSAGES ARE A SECRET TREASURE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "JWGHGB PIUGDKGG DVG O VIEFHX VFHEUIUI",
        "plaintext": "HIDDEN MESSAGES ARE A SECRET TREASURE",
        "key": "CODE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "There is an old rumor about hidden treasure being encoded in a mysterious letter using a classic encryption method. The ciphertext uncovered reads as follows: ZVP WXSLVAFP LY PFUOSO XTRPU ZVP RRR ZDQ HCHK\n\nDecipher the message to reveal the location of the treasure.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"ZVP WXSLVAFP LY PFUOSO XTRPU ZVP RRR ZDQ HCHK\"\nkey = \"GOLD\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS BURIED UNDER THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZVP WXSLVAFP LY PFUOSO XTRPU ZVP RRR ZDQ HCHK",
        "plaintext": "THE TREASURE IS BURIED UNDER THE OLD OAK TREE",
        "key": "GOLD",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the archives of an ancient library, an encrypted manuscript has been unearthed. Scholars believe it is written using the Vigenère cipher, a method known to confound even the most skilled codebreakers of the past. The encrypted text reads: FBW UGXIVG QR NZM PUAZB KE U KMEDYL PGXX TG VTY KBCDM. Your mission, should you choose to accept it, is to unravel the mystery and find the secret melody. Submission format: PCTF{decrypted_message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"FBW UGXIVG QR NZM PUAZB KE U KMEDYL PGXX TG VTY KBCDM\"\nkey = \"MUSIC\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE MELODY OF THE NIGHT IS A SECRET HELD BY THE STARS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FBW UGXIVG QR NZM PUAZB KE U KMEDYL PGXX TG VTY KBCDM",
        "plaintext": "THE MELODY OF THE NIGHT IS A SECRET HELD BY THE STARS",
        "key": "MUSIC",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An encoded message was discovered hidden inside an antique music box, accompanied by a note referencing 'The Adventure of the Dancing Men'. The message seems to be encrypted using the Vigenère cipher.\n\nHere is the ciphertext you need to decrypt: WHR CHYEAVYUE BH XKE QCRFIAI QHN VU E IAZQYV SUGVOOPM LRLZGW PYFVIUY\n\nDecipher the message to uncover the secret within.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"WHR CHYEAVYUE BH XKE QCRFIAI QHN VU E IAZQYV SUGVOOPM LRLZGW PYFVIUY\"\nkey = \"DANCE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE ADVENTURE OF THE DANCING MEN IS A FAMOUS SHERLOCK HOLMES MYSTERY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "WHR CHYEAVYUE BH XKE QCRFIAI QHN VU E IAZQYV SUGVOOPM LRLZGW PYFVIUY",
        "plaintext": "THE ADVENTURE OF THE DANCING MEN IS A FAMOUS SHERLOCK HOLMES MYSTERY",
        "key": "DANCE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "While exploring an ancient manuscript, you come across a page filled with cryptic symbols and letters. The text seems to be encrypted using the mysterious Vigenère cipher. The encoded message is: AHT HMPVWL VF AXNR MK LV ECYWL XZW QOJGVRC FGA JJHB GLW VLSIXVNXAGU. Your mission, should you choose to accept it, is to unveil the secret within. Submit your answer in the format: PCTF{plaintext answer}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"AHT HMPVWL VF AXNR MK LV ECYWL XZW QOJGVRC FGA JJHB GLW VLSIXVNXAGU\"\nkey = \"HAPPINESS\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET OF LIFE IS TO ENJOY THE JOURNEY NOT JUST THE DESTINATION}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "AHT HMPVWL VF AXNR MK LV ECYWL XZW QOJGVRC FGA JJHB GLW VLSIXVNXAGU",
        "plaintext": "THE SECRET OF LIFE IS TO ENJOY THE JOURNEY NOT JUST THE DESTINATION",
        "key": "HAPPINESS",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious scroll was found in the attic of an old English manor. The scroll contained a cryptic note and appears to use the Vigenère cipher. The encoded message is: M STNVQT ICIMSJCI US QFVUES FRPEG ELQ ACNMQNI ZEW TGPI\n\nYour task is to decrypt the message and uncover the secret. Submit the format as: PCTF{plaintext string}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"M STNVQT ICIMSJCI US QFVUES FRPEG ELQ ACNMQNI ZEW TGPI\"\nkey = \"MAPLE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{A SECRET TREASURE IS BURIED UNDER THE ANCIENT OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "M STNVQT ICIMSJCI US QFVUES FRPEG ELQ ACNMQNI ZEW TGPI",
        "plaintext": "A SECRET TREASURE IS BURIED UNDER THE ANCIENT OAK TREE",
        "key": "MAPLE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of an old library, a cryptic note was discovered, encrypted using the enigmatic Vigenère cipher. Can you decipher the message to reveal its hidden secrets? The encrypted text is as follows: FFW JYZAW ZJHAE DAV BNQGQ ATWK XYC XYRR HFE\n\nSubmit the decrypted text in the format: PCTF{plaintext}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"FFW JYZAW ZJHAE DAV BNQGQ ATWK XYC XYRR HFE\"\nkey = \"MYSTERY\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "FFW JYZAW ZJHAE DAV BNQGQ ATWK XYC XYRR HFE",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "key": "MYSTERY",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the remnants of an old tech pioneer's journal, you come across a section encrypted with the famous Vigenère cipher. Experts suspect the key is related to the author's enigmatic personality. The ciphertext reads: AGRJZSMMJR VBWOMFZYDWZXW WILPIZR S EIVHWK EIH S YSGPGPIM. Unlock the message hidden within to reveal the wisdom of the past. Submit your answer in the format: PCTF{plaintext message}.",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"AGRJZSMMJR VBWOMFZYDWZXW WILPIZR S EIVHWK EIH S YSGPGPIM\"\nkey = \"STEVE\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{INNOVATION DISTINGUISHES BETWEEN A LEADER AND A FOLLOWER}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "AGRJZSMMJR VBWOMFZYDWZXW WILPIZR S EIVHWK EIH S YSGPGPIM",
        "plaintext": "INNOVATION DISTINGUISHES BETWEEN A LEADER AND A FOLLOWER",
        "key": "STEVE",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of a hidden archive, an encrypted note has been discovered. It is believed to be written by a mysterious group that uses the Vigenère cipher to protect their messages. The intercepted text is as follows: WHA FHCNRW MARWIJT ZIHY WAGR SLWPH AP QDWJ OB TDR RLZ BDK PEHE\n\nYour mission is to crack this code and reveal the hidden message concealed within.\n\nSubmit your solution in the format: PCTF{plaintext message}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"WHA FHCNRW MARWIJT ZIHY WAGR SLWPH AP QDWJ OB TDR RLZ BDK PEHE\"\nkey = \"DAWN\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET MEETING WILL TAKE PLACE AT DAWN BY THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "WHA FHCNRW MARWIJT ZIHY WAGR SLWPH AP QDWJ OB TDR RLZ BDK PEHE",
        "plaintext": "THE SECRET MEETING WILL TAKE PLACE AT DAWN BY THE OLD OAK TREE",
        "key": "DAWN",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the secret archives of a forgotten kingdom, a scroll was discovered containing a message encrypted with the Vigenère cipher. The scribes left clues about the kingdom's eternal quest. Can you unlock the secret? Here is the ciphertext: AVV YTWPR PIWVB SVL ACLDF VJVZ SVR SOQG CCT\n\nDecrypt the message to reveal the hidden information.\n\nSubmit your answer in the format: KNG{plaintext}",
    "rationale": "def vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    ciphertext = ciphertext.upper()\n    \n    i = 0\n    for char in ciphertext:\n        if char.isalpha():\n            # Shift the current character back by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\n# 给定的密文和密钥\nciphertext = \"AVV YTWPR PIWVB SVL ACLDF VJVZ SVR SOQG CCT\"\nkey = \"HORIZON\"\n\n# 解密\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Vigenere",
      "change_detail": "The Vigenère cipher is a polyalphabetic substitution cipher that uses a keyword to shift each letter in the plaintext by different amounts.",
      "synthesis_code": "def vigenere_encrypt(plaintext, key):\n    result = \"\"\n    key = key.upper()\n    key_length = len(key)\n    key_as_int = [ord(i) - ord('A') for i in key]\n    plaintext = plaintext.upper()\n    \n    i = 0\n    for char in plaintext:\n        if char.isalpha():\n            # Shift the current character by the corresponding key character value\n            shift = key_as_int[i % key_length]\n            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            i += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = \"{plaintext}\"\nkey = \"{key}\"\nciphertext = vigenere_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "AVV YTWPR PIWVB SVL ACLDF VJVZ SVR SOQG CCT",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "key": "HORIZON",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Spy Agency Intercept:\n\nThree intercepted messages from rogue agents were found. Analysts suspect all three messages contain the same secret phrase but were encrypted using RSA with **small exponent e=3** and distinct moduli. Fortunately, the messages were sent without padding. Your mission is to recover the original plaintext.\n\nn1 = 139865929\nc1 = 104368694\n\nn2 = 145036421\nc2 = 107148110\n\nn3 = 147928627\nc3 = 108321924\ne = 3\n\nDecrypt the message and submit it in the format: `PCTF{...}`",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [139865929, 145036421, 147928627]\nc = [104368694, 107148110, 108321924]\ne = 3\nM, _ = crt(n, c)\nm, _ = iroot(M, e)\nprint(long_to_bytes(m))",
    "final_answer": "PCTF{secure_channel_open}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "Exploiting RSA broadcast vulnerability using CRT and cube root.",
      "synthesis_code": "from Crypto.Util.number import bytes_to_long, getPrime\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nflag = b\"PCTF{secure_channel_open}\"\nm = bytes_to_long(flag)\ne = 3\nn = [getPrime(32) for _ in range(3)]\nc = [pow(m, e, ni) for ni in n]\nprint(n, c)",
      "compute": "1",
      "original_data": {
        "n": [
          139865929,
          145036421,
          147928627
        ],
        "c": [
          104368694,
          107148110,
          108321924
        ],
        "e": 3,
        "plaintext": "PCTF{secure_channel_open}"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Ancient Vault Scroll:\n\nA scroll hidden in a stone chamber contains 3 encrypted versions of a sacred message, all using RSA with `e = 3`. The encryption was applied without any padding. Historians believe the scroll hides a flag. Use your cryptographic skills to uncover the message.\n\nn1 = 163019731\nc1 = 122137922\n\nn2 = 167890423\nc2 = 124983504\n\nn3 = 169017517\nc3 = 128770146\ne = 3",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [163019731, 167890423, 169017517]\nc = [122137922, 124983504, 128770146]\nM, _ = crt(n, c)\nm, _ = iroot(M, 3)\nprint(long_to_bytes(m))",
    "final_answer": "PCTF{legacy_decryption_successful}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "An ancient scroll encrypted using RSA with low exponent.",
      "synthesis_code": "from Crypto.Util.number import bytes_to_long, getPrime\nflag = b\"PCTF{legacy_decryption_successful}\"\nm = bytes_to_long(flag)\ne = 3\nn = [getPrime(32) for _ in range(3)]\nc = [pow(m, e, ni) for ni in n]\nprint(n, c)",
      "compute": "1",
      "original_data": {
        "n": [
          163019731,
          167890423,
          169017517
        ],
        "c": [
          122137922,
          124983504,
          128770146
        ],
        "e": 3,
        "plaintext": "PCTF{legacy_decryption_successful}"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Hacker Terminal Dump:\n\nYour team has dumped part of a hacker’s encrypted communication. You discover that the same flag was encrypted three times using RSA with `e = 3`. No padding was used. You may assume the plaintext is short.\n\nn1 = 174395111\nc1 = 130049327\n\nn2 = 179308171\nc2 = 132217633\n\nn3 = 181217813\nc3 = 135193213\ne = 3",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [174395111, 179308171, 181217813]\nc = [130049327, 132217633, 135193213]\nM, _ = crt(n, c)\nm, _ = iroot(M, 3)\nprint(long_to_bytes(m))",
    "final_answer": "PCTF{broadcast_pwned}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "Applied RSA broadcast attack on hacker communication using CRT.",
      "synthesis_code": "from Crypto.Util.number import bytes_to_long, getPrime\nflag = b\"PCTF{broadcast_pwned}\"\nm = bytes_to_long(flag)\ne = 3\nn = [getPrime(32) for _ in range(3)]\nc = [pow(m, e, ni) for ni in n]\nprint(n, c)",
      "compute": "1",
      "original_data": {
        "n": [
          174395111,
          179308171,
          181217813
        ],
        "c": [
          130049327,
          132217633,
          135193213
        ],
        "e": 3,
        "plaintext": "PCTF{broadcast_pwned}"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Satellite Transmission Leak:\n\nThree encrypted satellite commands were leaked. All were encrypted with RSA using `e=3`, and different 32-bit RSA moduli. These messages are suspected to be identical, and due to the lack of padding, you can apply a broadcast attack.\n\nn1 = 154874873\nc1 = 113287123\n\nn2 = 158937599\nc2 = 115176567\n\nn3 = 161293849\nc3 = 116737233\ne = 3",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [154874873, 158937599, 161293849]\nc = [113287123, 115176567, 116737233]\nM, _ = crt(n, c)\nm, _ = iroot(M, 3)\nprint(long_to_bytes(m))",
    "final_answer": "PCTF{orbit_command_decoded}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "Satellite messages encrypted with low-exponent RSA. Vulnerable to broadcast attack.",
      "synthesis_code": "from Crypto.Util.number import bytes_to_long, getPrime\nflag = b\"PCTF{orbit_command_decoded}\"\nm = bytes_to_long(flag)\ne = 3\nn = [getPrime(32) for _ in range(3)]\nc = [pow(m, e, ni) for ni in n]\nprint(n, c)",
      "compute": "1",
      "original_data": {
        "n": [
          154874873,
          158937599,
          161293849
        ],
        "c": [
          113287123,
          115176567,
          116737233
        ],
        "e": 3,
        "plaintext": "PCTF{orbit_command_decoded}"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Encrypted Conference Key:\n\nDuring a cybersecurity summit, a public announcement system encrypted a shared password using RSA. However, developers mistakenly encrypted the same password using three different moduli but the same small exponent `e=3`. No padding was used. Intercepted data:\n\nn1 = 177013123\nc1 = 137081234\n\nn2 = 180713017\nc2 = 138973456\n\nn3 = 183019111\nc3 = 141520999\ne = 3\n\nRecover the original password.",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [177013123, 180713017, 183019111]\nc = [137081234, 138973456, 141520999]\nM, _ = crt(n, c)\nm, _ = iroot(M, 3)\nprint(long_to_bytes(m))",
    "final_answer": "PCTF{conference_key_leaked}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "Conference key encrypted with broadcast-vulnerable RSA. No padding enabled.",
      "synthesis_code": "from Crypto.Util.number import bytes_to_long, getPrime\nflag = b\"PCTF{conference_key_leaked}\"\nm = bytes_to_long(flag)\ne = 3\nn = [getPrime(32) for _ in range(3)]\nc = [pow(m, e, ni) for ni in n]\nprint(n, c)",
      "compute": "1",
      "original_data": {
        "n": [
          177013123,
          180713017,
          183019111
        ],
        "c": [
          137081234,
          138973456,
          141520999
        ],
        "e": 3,
        "plaintext": "PCTF{conference_key_leaked}"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a secret message sent by an ancient order of cryptographers. The message was encrypted using the Hill cipher, but you have managed to retrieve the ciphertext and the encryption matrix. Your task is to decipher the hidden message. The encrypted text you need to decode is: Tn. The encryption matrix used is: [[1, 13], [10, 3]]. Time is of the essence! Decrypt the message and submit your answer in the format: PCTF{plain_text}",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"Tn\"\nkey = [[1, 13], [10, 3]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Gt}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "Tn",
        "key": [
          [
            1,
            13
          ],
          [
            10,
            3
          ]
        ],
        "plaintext": "Gt",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have stumbled upon a mysterious encrypted message hidden deep within an ancient scroll. The message, written in a forgotten code, was encrypted using the Hill cipher. Your task is to break the code and unveil the hidden message. The encrypted message is: hGlo. To decrypt it, you will need to use the matrix key: [[25, 23, 5, 18], [9, 22, 10, 18], [23, 7, 21, 17], [12, 24, 17, 19]]. Solve this riddle, uncover the truth, and reveal the secret message! Submit your answer in the format: PCTF{plaintext}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"hGlo\"\nkey = [[25, 23, 5, 18], [9, 22, 10, 18], [23, 7, 21, 17], [12, 24, 17, 19]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{eZck}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "hGlo",
        "key": [
          [
            25,
            23,
            5,
            18
          ],
          [
            9,
            22,
            10,
            18
          ],
          [
            23,
            7,
            21,
            17
          ],
          [
            12,
            24,
            17,
            19
          ]
        ],
        "plaintext": "eZck",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message has been intercepted during a covert operation, encrypted using the Hill cipher. The encrypted message is as follows: sUOIlVfrgKtElONgRF. The encryption key matrix used to secure this message is: [[1, 19, 5, 22, 6, 13], [20, 4, 8, 4, 7, 24], [24, 7, 2, 7, 15, 12], [0, 3, 19, 4, 22, 13], [10, 22, 19, 12, 7, 9], [5, 21, 14, 6, 15, 9]]. Your mission is to decrypt the message and uncover the hidden intelligence. Submit your answer in the format: PCTF{plaintext_message}",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"sUOIlVfrgKtElONgRF\"\nkey = [[1, 19, 5, 22, 6, 13], [20, 4, 8, 4, 7, 24], [24, 7, 2, 7, 15, 12], [0, 3, 19, 4, 22, 13], [10, 22, 19, 12, 7, 9], [5, 21, 14, 6, 15, 9]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{oNJXcYpoiDxChVYyGX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "sUOIlVfrgKtElONgRF",
        "key": [
          [
            1,
            19,
            5,
            22,
            6,
            13
          ],
          [
            20,
            4,
            8,
            4,
            7,
            24
          ],
          [
            24,
            7,
            2,
            7,
            15,
            12
          ],
          [
            0,
            3,
            19,
            4,
            22,
            13
          ],
          [
            10,
            22,
            19,
            12,
            7,
            9
          ],
          [
            5,
            21,
            14,
            6,
            15,
            9
          ]
        ],
        "plaintext": "oNJXcYpoiDxChVYyGX",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a message from a covert communication. The message was encrypted using the ancient Hill cipher, and it has been sent through a secure channel. Your task is to decrypt the message and reveal the hidden instructions. The encrypted ciphertext you found is: XOiMyfWxS. The encryption was performed using a key matrix, which you can see below: [[13, 3, 17], [21, 4, 11], [2, 19, 9]]. Use your cryptographic skills to unravel the message. Time is of the essence! Once you've decoded the plaintext, submit it in the following format: PCTF{decoded_message}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"XOiMyfWxS\"\nkey = [[13, 3, 17], [21, 4, 11], [2, 19, 9]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{VTlDubYpR}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "XOiMyfWxS",
        "key": [
          [
            13,
            3,
            17
          ],
          [
            21,
            4,
            11
          ],
          [
            2,
            19,
            9
          ]
        ],
        "plaintext": "VTlDubYpR",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have intercepted a secret message that was encoded using the Hill cipher. The encrypted message is: BwUR. The cryptographer who created this message used a special 2x2 matrix to encrypt it. The matrix, known only to a few, is: [[12, 4, 8, 1], [3, 13, 8, 9], [19, 8, 8, 1], [13, 15, 5, 14]]. Can you decode the message and reveal the original text? The answer format should be: PCTF{plaintext}. The fate of the mission depends on you uncovering this hidden message before time runs out!",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"BwUR\"\nkey = [[12, 4, 8, 1], [3, 13, 8, 9], [19, 8, 8, 1], [13, 15, 5, 14]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{TeUN}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "BwUR",
        "key": [
          [
            12,
            4,
            8,
            1
          ],
          [
            3,
            13,
            8,
            9
          ],
          [
            19,
            8,
            8,
            1
          ],
          [
            13,
            15,
            5,
            14
          ]
        ],
        "plaintext": "TeUN",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message has been intercepted, encrypted using the Hill cipher. The message is crucial for deciphering an ancient code that could unlock a hidden treasure. The ciphertext is: WbYF. The encryption was performed using a 2x2 matrix key: [[1, 18, 12, 10], [14, 23, 22, 1], [5, 3, 11, 7], [24, 23, 15, 12]]. Your mission is to decrypt this message and uncover the truth. To submit your answer, reveal the plaintext message in the format: PCTF{decrypted_message}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"WbYF\"\nkey = [[1, 18, 12, 10], [14, 23, 22, 1], [5, 3, 11, 7], [24, 23, 15, 12]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{UeBX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "WbYF",
        "key": [
          [
            1,
            18,
            12,
            10
          ],
          [
            14,
            23,
            22,
            1
          ],
          [
            5,
            3,
            11,
            7
          ],
          [
            24,
            23,
            15,
            12
          ]
        ],
        "plaintext": "UeBX",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a secretive organization, agents communicate using an ancient cipher system, the Hill cipher, to relay important information. One such message has been intercepted. The encrypted message is as follows: VMTH. The encryption was carried out using a 2x2 matrix key: [[1, 8, 10, 25], [24, 19, 13, 8], [22, 16, 2, 23], [22, 21, 10, 11]]. Your task is to decrypt this message and uncover the hidden intelligence. The original message holds vital information that must be revealed to complete your mission. Submit your solution in the format: PCTF{plaintext}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"VMTH\"\nkey = [[1, 8, 10, 25], [24, 19, 13, 8], [22, 16, 2, 23], [22, 21, 10, 11]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{CGER}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "VMTH",
        "key": [
          [
            1,
            8,
            10,
            25
          ],
          [
            24,
            19,
            13,
            8
          ],
          [
            22,
            16,
            2,
            23
          ],
          [
            22,
            21,
            10,
            11
          ]
        ],
        "plaintext": "CGER",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During the investigation of an ancient cryptic artifact, a secret message was uncovered, encrypted using the Hill cipher. The message, believed to reveal the location of a hidden treasure, was encoded as: wLSkysXBTXhIxENJIA. The encryption matrix used to obscure the truth is as follows: [[16, 23, 10, 19, 7, 5], [12, 17, 21, 0, 1, 12], [25, 1, 12, 23, 19, 10], [13, 19, 13, 15, 21, 23], [15, 13, 11, 4, 14, 8], [2, 14, 5, 3, 2, 22]]. Can you decipher this message and unveil the treasure's secret? Your task is to decrypt the ciphertext and reveal the hidden message. Submit your answer in the format: PCTF{plaintext_message}",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"wLSkysXBTXhIxENJIA\"\nkey = [[16, 23, 10, 19, 7, 5], [12, 17, 21, 0, 1, 12], [25, 1, 12, 23, 19, 10], [13, 19, 13, 15, 21, 23], [15, 13, 11, 4, 14, 8], [2, 14, 5, 3, 2, 22]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xOVlwrAVMYuExEPXJB}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "wLSkysXBTXhIxENJIA",
        "key": [
          [
            16,
            23,
            10,
            19,
            7,
            5
          ],
          [
            12,
            17,
            21,
            0,
            1,
            12
          ],
          [
            25,
            1,
            12,
            23,
            19,
            10
          ],
          [
            13,
            19,
            13,
            15,
            21,
            23
          ],
          [
            15,
            13,
            11,
            4,
            14,
            8
          ],
          [
            2,
            14,
            5,
            3,
            2,
            22
          ]
        ],
        "plaintext": "xOVlwrAVMYuExEPXJB",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have stumbled upon an encrypted message hidden within an ancient text. Legends say that only the wise can unlock its secrets using the Hill cipher. The message, once decrypted, holds the key to a long-lost treasure. Your mission is clear: decrypt the following ciphertext and uncover the truth.\n\nCiphertext: yE\n\nThe encryption matrix used to encode the message is: [[4, 17], [19, 12]]\n\nSolve the puzzle and submit your answer as: PCTF{plaintext_message}",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"yE\"\nkey = [[4, 17], [19, 12]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{uM}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "yE",
        "key": [
          [
            4,
            17
          ],
          [
            19,
            12
          ]
        ],
        "plaintext": "uM",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message has been intercepted, encrypted using the Hill cipher. The cryptic text reads: vFGsFJunR. The cipher was created using a matrix key: [[21, 8, 19], [0, 13, 19], [24, 17, 22]]. Can you unravel the hidden meaning behind this encrypted message and restore it to its original form? Time is of the essence. Submit your decoded message in the format: PCTF{plaintext}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"vFGsFJunR\"\nkey = [[21, 8, 19], [0, 13, 19], [24, 17, 22]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{uIDqXQovA}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "vFGsFJunR",
        "key": [
          [
            21,
            8,
            19
          ],
          [
            0,
            13,
            19
          ],
          [
            24,
            17,
            22
          ]
        ],
        "plaintext": "uIDqXQovA",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You are a secret agent tasked with decoding an encrypted message. Your mission: to retrieve an important message hidden by an enemy agent using the Hill cipher. The encrypted message is: gjPI. You have intercepted the matrix key used to encrypt the message: [[16, 12, 8, 5], [9, 1, 22, 16], [4, 3, 1, 7], [7, 23, 25, 22]]. Your goal is to decrypt the message and uncover the hidden intelligence. Once you have decrypted it, submit the plaintext in the format: PCTF{plaintext_string}.",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"gjPI\"\nkey = [[16, 12, 8, 5], [9, 1, 22, 16], [4, 3, 1, 7], [7, 23, 25, 22]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{paJW}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "gjPI",
        "key": [
          [
            16,
            12,
            8,
            5
          ],
          [
            9,
            1,
            22,
            16
          ],
          [
            4,
            3,
            1,
            7
          ],
          [
            7,
            23,
            25,
            22
          ]
        ],
        "plaintext": "paJW",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the ancient archives of the forgotten kingdom, an encrypted message was discovered, believed to hold the key to unlocking a long-lost treasure. The message was encrypted using the Hill cipher, and the only clue left behind is the ciphertext: qVTo. Along with this, an ancient matrix used for encryption has been uncovered: [[13, 11], [23, 0]]. Your task is to decrypt the message and reveal its hidden contents. Time is of the essence, as the kingdom's fate rests in your hands. Submit your decrypted message in the following format: PCTF{decrypted_message}",
    "rationale": "import numpy as np\ndef mod_inv(a, m):\n    '''Modular inverse using extended Euclidean algorithm'''\n    for x in range(1, m):\n        if (a * x) % m == 1:\n            return x\n    raise ValueError(\"No modular inverse.\")\n\ndef matrix_mod_inv(matrix, mod):\n    '''Find inverse of matrix under modulo'''\n    det = int(round(np.linalg.det(matrix)))  # Compute determinant\n    det_inv = mod_inv(det % mod, mod)        # Modular inverse of determinant\n    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int)  # Adjugate matrix\n    return (det_inv * matrix_adj) % mod\n\ndef hill_decrypt(ciphertext, key):\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    n = len(key)\n\n    # Track casing\n    casing = [c.isupper() for c in ciphertext]\n    \n    # Convert ciphertext to numbers\n    nums = [char_to_num(c) for c in ciphertext]\n    cipher_matrix = np.array(nums).reshape(-1, n)\n\n    # Compute inverse key matrix mod 26\n    key_inv = matrix_mod_inv(np.array(key), 26)\n\n    # Decrypt\n    plain_matrix = np.dot(cipher_matrix, key_inv.T) % 26\n    flat = plain_matrix.flatten()\n\n    # Convert numbers back to characters with original casing\n    plaintext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return plaintext\n\n# 给定的密文和密钥\nciphertext = \"qVTo\"\nkey = [[13, 11], [23, 0]]\n\n# 解密\nplaintext = hill_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{tFEx}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Hill",
      "change_detail": "The Hill cipher is a polygraphic substitution cipher based on linear algebra. It converts plaintext into vectors and multiplies them by an invertible key matrix modulo 26. The key matrix must be invertible in mod 26 (i.e., its determinant is coprime with 26) to allow decryption.",
      "synthesis_code": "import numpy as np\n\ndef hill_encrypt(plaintext, key):\n    # Convert character to number: A=0, B=1, ..., Z=25\n    def char_to_num(c): return ord(c.upper()) - ord('A')\n    def num_to_char(n, is_upper): \n        return chr(n + ord('A')) if is_upper else chr(n + ord('a'))\n\n    # Matrix size\n    key = np.array(key)\n    n = len(key)\n\n    # Convert to numeric vectors and track original casing\n    nums = [char_to_num(c) for c in plaintext]\n    casing = [c.isupper() for c in plaintext]\n\n    # Create matrix and encrypt\n    plain_matrix = np.array(nums).reshape(-1, n)\n    cipher_matrix = np.dot(plain_matrix, key.T) % 26\n\n    # Flatten and convert back to characters with original casing\n    flat = cipher_matrix.flatten()\n    ciphertext = ''.join(num_to_char(int(num), is_upper) for num, is_upper in zip(flat, casing))\n    return ciphertext\n\nplaintext = \"{plaintext}\"  # Should be alphabetic and uppercase\nkey = np.array({key})  # Example: [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\nciphertext = hill_encrypt(plaintext, key)\nprint(ciphertext)\n",
      "compute": "2",
      "original_data": {
        "ciphertext": "qVTo",
        "key": [
          [
            13,
            11
          ],
          [
            23,
            0
          ]
        ],
        "plaintext": "tFEx",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten corner of the ancient library, an old cryptographer left behind a secret message encoded using the Autokey Cipher. The message, encrypted with the keyword IFWXHJCT, holds the key to unlocking a long-lost treasure. Your task is to decipher the following ciphertext: VJRQ OZZVOF PWBDS POL ZZEXQ and uncover the hidden secrets it holds. Can you decode the message and reveal the truth? Submit the plaintext as PCTF{plaintext_string}.",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"VJRQ OZZVOF PWBDS POL ZZEXQ\"\nkey = \"IFWXHJCT\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{NEVT HQXCBB UDUNV NNK FWKKV}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "VJRQ OZZVOF PWBDS POL ZZEXQ",
        "key": "IFWXHJCT",
        "plaintext": "NEVT HQXCBB UDUNV NNK FWKKV",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A notorious secret society has encrypted a critical message using the Autokey Cipher. The message contains crucial information about their next move. The encrypted message is: YQVM MSPB BOH DYFIQP ERJRGB ZBM, and the keyword they used to encrypt it is: FNX. Your mission is to decrypt the message and reveal the hidden information. Time is of the essence. Good luck, agent.\n\nSubmit the flag in the following format: PCTF{decrypted_message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"YQVM MSPB BOH DYFIQP ERJRGB ZBM\"\nkey = \"FNX\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{TDYT JUWS HSP WGQMKZ SHKZZR ACV}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "YQVM MSPB BOH DYFIQP ERJRGB ZBM",
        "key": "FNX",
        "plaintext": "TDYT JUWS HSP WGQMKZ SHKZZR ACV",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message has been hidden using the powerful Autokey Cipher, and it's now up to you to decode it. The encrypted message is: VYSGFV HASKHU ZTSA. To break the code, you will need the keyword used for encryption: KUX. Use your cryptographic skills to decrypt the message and reveal the hidden truth behind the ciphertext. Can you uncover the secret? \n\nSubmit the decoded message in the format: PCTF{plaintext}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"VYSGFV HASKHU ZTSA\"\nkey = \"KUX\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{LEVVBA MZSYIC BLQZ}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "VYSGFV HASKHU ZTSA",
        "key": "KUX",
        "plaintext": "LEVVBA MZSYIC BLQZ",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the distant future, a rogue group of hackers has intercepted a critical message encrypted with the Autokey Cipher. The message holds the key to a secret location, and the fate of the mission depends on decoding it. Your task is to decrypt the following ciphertext: EVGF UGYFDV OJIA OSSHPT FJW KXJJA, using the keyword: LJNPRV. Time is of the essence, and the mission cannot afford any delays. Retrieve the plaintext message and report your findings. Format your answer as: PCTF{plaintext}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"EVGF UGYFDV OJIA OSSHPT FJW KXJJA\"\nkey = \"LJNPRV\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{TMTQ DLFTKF LYDH ENHJMM BWP BLXIE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "EVGF UGYFDV OJIA OSSHPT FJW KXJJA",
        "key": "LJNPRV",
        "plaintext": "TMTQ DLFTKF LYDH ENHJMM BWP BLXIE",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message has been hidden using an Autokey Cipher, and it is now your task to uncover the truth behind it. You have intercepted a ciphertext: LHPLK PTF FUD RBCIM. The encryption was performed using the keyword: HEQ. Can you decrypt this message and reveal the original text? Time is of the essence, as the contents of this message could change the course of history. Solve it before it's too late! Submit the decrypted message in the format: PCTF{plaintext}.",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"LHPLK PTF FUD RBCIM\"\nkey = \"HEQ\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{EDZHH QMY PIF CTXGT}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "LHPLK PTF FUD RBCIM",
        "key": "HEQ",
        "plaintext": "EDZHH QMY PIF CTXGT",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the midst of an ancient battle, a secret message was sent between two commanders using the Autokey Cipher to ensure their plans remained undetected. The message, encrypted with the keyword USDPR, was intercepted by enemy forces. You, as an elite cryptanalyst, have managed to acquire the ciphertext: MXLMS SLHTE KDFY SQS OVQE. Your task is to decrypt the message and uncover the vital intelligence hidden within. Time is of the essence, so decode it quickly and submit the plaintext as: PCTF{plaintext_string}.",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"MXLMS SLHTE KDFY SQS OVQE\"\nkey = \"USDPR\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SFIXB AGZWD KXGC PGV ITBY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "MXLMS SLHTE KDFY SQS OVQE",
        "key": "USDPR",
        "plaintext": "SFIXB AGZWD KXGC PGV ITBY",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a hidden vault deep within an ancient library, a message was found encrypted using the Autokey Cipher. The encrypted message reads: IIGOL PXYRY QLIW, and the keyword used for encryption is: OHIJJJS. Your mission, should you choose to accept it, is to decrypt this message and unveil its secrets. Solve the puzzle and uncover the truth behind the mysterious message.\n\nSubmit the decrypted message in the format: PCTF{plaintext_string}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"IIGOL PXYRY QLIW\"\nkey = \"OHIJJJS\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{UBYFC GFEQA LJCR}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "IIGOL PXYRY QLIW",
        "key": "OHIJJJS",
        "plaintext": "UBYFC GFEQA LJCR",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the quiet town of Veldron, a secret message was passed between two agents using a mysterious cipher. The only clue left behind was the encrypted text: FFAOW XIB VNWV WJC. A keyword was used to encrypt the message, but it's been lost to time. However, you have discovered the keyword: QOMJUD. Your task is to decipher the message and uncover the hidden secret. Solve this puzzle and find out what the agents were trying to convey. \n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"FFAOW XIB VNWV WJC\"\nkey = \"QOMJUD\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{PROFC UTK HIUB DZV}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "FFAOW XIB VNWV WJC",
        "key": "QOMJUD",
        "plaintext": "PROFC UTK HIUB DZV",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a long-forgotten library, a mysterious note was discovered hidden inside an ancient book. The note, containing a message encrypted using the Autokey Cipher, was written in a language that only those who could decode it would understand. The encrypted message reads: MWOO SGAWU CDR GRNJES HQJ. The only clue left behind was a keyword: OZTSY. Can you decrypt this cryptic message and uncover the secrets hidden within? \n\nSubmit your answer in the following format: PCTF{decrypted_message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"MWOO SGAWU CDR GRNJES HQJ\"\nkey = \"OZTSY\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{YXVW UIDBY IVO FTFOQN OLV}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "MWOO SGAWU CDR GRNJES HQJ",
        "key": "OZTSY",
        "plaintext": "YXVW UIDBY IVO FTFOQN OLV",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a secretive organization, a cryptographer has hidden a crucial message using the Autokey cipher. The encrypted message, which contains vital information about a covert operation, is as follows: GXF BVD KHPAFO VGX. The cryptographer used a special keyword to encrypt the message, and the keyword is: KFD. Your task is to decrypt the message and reveal the secret. \nSubmit the decoded message in the format: PCTF{plaintext}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"GXF BVD KHPAFO VGX\"\nkey = \"KFD\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{WSC FDB FEOVBA AFX}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "GXF BVD KHPAFO VGX",
        "key": "KFD",
        "plaintext": "WSC FDB FEOVBA AFX",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A secret message has been intercepted, and it has been encrypted using the Autokey Cipher. The encrypted message is: NVJOE QZQJAS KJPMC QJMT ERI. The encryption was carried out with the keyword: ENN. Your mission is to decrypt this message and reveal its contents. Only the most skilled cryptographers can crack this code!\n\nSubmit the plaintext in the format: PCTF{decrypted message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"NVJOE QZQJAS KJPMC QJMT ERI\"\nkey = \"ENN\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{JIWFW UUUPGY VDRRZ ZSNU MEO}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "NVJOE QZQJAS KJPMC QJMT ERI",
        "key": "ENN",
        "plaintext": "JIWFW UUUPGY VDRRZ ZSNU MEO",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A covert message has been intercepted, encrypted using the Autokey Cipher. The authorities have confirmed that the encryption follows a strict key pattern derived from a seemingly innocuous word. Your mission, should you choose to accept it, is to uncover the original message hidden within. The encrypted message you need to decrypt is: UGBE ZEL DJJXCY MDJ ZTLC, and the keyword used to encrypt it is: TATSLCV. Time is running out, so decrypt it as soon as possible and report back with your findings. Your submission should be formatted as: PCTF{plaintext}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"UGBE ZEL DJJXCY MDJ ZTLC\"\nkey = \"TATSLCV\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{BGIM OCQ CDBLOW WBG YIXG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "UGBE ZEL DJJXCY MDJ ZTLC",
        "key": "TATSLCV",
        "plaintext": "BGIM OCQ CDBLOW WBG YIXG",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library hidden beneath the sands of time, a cryptic message has been discovered, encoded with the powerful Autokey Cipher. The message, left by an unknown scholar, contains vital information that could unlock a long-lost secret. The encrypted message reads as follows: GSG KAFAHE VLQ. The key used for encryption is: MJLAZJGN. Your task is to decrypt this message and uncover the truth behind the scholar's words. What does the message reveal? Submit your answer in the format: PCTF{plaintext_string}.",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"GSG KAFAHE VLQ\"\nkey = \"MJLAZJGN\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{UJV KBWUUK MQG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "GSG KAFAHE VLQ",
        "key": "MJLAZJGN",
        "plaintext": "UJV KBWUUK MQG",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious letter was intercepted during a covert mission. It contains crucial information, but it's been encrypted using the Autokey cipher to protect its secrets. The message reads: WQVZH CFY JNYDZ, and it was encrypted using the key: YGRLXNNH. Your task is to decrypt the message and uncover the hidden intelligence. \n\nCan you crack the code and reveal the message behind the cipher? \n\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"WQVZH CFY JNYDZ\"\nkey = \"YGRLXNNH\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{YKEOK PSR LDUPP}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "WQVZH CFY JNYDZ",
        "key": "YGRLXNNH",
        "plaintext": "YKEOK PSR LDUPP",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a hidden message from a secret society, you have intercepted an encrypted communication that uses the Autokey cipher. The message was encoded with a mysterious keyword, and now it's up to you to crack the code. The encrypted message is: SSWXSM RGQV DPV RBHMM MUIK. The keyword used for encryption is: JDVNNSGP. Your task is to decrypt the message and uncover the hidden secrets it contains. Remember, the keyword is crucial for the decryption. Good luck, agent. \n\nSubmission format: PCTF{decrypted_message}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"SSWXSM RGQV DPV RBHMM MUIK\"\nkey = \"JDVNNSGP\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{JPBKFU LRHG CFQ XQQFG KPSN}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "SSWXSM RGQV DPV RBHMM MUIK",
        "key": "JDVNNSGP",
        "plaintext": "JPBKFU LRHG CFQ XQQFG KPSN",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten library, you uncover a dusty old manuscript with an encrypted message written by an ancient cryptographer. The message was encoded using the Autokey cipher, a technique so intricate that only those with a deep understanding of cryptography could decode it. You manage to recover part of the ciphertext: LVVYGN GYA QXS HVOZZ PIRI AEBZSO. After extensive research, you also discover a fragment of the original keyword: QLYQ. Can you decrypt the message and reveal the secret hidden within? The plaintext holds an important clue that could unlock the next step in your quest. Submit your answer in the format: PCTF{plaintext}.",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"LVVYGN GYA QXS HVOZZ PIRI AEBZSO\"\nkey = \"QLYQ\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{VKXILD JQP NOC SIAXH HIUB TWHYZS}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "LVVYGN GYA QXS HVOZZ PIRI AEBZSO",
        "key": "QLYQ",
        "plaintext": "VKXILD JQP NOC SIAXH HIUB TWHYZS",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A cryptic message has been intercepted and it seems to have been encoded using the Autokey Cipher. The message contains valuable information, but without the proper key, it's unreadable. Here's what we have: YTR RMNO WAV SRPXIB. The keyword used for encryption is: MBNXYGP. Your task is to decode this message and reveal its secrets. Can you crack the code and uncover the hidden text? \n\nSubmission format: PCTF{plaintext}",
    "rationale": "\ndef autokey_decrypt(ciphertext, key):\n    '''\n    Decrypts a given ciphertext encrypted with the Keyword Autokey Cipher.\n    \n    In the Autokey Cipher, the keystream is generated by concatenating the key \n    with the plaintext. During decryption, the process is performed iteratively. \n    The initial segment of the keystream is the provided key, and each decrypted \n    letter is appended to the keystream for use in subsequent decryption.\n    \n    Non-alphabetic characters (e.g., spaces) are preserved in their original positions.\n    \n    Parameters:\n        ciphertext (str): The encrypted message with spaces preserved.\n        key (str): The key used to initiate the keystream.\n        \n    Returns:\n        str: The resulting plaintext in uppercase with spaces preserved.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    plaintext = []\n    letter_index = 0\n\n    for ch in ciphertext:\n        if ch.isalpha():\n            c_val = ord(ch.upper()) - ord('A')\n            k_char = keystream[letter_index]\n            k_val = ord(k_char) - ord('A')\n            p_val = (c_val - k_val) % 26\n            p_char = chr(p_val + ord('A'))\n            plaintext.append(p_char)\n            # Append the decrypted letter to the keystream for subsequent decryption\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            plaintext.append(ch)\n    \n    return ''.join(plaintext)\n\n# Given ciphertext and key\nciphertext = \"YTR RMNO WAV SRPXIB\"\nkey = \"MBNXYGP\"\n\n# Decryption process\nplaintext = autokey_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{MSE UOHZ KIR YDIYYT}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Autokey",
      "change_detail": "The Autokey Cipher is a polyalphabetic substitution cipher that enhances the key schedule by appending the plaintext to an initial key. In the key Autokey variant, the keystream is generated by concatenating the key with the plaintext, then truncating the result to the length of the plaintext. Each letter of the plaintext is shifted by the numerical value of the corresponding keystream letter, making the cipher more resistant to frequency analysis than the traditional Vigenère cipher.",
      "synthesis_code": "\ndef autokey_encrypt(plaintext, key):\n    '''\n    Encrypts a given plaintext using the Keyword Autokey Cipher.\n    \n    Parameters:\n        plaintext (str): The message to encrypt. Alphabetic characters are encrypted, while non-alphabetic \n                         characters (such as spaces) are preserved in their original positions.\n        key (str): The keyword used to initiate the keystream.\n        \n    Returns:\n        str: The resulting ciphertext in uppercase with spaces preserved.\n        \n    Example:\n        plaintext = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"\n        key = \"CULTURE\"\n        # The keystream is generated by starting with \"CULTURE\" and then appending each processed plaintext letter.\n        # Non-alphabetic characters like spaces are not encrypted and remain at their positions.\n    '''\n    key = key.upper()\n    keystream = list(key)\n    ciphertext = []\n    letter_index = 0  # Only count alphabetic characters\n\n    for ch in plaintext:\n        if ch.isalpha():\n            p_char = ch.upper()\n            k_char = keystream[letter_index]\n            p_val = ord(p_char) - ord('A')\n            k_val = ord(k_char) - ord('A')\n            cipher_val = (p_val + k_val) % 26\n            cipher_char = chr(cipher_val + ord('A'))\n            ciphertext.append(cipher_char)\n            # Append the current plaintext letter to the keystream\n            keystream.append(p_char)\n            letter_index += 1\n        else:\n            # Preserve non-alphabetic characters as is\n            ciphertext.append(ch)\n    \n    return ''.join(ciphertext)\n\nplaintext = \"{plaintext}\" \nkey = \"{key}\"  \nciphertext = autokey_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "3",
      "original_data": {
        "ciphertext": "YTR RMNO WAV SRPXIB",
        "key": "MBNXYGP",
        "plaintext": "MSE UOHZ KIR YDIYYT",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library, hidden within the dusty shelves of forgotten tomes, an encrypted message was discovered. The cipher used to conceal this message is none other than the Bacon Cipher. The message consists of only uppercase English letters and spaces. Each letter in the plaintext has been encoded into a 5-character string, where 'A' represents 0 and 'B' represents 1 in binary. The encoding scheme follows a pattern where each letter (A-Z) is replaced by a specific combination of 'A' and 'B' characters. Spaces are left untouched and are visible in the ciphertext. The cipher text has been carefully crafted, and to decrypt the message, you must first understand the peculiar encoding method employed.In this challenge, the uppercase letters represent 'B', while the lowercase letters represent 'A'. Your task is to decode the encrypted message and reveal the original plaintext.Ciphertext: dkALvgzCKtajhgDubCVJEgpnpnQQoY yYIGxnETQLgAxOc sOYptjjFvYJeujnZiPapxirUg bDxlMNrurkuAKWdILaxjkcoNkxFRfmUncover the hidden words and discover the message. The final solution is the decrypted plaintext enclosed in the format: PCTF{plaintext}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"dkALvgzCKtajhgDubCVJEgpnpnQQoY yYIGxnETQLgAxOc sOYptjjFvYJeujnZiPapxirUg bDxlMNrurkuAKWdILaxjkcoNkxFRfm\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ggbhqn opk mfquc jqoycm}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "dkALvgzCKtajhgDubCVJEgpnpnQQoY yYIGxnETQLgAxOc sOYptjjFvYJeujnZiPapxirUg bDxlMNrurkuAKWdILaxjkcoNkxFRfm",
        "plaintext": "ggbhqn opk mfquc jqoycm",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ancient order of cryptographers, known for their mastery of secret codes, has left behind a mysterious message encrypted using the Bacon Cipher. Legend has it that this cipher was used by scholars to safeguard their greatest discoveries, and now, you've stumbled upon a fragment of their encrypted knowledge. The message, written in English, uses only letters (A-Z) and spaces, with the cipher applied to keep its contents hidden from prying eyes.\n\nIn this cipher, each letter from A to Z is mapped to a 5-bit binary number, and then encoded using the letters 'A' and 'B' to represent binary digits. The order is simple: A corresponds to 0 and B corresponds to 1. While spaces remain unaffected by encryption, they are preserved in the final ciphertext to maintain the message's structure. This particular challenge uses uppercase letters to represent 'B' and lowercase letters to represent 'A'.\n\nThe encrypted message you need to decipher is as follows:\n\nWlejAFnxmvCzYkbidVNS lndTxFyHJrFpdTdszPTi rpOTnoavvakyJAb DoUMwLvsRbZhztY\n\nCan you decode the hidden knowledge? Unveil the original plaintext message and submit it in the format: PCTF{decoded plaintext}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"WlejAFnxmvCzYkbidVNS lndTxFyHJrFpdTdszPTi rpOTnoavvakyJAb DoUMwLvsRbZhztY\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rquh cwsg gag wsr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "WlejAFnxmvCzYkbidVNS lndTxFyHJrFpdTdszPTi rpOTnoavvakyJAb DoUMwLvsRbZhztY",
        "plaintext": "rquh cwsg gag wsr",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A long-forgotten manuscript was discovered hidden within the archives of an ancient library. The text was encoded using a peculiar cipher-one that the library's caretakers had used for centuries to protect secrets. This cipher, known as the Bacon Cipher, was employed to encode important messages without raising suspicion. The caretakers, highly trained in the art of encryption, encoded their messages by translating each letter of the alphabet into a 5-letter binary string. The letters 'A' and 'B' represented binary digits 0 and 1, respectively, and the alphabet was mapped accordingly. Spaces were left untouched but preserved for structure.\n\nIn this challenge, the plaintext message consists solely of uppercase English letters and spaces, forming a coherent sentence. The encryption method used is: each letter is first converted into its corresponding binary string and then mapped to a combination of five 'A's and 'B's, where 'A' denotes 0 and 'B' denotes 1.\n\nHowever, there's a twist in the encryption: the message was further disguised by flipping the case of each character. In the ciphertext, capital letters represent 'B' and lowercase letters represent 'A'. The ciphertext is as follows:\n\nVUqiksCGdWlElSQluBpG dcJMbcMSrtPXieRIWkaRiAegLnyiVr iqDYhZXkmDZoeCH\n\nYour task is to uncover the original message encoded within. Once decoded, the message will lead you to a hidden treasure. Can you break the code and find what was kept secret for so long?\n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"VUqiksCGdWlElSQluBpG dcJMbcMSrtPXieRIWkaRiAegLnyiVr iqDYhZXkmDZoeCH\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ynlf gmzzjc gzt}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "VUqiksCGdWlElSQluBpG dcJMbcMSrtPXieRIWkaRiAegLnyiVr iqDYhZXkmDZoeCH",
        "plaintext": "ynlf gmzzjc gzt",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message has been intercepted, encoded with the ancient Bacon cipher, hidden in plain sight. The message contains only uppercase and lowercase English letters, along with spaces that separate the words. The cipher works by translating each letter into a 5-character binary code, with 'A' representing 0 and 'B' representing 1. The letters of the alphabet are encoded sequentially, with 'A' mapped to 00000 and 'Z' mapped to 11001. Spaces are preserved in the ciphertext but are not encrypted.\n\nIn this challenge, uppercase letters represent 'B' and lowercase letters represent 'A' in the cipher. Your task is to decipher the secret message concealed within the ciphertext below. Can you crack the code and reveal the hidden truth?\n\nCiphertext:\nNhHFwkWISvEmxvscVhTdpnPdp gyQMlhlWafxdUTQcQZjegdxojRxBBX MknNPvacNTFmhLqykMmjteOJo gvbFzkbSfJkTBSqbzbYZ\n\nGood luck, agent. Your submission format should be: PCTF{deciphered_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"NhHFwkWISvEmxvscVhTdpnPdp gyQMlhlWafxdUTQcQZjegdxojRxBBX MknNPvacNTFmhLqykMmjteOJo gvbFzkbSfJkTBSqbzbYZ\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{woqke gehmax tdseg cfod}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "NhHFwkWISvEmxvscVhTdpnPdp gyQMlhlWafxdUTQcQZjegdxojRxBBX MknNPvacNTFmhLqykMmjteOJo gvbFzkbSfJkTBSqbzbYZ",
        "plaintext": "woqke gehmax tdseg cfod",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious message has been intercepted, encrypted using the Bacon cipher. The sender, an elusive figure known only as 'The Enigmatic Scholar,' is believed to be hiding crucial information. The message, a secretive correspondence, contains only uppercase English letters, lowercase letters, and spaces, which hold the key to unraveling the mystery. The cipher uses the following encoding method: each letter of the alphabet (A-Z) is mapped to a unique 5-bit binary sequence, where 'A' represents 0, and 'B' represents 1. The message was then concealed in a series of five-character strings composed of A's and B's, with spaces left untouched in the final ciphertext. The twist? The sender decided to flip the case of the letters - uppercase letters represent 'B,' and lowercase letters represent 'A.' A rare cipher, indeed! \n\nYour task is to decode the encrypted message. The ciphertext is as follows: \nbEVrptEYKGxKtbw oVqptsofhIIjGCDpkOvMexzXT YnefubSYgMUBtkrbaKlEDdBFuwtmbe \n\nCan you uncover the truth hidden within this cryptic communication? Remember to submit the decoded message in the format: PCTF{decoded_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"bEVrptEYKGxKtbw oVqptsofhIIjGCDpkOvMexzXT YnefubSYgMUBtkrbaKlEDdBFuwtmbe\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{mpi ibxfd qnyfwa}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "bEVrptEYKGxKtbw oVqptsofhIIjGCDpkOvMexzXT YnefubSYgMUBtkrbaKlEDdBFuwtmbe",
        "plaintext": "mpi ibxfd qnyfwa",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a forgotten library, an ancient manuscript was discovered, its pages yellowed with age. The text within was encoded using a mysterious cipher that only a few cryptography scholars knew about – the Bacon Cipher. The text is a message from a secret society, hidden within layers of symbolism and disguised in a series of cryptic characters. The cipher uses the English alphabet, and spaces are preserved but not encrypted. The method of encryption involves transforming each letter into a five-character string, using the binary system: A is represented by 0, and B by 1. In this case, the convention is reversed - uppercase letters are mapped to B, while lowercase letters represent A. With this in mind, decode the encrypted message to unveil the hidden information. The ciphertext is as follows: tzJmjovuRrgvWYNraBWU EguuorSurgoHIjORlNsqPwfOt bRujeOjdprBlCdhkoYzGGCzen. Can you uncover the secret? To submit your solution, use the format: PCTF{plaintext_message}.",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"tzJmjovuRrgvWYNraBWU EguuorSurgoHIjORlNsqPwfOt bRujeOjdprBlCdhkoYzGGCzen\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{echh qinus iqufy}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "tzJmjovuRrgvWYNraBWU EguuorSurgoHIjORlNsqPwfOt bRujeOjdprBlCdhkoYzGGCzen",
        "plaintext": "echh qinus iqufy",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A mysterious figure known as The Ciphermaster has hidden a secret message within a series of strange symbols. This message has been encrypted using the Bacon Cipher, a cipher based on binary encoding. Each letter of the alphabet is represented by a unique 5-letter sequence of A's and B's, where 'A' stands for 0 and 'B' stands for 1. The message was crafted to convey a critical piece of information, but only those who can decode this puzzle will be able to uncover its true meaning.\n\nThe Ciphermaster left a clue: 'The alphabet is your map, each letter a step toward the truth.' Your task is to decipher the encrypted message and reveal the original plaintext, which is a sentence that makes perfect sense when read aloud.\n\nSpaces are preserved in the ciphertext, but they were not encoded. In this challenge, uppercase letters represent 'B' and lowercase letters represent 'A'.\n\nThe ciphertext you need to decrypt is as follows:\n\nHuvOsrnnPexecyvqupEB WhVpHSuYqsTiXhYWKzlWqXKzt FvCuUjESMOSLcsonDOAp HucnkaWMtZjwziKnewALnbXwn\n\nSolve this puzzle and submit your answer in the following format: PCTF{plaintext}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"HuvOsrnnPexecyvqupEB WhVpHSuYqsTiXhYWKzlWqXKzt FvCuUjESMOSLcsonDOAp HucnkaWMtZjwziKnewALnbXwn\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{scad vuvzm vpyo qnbde}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "HuvOsrnnPexecyvqupEB WhVpHSuYqsTiXhYWKzlWqXKzt FvCuUjESMOSLcsonDOAp HucnkaWMtZjwziKnewALnbXwn",
        "plaintext": "scad vuvzm vpyo qnbde",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the year 2045, an ancient encrypted document was discovered in a forgotten library. Historians quickly identified that the text had been encoded using a peculiar cipher known as the Bacon Cipher. This cipher, which dates back to the 17th century, was once used to secretly communicate messages without detection. The message, however, was encoded in a way that only the skilled could decrypt it.\n\nYour task is to unravel the mystery. The message consists solely of uppercase letters and spaces, and it is known that the encoding process involved the transformation of each letter (A-Z) into a 5-character binary code, where 'A' corresponds to 0 and 'B' to 1. Spaces in the original message were preserved but not encoded.\n\nHowever, there's a twist: this particular message was further encoded in a way that uppercase letters are used to represent 'B', and lowercase letters represent 'A'. To complicate things further, the historian who created this challenge has intentionally obfuscated the ciphertext. The encrypted message is presented below:\n\nWbBfrbPVpmdJeNHgyGNmHrPSNxEDwC yrwIgyBCqcuqIStswPpxOkpujjJOYS KUvxaFlScfRjKJNTinIm KCefHdcvwkGEdhGIyahPeZnyj\n\nYour goal is to decrypt the message back to its original plaintext. Once you have decoded the message, submit it in the format: PCTF{decoded_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"WbBfrbPVpmdJeNHgyGNmHrPSNxEDwC yrwIgyBCqcuqIStswPpxOkpujjJOYS KUvxaFlScfRjKJNTinIm KCefHdcvwkGEdhGIyahPeZnyj\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{umlgxn cmgeqp yuxs zazri}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "WbBfrbPVpmdJeNHgyGNmHrPSNxEDwC yrwIgyBCqcuqIStswPpxOkpujjJOYS KUvxaFlScfRjKJNTinIm KCefHdcvwkGEdhGIyahPeZnyj",
        "plaintext": "umlgxn cmgeqp yuxs zazri",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the quiet town of Cryptville, an ancient cipher was discovered, hidden within the walls of an old library. Legend has it that the cipher was used by secretive scholars to protect their most valuable knowledge. The cipher in question is the Bacon Cipher, an elegant yet simple system that disguises letters with strings of binary-like symbols. In this challenge, the scholars used uppercase and lowercase letters to represent binary values in a creative twist, where uppercase letters represent 'B' (binary 1) and lowercase letters represent 'A' (binary 0). Spaces between words remain unchanged, allowing some breathing room between the hidden messages. The scholars had carefully encoded a message in this mysterious code, and your task is to uncover it. The message is encrypted with the Bacon Cipher, and here's the ciphertext you must decrypt:BbXDAqyuWNbJWqunKHRSuLzvc IMfmgAmuOFxSjrhtlMzV yPcTDcrtkRRNaruxVpvowrFUTiKqKTGood luck, cryptographer. The fate of Cryptville's secrets lies in your hands.To submit your answer, please use the format: PCTF{decrypted_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"BbXDAqyuWNbJWqunKHRSuLzvc IMfmgAmuOFxSjrhtlMzV yPcTDcrtkRRNaruxVpvowrFUTiKqKT\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xdmpi ytif lbyihl}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "BbXDAqyuWNbJWqunKHRSuLzvc IMfmgAmuOFxSjrhtlMzV yPcTDcrtkRRNaruxVpvowrFUTiKqKT",
        "plaintext": "xdmpi ytif lbyihl",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A long-forgotten secret message has been uncovered, encrypted with the Bacon Cipher, a clever code dating back to the 17th century. The message, once hidden within an ancient manuscript, is said to contain crucial information about an undiscovered treasure. The text, containing only uppercase English letters and spaces, holds the key to finding the hidden fortune. To decipher the code, you'll need to convert each letter of the ciphertext into a binary sequence of 'A' and 'B'. In this variant, uppercase letters represent 'B', while lowercase letters stand for 'A'. Spaces remain intact, serving as dividers between words. The cipher is as follows: LrXJVnAWTXQBptxQMtnbafFUEvLesP SwiiqSayCNoSRQLuuyMl FvMgpnPbdGJiBCapzbgI TyiuiwjJTeoAPWb. Can you unlock the treasure's secrets by revealing the original plaintext message? \n\nSubmit the decoded message in the format: PCTF{plaintext}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"LrXJVnAWTXQBptxQMtnbafFUEvLesP SwiiqSayCNoSRQLuuyMl FvMgpnPbdGJiBCapzbgI TyiuiwjJTeoAPWb\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xpyyhj qtpc ujwb qgo}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "LrXJVnAWTXQBptxQMtnbafFUEvLesP SwiiqSayCNoSRQLuuyMl FvMgpnPbdGJiBCapzbgI TyiuiwjJTeoAPWb",
        "plaintext": "xpyyhj qtpc ujwb qgo",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old library deep within the castle of the mysterious Cipher Lord, you discover an ancient manuscript containing a strange cryptic message. The parchment reveals that the Cipher Lord used a peculiar cipher to hide his most coveted secrets. This cipher, known as the Bacon Cipher, uses an intricate binary encoding system to disguise his messages. The letters of the alphabet are substituted with combinations of two symbols, A and B, where the letter 'A' represents binary 0, and 'B' represents binary 1. The message also cleverly hides spaces, leaving them unencrypted but preserving their positions to ensure the flow of the text. To add an extra twist, the Lord had a peculiar custom of switching the case of the letters in his encoded messages. Uppercase letters represent 'B', and lowercase letters represent 'A'. You have uncovered the encrypted text hidden within the pages of the manuscript, but it is still a mystery waiting to be unraveled. The message you have found reads as follows:hdVSqxGcZQNbwLOhGLJHUVredHtwnU tafWHyVSZCnFfsy RQilNQrxIxKvjLdasdalRyHMo gKCXiswVYXmoipbyZYbLYour task is to decipher the original message and uncover the secrets it holds. The encrypted message only contains uppercase and lowercase letters, and spaces appear where the Cipher Lord intended. Can you decrypt this puzzle and reveal the hidden knowledge?Submit your solution in the format: PCTF{plaintext_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"hdVSqxGcZQNbwLOhGLJHUVredHtwnU tafWHyVSZCnFfsy RQilNQrxIxKvjLdasdalRyHMo gKCXiswVYXmoipbyZYbL\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{gltpyr dpi zssaw ohan}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "hdVSqxGcZQNbwLOhGLJHUVredHtwnU tafWHyVSZCnFfsy RQilNQrxIxKvjLdasdalRyHMo gKCXiswVYXmoipbyZYbL",
        "plaintext": "gltpyr dpi zssaw ohan",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a long-forgotten library, an ancient codex was discovered. It is said that this codex contains hidden messages, encoded in the Bacon Cipher. The scholars of old used this technique to communicate in secrecy, leaving behind a series of cryptic messages for those who dared to uncover their meaning. The message you're about to decode is part of this legacy. Only those with the patience and skill to decode the message will unveil the truth.\n\nThe Bacon Cipher works by substituting each letter in the alphabet with a unique 5-character binary sequence. The letters 'A' and 'B' represent 0 and 1, respectively, in the binary system. A key feature of this cipher is that it replaces the entire alphabet, which is represented by a combination of uppercase and lowercase letters. Spaces are left intact and are not encoded.\n\nIn this challenge, uppercase letters represent 'B' and lowercase letters represent 'A'. Your mission is to decode the hidden message within the cipher below.\n\nCiphertext: mDupTGUelgIvyxrjofPJ iRRNPnHqrhyuVpg pSgGiaNqaUrBNJp\n\nCan you decipher the hidden truth and reveal the original message? Once you crack the code, submit the message in the following format: PCTF{original_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"mDupTGUelgIvyxrjofPJ iRRNPnHqrhyuVpg pSgGiaNqaUrBNJp\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{jyqd pie kjo}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "mDupTGUelgIvyxrjofPJ iRRNPnHqrhyuVpg pSgGiaNqaUrBNJp",
        "plaintext": "jyqd pie kjo",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a world where secret messages are the key to unlocking hidden knowledge, an ancient cryptographer left behind a puzzle, using the elusive Bacon Cipher to safeguard the most important information. This cipher, named after the cryptographer, replaces each letter with a series of 5 characters, each either an 'A' or 'B'. The secret code was concealed using the characters 'A' for '0' and 'B' for '1'. Spaces are maintained but are not encoded.\n\nThe ciphertext contains the encrypted message, and your task is to decode it using the Bacon Cipher method.\n\nThe secret message you must decode is:\n\nuJfggkCltsgvfSlXnQtjwGADu VuiNkvMvcGEetSQ rNFuoaNQXIquwnnBkUTu vqVlroITULNyGCWmjZXtPopUR PAodloFtAHDwwRq\n\nThe original plaintext only contains uppercase letters and spaces. Can you uncover the hidden message within the cipher?\n\nSubmit your answer in the format: PCTF{plaintext_string}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"uJfggkCltsgvfSlXnQtjwGADu VuiNkvMvcGEetSQ rNFuoaNQXIquwnnBkUTu vqVlroITULNyGCWmjZXtPopUR PAodloFtAHDwwRq\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{iicuo sjt mpaw epxgt yls}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "uJfggkCltsgvfSlXnQtjwGADu VuiNkvMvcGEetSQ rNFuoaNQXIquwnnBkUTu vqVlroITULNyGCWmjZXtPopUR PAodloFtAHDwwRq",
        "plaintext": "iicuo sjt mpaw epxgt yls",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a quiet village, an ancient letter was discovered hidden inside a dusty chest. The letter, written in a mysterious code, was said to contain the location of a long-lost treasure. You, a brilliant cryptographer, were tasked with deciphering it. The letter uses a Bacon cipher to encode the secret message. The ciphertext consists only of uppercase and lowercase letters, where uppercase represents 'B' and lowercase represents 'A'. Spaces between words remain unchanged in the message. Your job is to decode the message and reveal the hidden clue that will lead to the treasure.\n\nThe encoding process involves mapping each letter of the alphabet (A-Z) to a 5-bit binary sequence, where 0 is represented by 'A' and 1 by 'B'. These sequences are then used to form groups of 5 characters. For this challenge, uppercase letters correspond to 'B', and lowercase letters correspond to 'A'.\n\nCiphertext:\nlevTkixJMoJzNSCFclipsHoSh xosdauFHiDCtQeeWmihlDmlgoLpLsQ fJiDUkPxcrAgqkz uOwcjiRNiqXMqmVErmNC oeNKonvEJZrOkFfFoclM\n\nDecode the message and find the original plaintext. Remember to submit your answer in the format: PCTF{decoded_message}",
    "rationale": "import random\n\n# A/B 编码转字母\ndef ab_to_char(ab):\n    binary = ''.join('0' if ch == 'A' else '1' for ch in ab)\n    index = int(binary, 2)\n    if 0 <= index < 26:\n        return chr(ord('a') + index)\n    else:\n        return '?'  # 如果出错，返回占位符\n\n# 解密函数\ndef bacon_decrypt(ciphertext):\n    words = ciphertext.split(' ')  # 按空格拆分\n    plaintext_words = []\n\n    for word in words:\n        ab_code = ''\n        for ch in word:\n            if ch.islower():\n                ab_code += 'A'\n            elif ch.isupper():\n                ab_code += 'B'\n            # 忽略非字母字符\n\n        # 每5个A/B解一个字母\n        plain = ''\n        for i in range(0, len(ab_code), 5):\n            chunk = ab_code[i:i+5]\n            if len(chunk) == 5:\n                plain += ab_to_char(chunk)\n\n        plaintext_words.append(plain)\n\n    return ' '.join(plaintext_words)\n    \n# 给定的密文和密钥\nciphertext = \"levTkixJMoJzNSCFclipsHoSh xosdauFHiDCtQeeWmihlDmlgoLpLsQ fJiDUkPxcrAgqkz uOwcjiRNiqXMqmVErmNC oeNKonvEJZrOkFfFoclM\"\n\n# 解密\nplaintext = bacon_decrypt(ciphertext)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{cgxqk anuqqv liq imzt ghkr}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Bacon",
      "change_detail": "The Bacon cipher is a classical steganographic cipher invented by Francis Bacon. It encodes each letter of the plaintext into a group of five 'A' or 'B' characters, representing a 5-bit binary number. Typically, the letter 'a' is represented as 'AAAAA' (00000), 'b' as 'AAAAB' (00001), ..., and 'z' as 'BBAAB' (11001). In this version, 'A' is mapped to lowercase letters, and 'B' to uppercase letters, allowing hidden messages to be embedded within seemingly normal text using font case.",
      "synthesis_code": "import random\n\n# 字母转 A/B 编码（通过二进制计算）\ndef char_to_ab(ch):\n    index = ord(ch) - ord('a')\n    binary = format(index, '05b')  # 转为5位二进制字符串\n    return ''.join('A' if b == '0' else 'B' for b in binary)\n\n# 加密函数\ndef bacon_encrypt(plaintext):\n    plaintext = plaintext.lower()\n    ab_code = ''\n    for ch in plaintext:\n        if ch.isalpha():\n            ab_code += char_to_ab(ch)\n        else:\n            ab_code += ch\n    \n    ciphertext = ''\n    for ab in ab_code:\n        if ab == 'A':\n            ciphertext += random.choice('abcdefghijklmnopqrstuvwxyz')\n        elif ab == 'B':\n            ciphertext += random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        else:\n            ciphertext += ab\n    return ciphertext\n\n\nplaintext = \"{plaintext}\"  # 必须是小写，可以有空格\nciphertext = bacon_encrypt(plaintext)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "levTkixJMoJzNSCFclipsHoSh xosdauFHiDCtQeeWmihlDmlgoLpLsQ fJiDUkPxcrAgqkz uOwcjiRNiqXMqmVErmNC oeNKonvEJZrOkFfFoclM",
        "plaintext": "cgxqk anuqqv liq imzt ghkr",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Legends tell of a secret message hidden by ancient sages, encoded with the legendary Caesar cipher. The message reads:\nAol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\nUnravel the mystery and reveal the message. Beware, for the key lies in your deduction skills.\n\nSubmit in the format: PCTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the ancient library of Alexandria, a scroll with a puzzling message was discovered, encrypted with a Caesar cipher. The ciphertext is: Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl.\nYour mission is to decipher the message revealing the hidden truth.\nSubmit your answer as PCTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\"\nkey = 5\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 5,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During the renovation of an ancient library, a mysterious scroll was uncovered. It was encrypted using a shift cipher, believed to be favored by the Roman military for secure communications. Scholars are eager to decode its contents. Can you unveil the hidden message? The encrypted text is:\nAol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\nSubmit your answer in the format: PCTF{plaintext message here}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Recently, archaeologists unearthed a scroll from the ruins of an ancient castle. The scroll contains a mysterious message encrypted with the Caesar cipher. Legend says that the message holds the key to the legendary treasure of Avalon. The coded message is as follows:\nGur dhvpx oebja sbk whzcf bire gur ynml qbt\nDecrypt the message to unveil the secret.\n\nSubmit format: PCTF{plaintext}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Gur dhvpx oebja sbk whzcf bire gur ynml qbt\"\nkey = 13\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gur dhvpx oebja sbk whzcf bire gur ynml qbt",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 13,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of a forgotten jungle, archeologists stumbled upon encrypted scrolls believed to be a message from a lost civilization. The scrolls contained a passage encoded with a Caesar cipher: Lewsvylyz mvbuk opkklu thwz pu aol hujplua ybpuz. Decipher this text to unlock the secrets of the ancients. Submit your answer as: PCTF{plaintext}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Lewsvylyz mvbuk opkklu thwz pu aol hujplua ybpuz\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Explorers found hidden maps in the ancient ruins}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Lewsvylyz mvbuk opkklu thwz pu aol hujplua ybpuz",
        "plaintext": "Explorers found hidden maps in the ancient ruins",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "As a cryptanalyst, you've discovered a timeworn scroll in a forgotten library, encrypted with a Caesar cipher. The encoded message reads as follows:\nAol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\nBy deciphering it, you can unveil the last words of a legendary sage.\n\nSubmit format: PCTF{your decrypted message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the hidden library of Alexanderia, a scroll reveals secrets guarded for centuries. To unlock its wisdom, decipher the mysterious message encrypted with a Caesar cipher. Here lies the hidden text: Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn. Solve the enigma and submit your answer as: PCTF{plaintext}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An ancient scroll was unearthed from the ruins of a forgotten library. It appears to have been encoded using a mysterious substitution method known to historians. Can you decipher its secrets?\n\nCiphertext:\nBpm bzmiaczm qa pqllmv cvlmz bpm wtl wis bzmm\n\nSubmit your answer in the format: PCTF{plaintext string}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Bpm bzmiaczm qa pqllmv cvlmz bpm wtl wis bzmm\"\nkey = 8\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The treasure is hidden under the old oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Bpm bzmiaczm qa pqllmv cvlmz bpm wtl wis bzmm",
        "plaintext": "The treasure is hidden under the old oak tree",
        "key": 8,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the archives of an ancient library, a dusty scroll was uncovered, containing an encrypted message believed to be from a forgotten civilization. As a skilled cryptographer, your task is to decrypt the following Caesar cipher:\n\nPu h xbpla cpsshnl, zljylaz vm aol whza hyl dopzwlylk aoyvbno aol dpuk\n\nReveal the hidden message and piece together the fragments of history.\n\nSubmit your answer in the format: CTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Pu h xbpla cpsshnl, zljylaz vm aol whza hyl dopzwlylk aoyvbno aol dpuk\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{In a quiet village, secrets of the past are whispered through the wind}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Pu h xbpla cpsshnl, zljylaz vm aol whza hyl dopzwlylk aoyvbno aol dpuk",
        "plaintext": "In a quiet village, secrets of the past are whispered through the wind",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an expedition in the ancient ruins of a mythical empire, archaeologists unearthed a scroll encrypted with the letters of a famous phrase. The cipher used seems to be a Caesar Cipher, a historic technique dating back to the times of the legendary Caesar himself. However, the scroll provides no direct clue to the key used. Can you decipher this message and discover the phrase that has baffled historians for centuries? The ciphertext is as follows: Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo Your task is to solve the puzzle and reveal the secret text.\n\nSubmission format: PCTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo\"\nkey = 8\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 8,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of an ancient library, you discover a scroll containing an encrypted message written in the enigmatic Caesar cipher. The scroll reads: Jvvb kyv yzuuve kivrjliv leuvi kyv fcu frb kivv. Your task is to unravel the mystery and reveal the secret message hidden within.\n\nSubmission format: PCTF{decrypted_message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Jvvb kyv yzuuve kivrjliv leuvi kyv fcu frb kivv\"\nkey = 17\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Seek the hidden treasure under the old oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Jvvb kyv yzuuve kivrjliv leuvi kyv fcu frb kivv",
        "plaintext": "Seek the hidden treasure under the old oak tree",
        "key": 17,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an excavation at an ancient Roman site, archaeologists unearthed a mysterious inscribed tablet. The message appears to be encrypted using the famous Caesar cipher. Can you decipher the message below?\n\nAol aylhzbyl pz ibyplk bukly aol vsk vhr ayll\n\nReveal the secret information hidden within this encrypted message.\n\nSubmit your answer in the format: PCTF{plaintext message in lower case}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol aylhzbyl pz ibyplk bukly aol vsk vhr ayll\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The treasure is buried under the old oak tree}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol aylhzbyl pz ibyplk bukly aol vsk vhr ayll",
        "plaintext": "The treasure is buried under the old oak tree",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an exploration of an ancient library, a faded scroll was discovered, containing a message believed to hold the secret location of a long-lost treasure. The message was encrypted with a Caesar cipher, an ancient form of encryption once used by the Romans. The ciphertext is as follows:\n\nGur dhvpx oebja sbk whzcf bire gur ynml qbt\n\nYour mission is to decrypt the message and uncover the truth hidden within.\n\nSubmission format: PCTF{plaintext message in uppercase}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Gur dhvpx oebja sbk whzcf bire gur ynml qbt\"\nkey = 13\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gur dhvpx oebja sbk whzcf bire gur ynml qbt",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 13,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Legend has it that a map leading to a lost treasure was encrypted by a cunning knight. This map, etched onto stone, has bewildered seekers for centuries. Here lies the cipher that guards the path: Wblvhoxk max abwwxg mkxtlnkx uxgxtma max tgvbxgm lmhgxl. Use your skills to decrypt this message and reveal the fabled path to the treasure.\n\nSubmit format: PCTF{your plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Wblvhoxk max abwwxg mkxtlnkx uxgxtma max tgvbxgm lmhgxl\"\nkey = 19\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Discover the hidden treasure beneath the ancient stones}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Wblvhoxk max abwwxg mkxtlnkx uxgxtma max tgvbxgm lmhgxl",
        "plaintext": "Discover the hidden treasure beneath the ancient stones",
        "key": 19,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of an ancient library, a scroll was discovered with encrypted writings. The document appears to be protected by a Caesar cipher. Here is the ciphertext: Aol hujplua spiyhyf ovskz zljylaz myvt h mvynvaalu jpcpspghapvu. Your mission is to decrypt this message and unveil the secrets it holds. Submit your answer as: PCTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol hujplua spiyhyf ovskz zljylaz myvt h mvynvaalu jpcpspghapvu\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The ancient library holds secrets from a forgotten civilization}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol hujplua spiyhyf ovskz zljylaz myvt h mvynvaalu jpcpspghapvu",
        "plaintext": "The ancient library holds secrets from a forgotten civilization",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a mysterious library, an encrypted message was found inscribed inside an ancient book. The message seems to be a classic case of a Caesar cipher. Here is the ciphertext: Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp. Can you unveil the secrets hidden within the text?\n\nSubmit your answer in the format: PCTF{YourDecryptedMessage}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp\"\nkey = 9\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 9,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the heart of a forgotten library, a dusty scroll was uncovered. The message on it was encrypted with the ancient art of Caesar cipher. Can you reveal its secrets? The ciphertext is as follows:\n\nGur dhvpx oebja sbk whzcf bire gur ynml qbt\n\nDecrypt this message and uncover the knowledge of the ancients.\n\nSubmit format: PCTF{decoded_message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Gur dhvpx oebja sbk whzcf bire gur ynml qbt\"\nkey = 13\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The quick brown fox jumps over the lazy dog}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gur dhvpx oebja sbk whzcf bire gur ynml qbt",
        "plaintext": "The quick brown fox jumps over the lazy dog",
        "key": 13,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an archaeological excavation, a mysterious scroll was discovered. The text appears to be encrypted using the ancient Caesar cipher technique. Here is the coded message:\n\nAol aylhzbyl pz opkklu bukly aol vsk vhr ayll ulhy aol ypcly ihur\n\nYour task is to decode this message and reveal the secrets it holds.\n\nSubmit format: PCTF{decrypted_message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Aol aylhzbyl pz opkklu bukly aol vsk vhr ayll ulhy aol ypcly ihur\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The treasure is hidden under the old oak tree near the river bank}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Aol aylhzbyl pz opkklu bukly aol vsk vhr ayll ulhy aol ypcly ihur",
        "plaintext": "The treasure is hidden under the old oak tree near the river bank",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library, a scroll has been unearthed containing mysterious encrypted text. It's believed to be hidden knowledge from a bygone era. The text is encoded using a simple Caesar cipher. Here is the ciphertext:\n\nKpzjvcly aol zljylaz vm aol hujplua dvysk\n\nCan you unravel the secrets within and reveal the hidden message?\n\nSubmit your answer in this format: PCTF{plaintext_string}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Kpzjvcly aol zljylaz vm aol hujplua dvysk\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Discover the secrets of the ancient world}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Kpzjvcly aol zljylaz vm aol hujplua dvysk",
        "plaintext": "Discover the secrets of the ancient world",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of a mysterious library, an ancient scroll was found, encrypted with a secretive Caesar cipher. The encoded message reads: Ruvdslknl pz wvdly huk zohypun ruvdslknl pz aol rlf av lclyfvul'z zbjjlzz. Brave adventurer, your task is to decrypt this message and uncover the wisdom it holds. Submit your answer in the format: PCTF{decrypted_message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Ruvdslknl pz wvdly huk zohypun ruvdslknl pz aol rlf av lclyfvul'z zbjjlzz\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Knowledge is power and sharing knowledge is the key to everyone's success}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Ruvdslknl pz wvdly huk zohypun ruvdslknl pz aol rlf av lclyfvul'z zbjjlzz",
        "plaintext": "Knowledge is power and sharing knowledge is the key to everyone's success",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the depths of a forgotten library, you stumble upon an encrypted scroll. The ancient text is written using a Caesar cipher, shrouded in mystery. Can you unlock its secrets?\nCiphertext:\nPiawzcp esp lyntpye cftyd ez fynzgpc esp dpncped espj rflco\nDecode the message and discover the story it guards.\nSubmit your answer in the format: PCTF{plain_text}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Piawzcp esp lyntpye cftyd ez fynzgpc esp dpncped espj rflco\"\nkey = 11\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Explore the ancient ruins to uncover the secrets they guard}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Piawzcp esp lyntpye cftyd ez fynzgpc esp dpncped espj rflco",
        "plaintext": "Explore the ancient ruins to uncover the secrets they guard",
        "key": 11,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a hidden chamber beneath an ancient library, archaeologists found a scroll with encrypted text dating back to Roman times. Can you decipher this Caesar cipher? The ciphertext reads: Wkh hdjoh kdv odqghg rq wkh prrq. Use your skills to uncover the truth hidden within.\n\nSubmit your answer in the format: DECRYPTED{your_plaintext_message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Wkh hdjoh kdv odqghg rq wkh prrq\"\nkey = 3\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The eagle has landed on the moon}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Wkh hdjoh kdv odqghg rq wkh prrq",
        "plaintext": "The eagle has landed on the moon",
        "key": 3,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During your exploration of the legendary Atlantis, you come across an ancient scroll written in a mysterious cipher. You suspect it to be a Caesar cipher. The encrypted message reads as follows: Gur napvrag yvoenel bs Nyrknaqevn ubyqf znal frpergf. Use your skills to decrypt the message and uncover the secrets it holds. \n\nSubmit format: PCTF{decrypted message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Gur napvrag yvoenel bs Nyrknaqevn ubyqf znal frpergf\"\nkey = 13\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{The ancient library of Alexandria holds many secrets}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Gur napvrag yvoenel bs Nyrknaqevn ubyqf znal frpergf",
        "plaintext": "The ancient library of Alexandria holds many secrets",
        "key": 13,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep within the mystic forest, an ancient scroll was discovered. Encoded with a forgotten language, it promises to reveal the location of a hidden treasure. The message is encrypted using the legendary Caesar cipher. The enigmatic ciphertext is as follows:\nTlla tl ha aol vsk vhr ayll avupnoa\nYour mission, should you choose to accept it, is to decipher this message and unlock the secrets it holds.\n\nSubmission format: PCTF{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Tlla tl ha aol vsk vhr ayll avupnoa\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Meet me at the old oak tree tonight}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Tlla tl ha aol vsk vhr ayll avupnoa",
        "plaintext": "Meet me at the old oak tree tonight",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Deep in the sands of time, an ancient scroll was uncovered, hidden within the ashes of a forgotten civilization. This scroll contains a message encoded with the notorious Caesar cipher, believed to hold the secret to eternal wisdom. The encoded message is as follows:\\nLewsvyhapvu pz aol lzzlujl vm aol obthu zwpypa\\nYour task is to decipher it, revealing the truths hidden by the sands.\\nSubmit your answer in the format: REVIVE{plaintext message}",
    "rationale": "def caesar_decrypt(ciphertext, key):\n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset - key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\n# 给定的密文和密钥\nciphertext = \"Lewsvyhapvu pz aol lzzlujl vm aol obthu zwpypa\"\nkey = 7\n\n# 解密\nplaintext = caesar_decrypt(ciphertext, key)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Exploration is the essence of the human spirit}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "Caesar",
      "change_detail": "In the Caesar cipher, each letter in the plaintext is shifted by a fixed number of positions down the alphabet. The key represents the shift value.",
      "synthesis_code": "def caesar_encrypt(plaintext, key):\n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted = (ord(char) - ascii_offset + key) % 26\n            result += chr(shifted + ascii_offset)\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\nkey = {key}\nciphertext = caesar_encrypt(plaintext, key)\nprint(ciphertext)",
      "compute": "1",
      "original_data": {
        "ciphertext": "Lewsvyhapvu pz aol lzzlujl vm aol obthu zwpypa",
        "plaintext": "Exploration is the essence of the human spirit",
        "key": 7,
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "After exploring an ancient library, you stumble upon a dusty scroll with cryptic symbols. The symbols are part of a simple substitution cipher puzzle. Can you uncover the message hidden within?\n\nCiphertext: HZN LNDTNH WNNHXIV XL HOWOTTOU BH IOOI\n\nDecode the message to reveal the hidden truth.\n\nSubmit your findings in this format: PCTF{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"HZN LNDTNH WNNHXIV XL HOWOTTOU BH IOOI\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"bjdmnpvzxakswioygtlhfcurqe\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET MEETING IS TOMORROW AT NOON}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "HZN LNDTNH WNNHXIV XL HOWOTTOU BH IOOI",
        "plaintext": "THE SECRET MEETING IS TOMORROW AT NOON",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "bjdmnpvzxakswioygtlhfcurqe",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old explorer's journal reveals a page containing a mysterious message encrypted with a Simple Substitution cipher. The handwritten text appears as UVK BJTRF AMOZQ COY EJXPI ODKM UVK HWGS LON. Your challenge is to uncover the true message concealed within this cryptic note. Crack the code and reveal the secrets. Submit your answer in the format: EXPEDITION{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"UVK BJTRF AMOZQ COY EJXPI ODKM UVK HWGS LON\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"warlkcnvtefhxqopbmiujdzysg\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "UVK BJTRF AMOZQ COY EJXPI ODKM UVK HWGS LON",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "warlkcnvtefhxqopbmiujdzysg",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a deep dive into the archives of an old cryptographer, you uncover a mysterious document encrypted with a simple substitution cipher. Can you decrypt the message and reveal the hidden sentence hidden within?\n\nCiphertext: CMB GSLPO QXEHV DEU RSIJY EKBX CMB NWTF ZEA\n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"CMB GSLPO QXEHV DEU RSIJY EKBX CMB NWTF ZEA\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"wqpzbdamlronivejgxycskhuft\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "CMB GSLPO QXEHV DEU RSIJY EKBX CMB NWTF ZEA",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "wqpzbdamlronivejgxycskhuft",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An encrypted communication from an ancient intelligence network was unearthed during a recent excavation. This message seems to hold vital information about covert operations. The encoded message reads: YKUJKH PIHKQQPEKIUK JKBCJH HMK KIKOZ MSY DKKI YBCHHKV IKSJ HMK JPLKJ\n\nYour mission, should you choose to accept it, is to decrypt this message and unveil the hidden secrets.\n\nSubmission format: FLAG{your_decrypted_message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"YKUJKH PIHKQQPEKIUK JKBCJH HMK KIKOZ MSY DKKI YBCHHKV IKSJ HMK JPLKJ\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"sduvkfempgnqoicbxjyhrlwtza\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SECRET INTELLIGENCE REPORT THE ENEMY HAS BEEN SPOTTED NEAR THE RIVER}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "YKUJKH PIHKQQPEKIUK JKBCJH HMK KIKOZ MSY DKKI YBCHHKV IKSJ HMK JPLKJ",
        "plaintext": "SECRET INTELLIGENCE REPORT THE ENEMY HAS BEEN SPOTTED NEAR THE RIVER",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "sduvkfempgnqoicbxjyhrlwtza",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Within the dusty sarcophagus lies a parchment bearing an encrypted message. Legend has it, the message reveals the location of a hidden treasure. The encryption appears to be a simple substitution cipher.\n\nThe cloaked riddle is as follows: MF ZF ZFAMGFY YNQO LZT UNDFR Z QGTTZKG YEZY TIGZJT NU YBGZTDBG\n\nUse your cunning to decode this ancient script and unveil the location marked for fortune.\n\nSubmission format: PCTF{decrypted message in uppercase letters}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"MF ZF ZFAMGFY YNQO LZT UNDFR Z QGTTZKG YEZY TIGZJT NU YBGZTDBG\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"zoargukemhjsqfnicbtydvlpwx\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{IN AN ANCIENT TOMB WAS FOUND A MESSAGE THAT SPEAKS OF TREASURE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "MF ZF ZFAMGFY YNQO LZT UNDFR Z QGTTZKG YEZY TIGZJT NU YBGZTDBG",
        "plaintext": "IN AN ANCIENT TOMB WAS FOUND A MESSAGE THAT SPEAKS OF TREASURE",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "zoargukemhjsqfnicbtydvlpwx",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During a renovation of an ancient library, a curious scroll was discovered, encrypted with a simple substitution cipher.\nThe ciphertext reads: EML TSAOP CKJBH RJV GSQID JULK EML ZWXN FJY\n\nYour task is to decode this enigmatic message and uncover the words hidden within.\n\nSubmit your answer in this format: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"EML TSAOP CKJBH RJV GSQID JULK EML ZWXN FJY\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"wcoflrymagpzqhjitkdesubvnx\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "EML TSAOP CKJBH RJV GSQID JULK EML ZWXN FJY",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "wcoflrymagpzqhjitkdesubvnx",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the archives of a forgotten library, you stumble upon a dusty manuscript. It contains a message encrypted using a simple substitution cipher. The encoded message might hold the key to a long-lost treasure. The cipher text reads: ZVLHBECVOHUL WA BUP OVB EG APZNVP ZEIINXWZOBWEX\n\nCan you crack the code and reveal the hidden message?\n\nSubmit your answer in the format: PCTF{decrypted_message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"ZVLHBECVOHUL WA BUP OVB EG APZNVP ZEIINXWZOBWEX\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"oyzdpgcuwtqkixehrvabnjsmlf\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{CRYPTOGRAPHY IS THE ART OF SECURE COMMUNICATION}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZVLHBECVOHUL WA BUP OVB EG APZNVP ZEIINXWZOBWEX",
        "plaintext": "CRYPTOGRAPHY IS THE ART OF SECURE COMMUNICATION",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "oyzdpgcuwtqkixehrvabnjsmlf",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an old dusty library, you find a note from a forgotten cryptographer. The note is written in a simple substitution cipher, where each letter is uniquely replaced with another. Unfortunately, no further guidance is provided except for the ciphertext itself. As you inspect the note, the following message stands out: ZQA XDNFR BWMJS PMG KDTEY MHAW ZQA ULIC OMV\n\nDecrypt the message to reveal the hidden information.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"ZQA XDNFR BWMJS PMG KDTEY MHAW ZQA ULIC OMV\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"lbfoapvqnkrutsmexwyzdhjgci\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZQA XDNFR BWMJS PMG KDTEY MHAW ZQA ULIC OMV",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "lbfoapvqnkrutsmexwyzdhjgci",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "You have stumbled upon an old detective's journal which describes a secret rendezvous in code. The message uses a classic simple substitution cipher. The encoded message is:\n\nGDW JWENWG QWWGRTH SRZZ GLXW CZLEW LG GDW UZF ELAW UT GYWJFLM\n\nYour mission is to crack the cipher and reveal the details of the meeting.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"GDW JWENWG QWWGRTH SRZZ GLXW CZLEW LG GDW UZF ELAW UT GYWJFLM\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"lkefwahdrpxzqtucvnjgyisomb\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET MEETING WILL TAKE PLACE AT THE OLD CAFE ON TUESDAY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "GDW JWENWG QWWGRTH SRZZ GLXW CZLEW LG GDW UZF ELAW UT GYWJFLM",
        "plaintext": "THE SECRET MEETING WILL TAKE PLACE AT THE OLD CAFE ON TUESDAY",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "lkefwahdrpxzqtucvnjgyisomb",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a vault hidden beneath the ancient library, a cryptic scroll was found, encrypted with a simple substitution cipher. The message is believed to hold the secret to a lost artifact. Can you decipher the message and uncover the truth? The encrypted message is as follows: ZTL EQPJH IFWMG CWB YQUNR WXLF ZTL OSDV AWK \n\nYour mission is to decrypt this enigmatic message and reveal the hidden text. \n\nSubmit your answer in the format: PCTF{PLAINTEXTMESSAGE}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"ZTL EQPJH IFWMG CWB YQUNR WXLF ZTL OSDV AWK\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"sijalcktpyhougwnefrzqxmbvd\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "ZTL EQPJH IFWMG CWB YQUNR WXLF ZTL OSDV AWK",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "sijalcktpyhougwnefrzqxmbvd",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old map of treasure locations contains a cryptic message written in a Simple Substitution cipher. Unlock the secrets hidden by the ancients by deciphering the code provided below: WTL JZARF GNUHI CUO VZYPD UBLN WTL MEKS QUX\n\nCrack the code to reveal the treasure's whereabouts.\n\nSubmit the flag in the format: PCTF{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"WTL JZARF GNUHI CUO VZYPD UBLN WTL MEKS QUX\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"egrqlcxtavfmyiupjndwzbhosk\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "WTL JZARF GNUHI CUO VZYPD UBLN WTL MEKS QUX",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "egrqlcxtavfmyiupjndwzbhosk",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a dusty corner of an ancient library, a mysterious parchment was found. It was covered in runes that resembled a substitution cipher. Enterprising cryptanalysts determined that it reads as follows: LDQ AQENQL RPEILZPY ZA DZGGQY ZY LDQ PRG RZWNINX\n\nYour mission is to decipher these runes and retrieve the hidden message that lies within.\n\nSubmit format: PCTF{your plaintext message here }",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"LDQ AQENQL RPEILZPY ZA DZGGQY ZY LDQ PRG RZWNINX\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"iwegqbudzckrmypstnalvohjxf\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE SECRET LOCATION IS HIDDEN IN THE OLD LIBRARY}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "LDQ AQENQL RPEILZPY ZA DZGGQY ZY LDQ PRG RZWNINX",
        "plaintext": "THE SECRET LOCATION IS HIDDEN IN THE OLD LIBRARY",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "iwegqbudzckrmypstnalvohjxf",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "During an excavation in an ancient library, you discover a scroll with encrypted writings. Scholars believe it holds the secrets of a forgotten civilization. The only problem? It's encrypted using a substitution cipher. Can you help decrypt this mysterious message? Here is the ciphertext: JTG CRZSL BMYDV NYI FRQEX YPGM JTG AUWK OYH \n\nDecipher the message and reveal its secrets.\n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"JTG CRZSL BMYDV NYI FRQEX YPGM JTG AUWK OYH\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"ubsognhtzflaqvyecmxjrpdikw\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "JTG CRZSL BMYDV NYI FRQEX YPGM JTG AUWK OYH",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "ubsognhtzflaqvyecmxjrpdikw",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of a forgotten library, an ancient scroll was discovered. It holds a message encrypted with a simple substitution cipher, believed to be used by a secret society. The ciphertext is as follows: SJH QFXCD TZEIG BEW LFUYM ERHZ SJH OAPN VEK \n\nCan you decrypt this ciphertext and uncover the hidden message? \n\nSubmit your answer in the format: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"SJH QFXCD TZEIG BEW LFUYM ERHZ SJH OAPN VEK\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"atcvhbkjxldougeyqzmsfriwnp\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "SJH QFXCD TZEIG BEW LFUYM ERHZ SJH OAPN VEK",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "atcvhbkjxldougeyqzmsfriwnp",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An ancient cypher manuscript has surfaced, containing a message encrypted with a simple substitution cipher. Can you crack the code and reveal the hidden secrets?\n\nEncrypted Message: JUD PXAWV TBLMO HLN FXEIZ LSDB JUD RYCG QLK\n\nUnravel the mystery and submit the decrypted message in the format: PCTF{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"JUD PXAWV TBLMO HLN FXEIZ LSDB JUD RYCG QLK\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"ytwqdhkuafvreolipbzjxsmngc\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "JUD PXAWV TBLMO HLN FXEIZ LSDB JUD RYCG QLK",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "ytwqdhkuafvreolipbzjxsmngc",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the dusty archives of the ancient mathematician's library, a mysterious parchment was discovered. It appeared to be encrypted using a simple substitution cipher. Your task is to decipher it. The encrypted message reads: YGV RBWTQ ECFXP SFM KBLZU FDVC YGV ONAJ IFH \n\nCan you unlock its secrets and reveal what lies beneath?\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"YGV RBWTQ ECFXP SFM KBLZU FDVC YGV ONAJ IFH\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"netivshgwkqolpfzrcuybdxmja\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "YGV RBWTQ ECFXP SFM KBLZU FDVC YGV ONAJ IFH",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "netivshgwkqolpfzrcuybdxmja",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "An old explorer left a message encoded with a simple substitution cipher. Can you uncover the secret of his hidden treasure? Here is the encrypted message: OFJ OWJZCXWJ BC FBIIJY XYIJW OFJ TVI TZN OWJJ\n\nDecrypt the message to reveal the hidden information.\n\nSubmit your answer in the format: PCTF{plaintext}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"OFJ OWJZCXWJ BC FBIIJY XYIJW OFJ TVI TZN OWJJ\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"zerijkhfbqnvpytlswcoxmagdu\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "OFJ OWJZCXWJ BC FBIIJY XYIJW OFJ TVI TZN OWJJ",
        "plaintext": "THE TREASURE IS HIDDEN UNDER THE OLD OAK TREE",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "zerijkhfbqnvpytlswcoxmagdu",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In an ancient library lost between the annals of history, explorers discovered a scroll encrypted with a classic Simple Substitution cipher. The coded message turned out to be quite the brain teaser. Decipher the ancient text to uncover its mystery. The ciphertext is displayed below: RVE AJYMN XDILT ZIC FJWOB IUED RVE KQGS HIP\n\nWill you be the one to crack this code and reveal the secret message hidden within?\n\nSubmit your answer as: PCTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"RVE AJYMN XDILT ZIC FJWOB IUED RVE KQGS HIP\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"qxmhezpvyfnkwtioadbrjulcsg\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "RVE AJYMN XDILT ZIC FJWOB IUED RVE KQGS HIP",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "qxmhezpvyfnkwtioadbrjulcsg",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In the deep archives of the library, you stumble upon an old manuscript encrypted with a simple substitution cipher. The message is said to hold secrets of timeless knowledge.\nThe ciphertext is: IGT UEPZJM AX AP EY Z NVZYYEN IZVT AX XJETCMYGEQ ZCM FZOEN\n\nDecrypt this message to reveal the hidden wisdom.\n\nSubmit your answer in the format: PCTF{plaintext_message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"IGT UEPZJM AX AP EY Z NVZYYEN IZVT AX XJETCMYGEQ ZCM FZOEN\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"zwnmtxogeshvfcaqdjyilkubrp\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE WIZARD OF OZ IS A CLASSIC TALE OF FRIENDSHIP AND MAGIC}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "IGT UEPZJM AX AP EY Z NVZYYEN IZVT AX XJETCMYGEQ ZCM FZOEN",
        "plaintext": "THE WIZARD OF OZ IS A CLASSIC TALE OF FRIENDSHIP AND MAGIC",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "zwnmtxogeshvfcaqdjyilkubrp",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "In a mysterious cave, hidden by an ancient tribe, explorers found an artifact with encrypted symbols. The symbols are believed to be encoded using a simple substitution cipher, a cipher older than memory itself. The encrypted message reads: QIO YBXSZ KTCVL FCP NBHDG CEOT QIO WRUA JCM\n\nDecipher this message to uncover the secret it guards.\n\nSubmission format: CTF{plaintext message}",
    "rationale": "def simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet):\n    # Create mapping from cipher alphabet to plain alphabet\n    substitution_map = dict(zip(cipher_alphabet.upper(), plain_alphabet.upper()))\n    \n    result = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\n# 给定的密文和字母表\nciphertext = \"QIO YBXSZ KTCVL FCP NBHDG CEOT QIO WRUA JCM\"\nplain_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\ncipher_alphabet = \"rksjofmixnzwhlcdytgqbevpau\"\n\n# 解密\nplaintext = simple_substitution_decrypt(ciphertext, plain_alphabet, cipher_alphabet)\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG}",
    "metadata": {
      "class1": "Classical_Cryptography",
      "class2": "SimpleSubstitution",
      "change_detail": "In the Simple Substitution cipher, each letter in the plaintext is replaced with a different letter according to a fixed substitution mapping. Unlike Caesar cipher, the substitution can be any permutation of the alphabet.",
      "synthesis_code": "def simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet):\n    # Create mapping from plain alphabet to cipher alphabet\n    substitution_map = dict(zip(plain_alphabet.upper(), cipher_alphabet.upper()))\n    \n    result = \"\"\n    for char in plaintext:\n        if char.isalpha():\n            # Convert to uppercase for substitution\n            char_upper = char.upper()\n            if char_upper in substitution_map:\n                result += substitution_map[char_upper]\n        else:\n            result += char\n    return result\n\nplaintext = \"{plaintext}\"\n# Using standard alphabet and cipher alphabet for substitution\nplain_alphabet = \"{plain_alphabet}\"\ncipher_alphabet = \"{cipher_alphabet}\"\nciphertext = simple_substitution_encrypt(plaintext, plain_alphabet, cipher_alphabet)\nprint(ciphertext)",
      "compute": "2",
      "original_data": {
        "ciphertext": "QIO YBXSZ KTCVL FCP NBHDG CEOT QIO WRUA JCM",
        "plaintext": "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
        "plain_alphabet": "abcdefghijklmnopqrstuvwxyz",
        "cipher_alphabet": "rksjofmixnzwhlcdytgqbevpau",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [8589934592, 495168206759], and the following public key:\np = \"19946195816033\", g = \"2\", x = \"7438157187561\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 19946195816033\ng = 2\nh = pow(g, 7438157187561, p)\nciphertext = [8589934592, 495168206759]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{9366}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 19946195816033,
        "g": 2,
        "x": 7438157187561,
        "h": 16619307045486,
        "r": 33,
        "plaintext": "9366",
        "ciphertext": "[8589934592, 495168206759]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [2147483648, 9773338715807], and the following public key:\np = \"31093800382291\", g = \"2\", x = \"8688028675764\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 31093800382291\ng = 2\nh = pow(g, 8688028675764, p)\nciphertext = [2147483648, 9773338715807]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{9702}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 31093800382291,
        "g": 2,
        "x": 8688028675764,
        "h": 10355661681388,
        "r": 31,
        "plaintext": "9702",
        "ciphertext": "[2147483648, 9773338715807]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [26122207883653, 7239757206844], and the following public key:\np = \"31326735055153\", g = \"2\", x = \"4751776596937\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 31326735055153\ng = 2\nh = pow(g, 4751776596937, p)\nciphertext = [26122207883653, 7239757206844]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{3832}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 31326735055153,
        "g": 2,
        "x": 4751776596937,
        "h": 15644632654127,
        "r": 92,
        "plaintext": "3832",
        "ciphertext": "[26122207883653, 7239757206844]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [16134871590158, 2444712609091], and the following public key:\np = \"26478688606003\", g = \"2\", x = \"10021950183736\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 26478688606003\ng = 2\nh = pow(g, 10021950183736, p)\nciphertext = [16134871590158, 2444712609091]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{9259}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 26478688606003,
        "g": 2,
        "x": 10021950183736,
        "h": 19443385319728,
        "r": 89,
        "plaintext": "9259",
        "ciphertext": "[16134871590158, 2444712609091]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [12622503041858, 10775456635987], and the following public key:\np = \"19723608074207\", g = \"2\", x = \"15103210000812\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 19723608074207\ng = 2\nh = pow(g, 15103210000812, p)\nciphertext = [12622503041858, 10775456635987]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{7143}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 19723608074207,
        "g": 2,
        "x": 15103210000812,
        "h": 16628059506501,
        "r": 89,
        "plaintext": "7143",
        "ciphertext": "[12622503041858, 10775456635987]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [12564348339055, 7810181966068], and the following public key:\np = \"22620023749777\", g = \"2\", x = \"12243857189570\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 22620023749777\ng = 2\nh = pow(g, 12243857189570, p)\nciphertext = [12564348339055, 7810181966068]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{5131}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 22620023749777,
        "g": 2,
        "x": 12243857189570,
        "h": 13746296843946,
        "r": 45,
        "plaintext": "5131",
        "ciphertext": "[12564348339055, 7810181966068]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [268435456, 3144742586494], and the following public key:\np = \"28128920280737\", g = \"2\", x = \"3402698113532\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 28128920280737\ng = 2\nh = pow(g, 3402698113532, p)\nciphertext = [268435456, 3144742586494]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{8119}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 28128920280737,
        "g": 2,
        "x": 3402698113532,
        "h": 12733643409600,
        "r": 28,
        "plaintext": "8119",
        "ciphertext": "[268435456, 3144742586494]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [8192, 4999247301388], and the following public key:\np = \"33803027357867\", g = \"2\", x = \"11271747733751\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 33803027357867\ng = 2\nh = pow(g, 11271747733751, p)\nciphertext = [8192, 4999247301388]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{3841}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 33803027357867,
        "g": 2,
        "x": 11271747733751,
        "h": 18880951966107,
        "r": 13,
        "plaintext": "3841",
        "ciphertext": "[8192, 4999247301388]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [20661100423963, 836343476620], and the following public key:\np = \"28028238453079\", g = \"2\", x = \"26975444170055\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 28028238453079\ng = 2\nh = pow(g, 26975444170055, p)\nciphertext = [20661100423963, 836343476620]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{7265}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 28028238453079,
        "g": 2,
        "x": 26975444170055,
        "h": 11515653370534,
        "r": 74,
        "plaintext": "7265",
        "ciphertext": "[20661100423963, 836343476620]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG_ELGAMAL: [17179869184, 8626436276413], and the following public key:\np = \"28153450274239\", g = \"2\", x = \"28014325400749\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Util.number import *\nfrom sympy import discrete_log\n\np = 28153450274239\ng = 2\nh = pow(g, 28014325400749, p)\nciphertext = [17179869184, 8626436276413]\nc1 = int(ciphertext[0])\nc2 = int(ciphertext[1])\n\n# Step1: Recover r from c1 = g^r mod p\nr = discrete_log(p, c1, g)\n\n# Step2: Compute s = h^r mod p\ns = pow(h, r, p)\n\ns_inv = inverse(s, p)\nm = (c2 * s_inv) % p\nprint(str(m))\n",
    "final_answer": "PCTF{6247}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ELGAMAL",
      "change_detail": "Use p, g, private key x to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\n# Private key\nx = {x}\nplaintext = {plaintext}\nm = int(plaintext)\nr = {r}\nh = pow(g, x, p)\nc1 = pow(g, r, p)\nc2 = (m * pow(h, r, p)) % p\nciphertext = str([c1, c2])\nprint(ciphertext)\n",
      "original_data": {
        "p": 28153450274239,
        "g": 2,
        "x": 28014325400749,
        "h": 3552225764661,
        "r": 34,
        "plaintext": "6247",
        "ciphertext": "[17179869184, 8626436276413]",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((244, 0), (251, 221)), ((20, 230), (27, 51)), ((27, 51), (20, 230)), ((52, 203), (59, 25)), ((123, 87), (116, 140)), ((36, 210), (43, 15)), ((212, 35), (219, 246)), ((132, 123), (139, 160)), ((244, 0), (251, 221)), ((187, 144), (180, 75))]\nexpected_diff = 13\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{07}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 7,
        "expected_diff": 13
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((221, 221), (210, 113)), ((125, 126), (114, 210)), ((221, 221), (210, 113)), ((231, 215), (232, 123)), ((247, 192), (248, 100)), ((183, 142), (184, 34)), ((231, 215), (232, 123)), ((45, 39), (34, 139)), ((55, 1), (56, 173)), ((247, 192), (248, 100))]\nexpected_diff = 10\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{13}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 19,
        "expected_diff": 10
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((58, 221), (53, 177)), ((10, 231), (5, 135)), ((101, 232), (106, 136)), ((101, 232), (106, 136)), ((245, 123), (250, 27)), ((229, 104), (234, 14)), ((10, 231), (5, 135)), ((186, 82), (181, 49)), ((229, 104), (234, 14)), ((42, 203), (37, 171))]\nexpected_diff = 6\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{02}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 2,
        "expected_diff": 6
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((181, 205), (186, 41)), ((130, 184), (141, 90)), ((218, 70), (213, 172)), ((202, 93), (197, 191)), ((13, 208), (2, 61)), ((197, 191), (202, 93)), ((194, 244), (205, 17)), ((98, 85), (109, 183)), ((66, 123), (77, 157)), ((21, 99), (26, 143))]\nexpected_diff = 14\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{12}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 18,
        "expected_diff": 14
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((131, 56), (140, 139)), ((83, 236), (92, 81)), ((12, 7), (3, 177)), ((108, 99), (99, 220)), ((156, 148), (147, 43)), ((124, 122), (115, 195)), ((211, 108), (220, 211)), ((51, 132), (60, 55)), ((76, 78), (67, 255)), ((188, 190), (179, 8))]\nexpected_diff = 11\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{0C}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 12,
        "expected_diff": 11
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((246, 40), (249, 100)), ((153, 13), (150, 71)), ((246, 40), (249, 100)), ((233, 119), (230, 50)), ((166, 120), (169, 61)), ((57, 167), (54, 235)), ((105, 248), (102, 178)), ((70, 159), (73, 222)), ((54, 235), (57, 167)), ((198, 23), (201, 81))]\nexpected_diff = 4\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{02}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 2,
        "expected_diff": 4
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((109, 69), (98, 74)), ((34, 13), (45, 2)), ((50, 20), (61, 27)), ((205, 234), (194, 229)), ((205, 234), (194, 229)), ((45, 2), (34, 13)), ((226, 198), (237, 201)), ((34, 13), (45, 2)), ((162, 141), (173, 130)), ((194, 229), (205, 234))]\nexpected_diff = 0\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{0A}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 10,
        "expected_diff": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((39, 165), (40, 197)), ((135, 9), (136, 105)), ((152, 112), (151, 19)), ((55, 190), (56, 217)), ((39, 165), (40, 197)), ((7, 137), (8, 233)), ((103, 230), (104, 134)), ((8, 233), (7, 137)), ((168, 69), (167, 35)), ((24, 255), (23, 147))]\nexpected_diff = 6\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 0,
        "expected_diff": 6
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((108, 23), (99, 54)), ((76, 57), (67, 24)), ((252, 133), (243, 166)), ((220, 169), (211, 138)), ((44, 82), (35, 112)), ((108, 23), (99, 54)), ((227, 176), (236, 150)), ((172, 220), (163, 246)), ((35, 112), (44, 82)), ((163, 246), (172, 220))]\nexpected_diff = 2\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{13}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 19,
        "expected_diff": 2
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice used a simplified 2-round DES cipher. You're given several plaintext-ciphertext pairs:\n- Each pair consists of `(P1, C1)` and `(P2, C2)` such that `P1 ^ P2 = 0x0F`\n- The cipher uses a single 6-bit subkey (S-box input key) in both rounds.\n- Use **differential cryptanalysis** to recover the 6-bit key used in S-box input.\n\nOutput format: `PCTF{XX}` where `XX` is the 6-bit key in hex.",
    "rationale": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = [((163, 152), (172, 22)), ((243, 200), (252, 75)), ((19, 38), (28, 166)), ((108, 210), (99, 83)), ((163, 152), (172, 22)), ((195, 240), (204, 121)), ((51, 10), (60, 138)), ((124, 199), (115, 68)), ((92, 224), (83, 99)), ((204, 121), (195, 240))]\nexpected_diff = 8\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
    "final_answer": "PCTF{1A}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DES_Differential",
      "change_detail": "Recover 6-bit S-box subkey of DES using differential cryptanalysis (statistical).",
      "synthesis_code": "def expand(r4):\n    return ((r4 & 1) << 5) | ((r4 & 0b1110) >> 1) << 1 | ((r4 >> 3) & 1)\n\ndef sbox_lookup(six_bits):\n    SBOX = [\n        [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n        [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n        [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n        [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    ]\n    row = ((six_bits >> 5) & 1) << 1 | (six_bits & 1)\n    col = (six_bits >> 1) & 0b1111\n    return SBOX[row][col]\n\ndef feistel(r, subkey):\n    e = expand(r)\n    return sbox_lookup(e ^ subkey)\n\npairs = __PAIRS__\nexpected_diff = __EXPECTED_DIFF__\n\nfor k in range(64):\n    match_count = 0\n    for (p1, c1), (p2, c2) in pairs:\n        l0_1, r0_1 = (p1 >> 4) & 0xF, p1 & 0xF\n        l0_2, r0_2 = (p2 >> 4) & 0xF, p2 & 0xF\n\n        f1 = feistel(r0_1, k)\n        f2 = feistel(r0_2, k)\n\n        r1_1 = l0_1 ^ f1\n        r1_2 = l0_2 ^ f2\n\n        if r1_1 ^ r1_2 == expected_diff:\n            match_count += 1\n\n    if match_count >= int(0.75 * len(pairs)):\n        print(f\"PCTF{{{k:02X}}}\")\n        break\n",
      "original_data": {
        "subkey": 26,
        "expected_diff": 8
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x6eb4faa103bc82 and the public key:\nN=123968267750098253 e=679\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 123968267750098253\ne = 679\nc = 0x6eb4faa103bc82\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{fire}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x6eb4faa103bc82",
        "p": 1843522033,
        "q": 67245341,
        "N": 123968267750098253,
        "e": 679,
        "plaintext": "fire",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x51c2aac7f9693c and the public key:\nN=49320717209019433 e=51\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 49320717209019433\ne = 51\nc = 0x51c2aac7f9693c\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{tree}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x51c2aac7f9693c",
        "p": 36310049,
        "q": 1358321417,
        "N": 49320717209019433,
        "e": 51,
        "plaintext": "tree",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x1264830a93c75e and the public key:\nN=112666460616921131 e=86806435615572787\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 112666460616921131\ne = 86806435615572787\nc = 0x1264830a93c75e\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{blue}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x1264830a93c75e",
        "p": 3880729241,
        "q": 29032291,
        "N": 112666460616921131,
        "e": 86806435615572787,
        "plaintext": "blue",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0xbc3404a1c308f2 and the public key:\nN=84601523487270743 e=37157918974962917\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 84601523487270743\ne = 37157918974962917\nc = 0xbc3404a1c308f2\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{love}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xbc3404a1c308f2",
        "p": 95045231,
        "q": 890118553,
        "N": 84601523487270743,
        "e": 37157918974962917,
        "plaintext": "love",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x17b69aa6a4468d6 and the public key:\nN=115303917943410143 e=2047\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 115303917943410143\ne = 2047\nc = 0x17b69aa6a4468d6\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{good}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x17b69aa6a4468d6",
        "p": 71123149,
        "q": 1621186907,
        "N": 115303917943410143,
        "e": 2047,
        "plaintext": "good",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0xdac8fb6bced934 and the public key:\nN=64591566229211513 e=65537\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 64591566229211513\ne = 65537\nc = 0xdac8fb6bced934\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{cool}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xdac8fb6bced934",
        "p": 972154949,
        "q": 66441637,
        "N": 64591566229211513,
        "e": 65537,
        "plaintext": "cool",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x5603ee0de685fb and the public key:\nN=25626138853815911 e=95\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 25626138853815911\ne = 95\nc = 0x5603ee0de685fb\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{moon}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x5603ee0de685fb",
        "p": 1470501437,
        "q": 17426803,
        "N": 25626138853815911,
        "e": 95,
        "plaintext": "moon",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0xdb1fbc649a5761 and the public key:\nN=233773082310593159 e=457\nPlease decrypt the message, and submit the result as ASCII characters.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 233773082310593159\ne = 457\nc = 0xdb1fbc649a5761\n\ndef factorize_N(N):\n    for i in range(2, 10**8):  # The search range can be adjusted based on specific circumstances\n        if gmpy2.gcd(N, i) != 1 and N % i == 0:\n            p = i\n            q = N // i\n            return p, q\n    return None, None\n\np, q = factorize_N(N)\nif p is None or q is None:\n    print(\"Factorization failed\")\nelse:\n    # Calculate φ(N)\n    phi_n = (p - 1) * (q - 1)\n    \n    # Calculate the private exponent d\n    d = gmpy2.invert(e, phi_n)\n    \n    # RSA Decryption\n    m = gmpy2.powmod(c, d, N)\n    \n    # Convert to ASCII\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{hope}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Common_Factor",
      "change_detail": "If N shares a common factor with e, one can recover the private key easily.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xdb1fbc649a5761",
        "p": 73305931,
        "q": 3189006389,
        "N": 233773082310593159,
        "e": 457,
        "plaintext": "hope",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 6bfb6342d01594c191d39e8e0e410a15b4f2fd05a8266b16bb5cd5430b52a918, and the following public key:\nkey = \"gbAbUSUsiAsfMK73\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"gbAbUSUsiAsfMK73\"\nciphertext = binascii.unhexlify(\"6bfb6342d01594c191d39e8e0e410a15b4f2fd05a8266b16bb5cd5430b52a918\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{gjHuc7IRSKNsGQX8}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "gjHuc7IRSKNsGQX8",
        "ciphertext": "6bfb6342d01594c191d39e8e0e410a15b4f2fd05a8266b16bb5cd5430b52a918",
        "key": "gbAbUSUsiAsfMK73",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 82d828adb3e50a095fc9ae2b16a8804c, and the following public key:\nkey = \"sQR6fkGAZsf1y4X4\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"sQR6fkGAZsf1y4X4\"\nciphertext = binascii.unhexlify(\"82d828adb3e50a095fc9ae2b16a8804c\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qz7FmOUNt0}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "qz7FmOUNt0",
        "ciphertext": "82d828adb3e50a095fc9ae2b16a8804c",
        "key": "sQR6fkGAZsf1y4X4",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 2c7381d226e75a5bff8e8aa22e904d23, and the following public key:\nkey = \"AyhoavSzJOoU31CL\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"AyhoavSzJOoU31CL\"\nciphertext = binascii.unhexlify(\"2c7381d226e75a5bff8e8aa22e904d23\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{Q4QdithkqB}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "Q4QdithkqB",
        "ciphertext": "2c7381d226e75a5bff8e8aa22e904d23",
        "key": "AyhoavSzJOoU31CL",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 38ee0a516b42f204a693c0ba4e1768292c54532c9133c1a25d6422cd080daff9, and the following public key:\nkey = \"J7l0AndsSwqpuwTN\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"J7l0AndsSwqpuwTN\"\nciphertext = binascii.unhexlify(\"38ee0a516b42f204a693c0ba4e1768292c54532c9133c1a25d6422cd080daff9\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{n3klbgF4ydwZDho6erHIUrjRKR}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "n3klbgF4ydwZDho6erHIUrjRKR",
        "ciphertext": "38ee0a516b42f204a693c0ba4e1768292c54532c9133c1a25d6422cd080daff9",
        "key": "J7l0AndsSwqpuwTN",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: e6bef38f133ddc20ba6ae61c4eed48e36e21a2cb835440fa1c0dae5d055605ad, and the following public key:\nkey = \"sh5WDB0DREKf6Ss4\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"sh5WDB0DREKf6Ss4\"\nciphertext = binascii.unhexlify(\"e6bef38f133ddc20ba6ae61c4eed48e36e21a2cb835440fa1c0dae5d055605ad\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{yDHal4Upl8oeG9Kb}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "yDHal4Upl8oeG9Kb",
        "ciphertext": "e6bef38f133ddc20ba6ae61c4eed48e36e21a2cb835440fa1c0dae5d055605ad",
        "key": "sh5WDB0DREKf6Ss4",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 79da263927d27e702a63a4f8528ed5b7cb07f0c69a48c793e4b1bbe5d3d5a35e, and the following public key:\nkey = \"1CRWc6vs1WYQHHzk\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"1CRWc6vs1WYQHHzk\"\nciphertext = binascii.unhexlify(\"79da263927d27e702a63a4f8528ed5b7cb07f0c69a48c793e4b1bbe5d3d5a35e\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{6CvhBWp0sskegytm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "6CvhBWp0sskegytm",
        "ciphertext": "79da263927d27e702a63a4f8528ed5b7cb07f0c69a48c793e4b1bbe5d3d5a35e",
        "key": "1CRWc6vs1WYQHHzk",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 1325a0bc24cbe0db7819a434cb8f0f2edefdab92f22a96dcdd8b4aef769b13de, and the following public key:\nkey = \"cfDzjUIY8RWO93iG\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"cfDzjUIY8RWO93iG\"\nciphertext = binascii.unhexlify(\"1325a0bc24cbe0db7819a434cb8f0f2edefdab92f22a96dcdd8b4aef769b13de\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{knQ38EeG6scWJtD81}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "knQ38EeG6scWJtD81",
        "ciphertext": "1325a0bc24cbe0db7819a434cb8f0f2edefdab92f22a96dcdd8b4aef769b13de",
        "key": "cfDzjUIY8RWO93iG",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: d309aac181c869c8decb98f8f4d1d0ebd575e594ff7a28f2e7f2ef86d732e40f, and the following public key:\nkey = \"McwV0fUadykdS2Qf\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"McwV0fUadykdS2Qf\"\nciphertext = binascii.unhexlify(\"d309aac181c869c8decb98f8f4d1d0ebd575e594ff7a28f2e7f2ef86d732e40f\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ZsMdwCXWsUSd2ns79}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "ZsMdwCXWsUSd2ns79",
        "ciphertext": "d309aac181c869c8decb98f8f4d1d0ebd575e594ff7a28f2e7f2ef86d732e40f",
        "key": "McwV0fUadykdS2Qf",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 9c1662c90e7a90a8a08f1c9710069050289d4bacc43f8f2c70bf91a0a9d061de, and the following public key:\nkey = \"ShHUMgzZpnUXDnRC\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"ShHUMgzZpnUXDnRC\"\nciphertext = binascii.unhexlify(\"9c1662c90e7a90a8a08f1c9710069050289d4bacc43f8f2c70bf91a0a9d061de\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{tCOTyFr50njg918aG7}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "tCOTyFr50njg918aG7",
        "ciphertext": "9c1662c90e7a90a8a08f1c9710069050289d4bacc43f8f2c70bf91a0a9d061de",
        "key": "ShHUMgzZpnUXDnRC",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: c2cb4af8bc0c36ed6ef4b15d884a5a48, and the following public key:\nkey = \"YkVb2ZZ2WFEraZaj\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport binascii\n\nkey = b\"YkVb2ZZ2WFEraZaj\"\nciphertext = binascii.unhexlify(\"c2cb4af8bc0c36ed6ef4b15d884a5a48\")\n\n# ECB decrypt\ncipher = AES.new(key, AES.MODE_ECB)\npadded_plaintext = cipher.decrypt(ciphertext)\n\n# Remove padding\nplaintext = unpad(padded_plaintext, AES.block_size).decode()\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{SX9DQoic19XQ}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_ECB",
      "change_detail": "Use key to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport binascii\n\nkey = b\"{key}\"  # 16-byte AES key\nplaintext = b\"{plaintext}\"  # Plaintext to be encrypted\n\n# Padding to 16-byte boundary\npadded = pad(plaintext, AES.block_size)\n\n# ECB encryption\ncipher = AES.new(key, AES.MODE_ECB)\nciphertext = cipher.encrypt(padded)\nprint(binascii.hexlify(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "SX9DQoic19XQ",
        "ciphertext": "c2cb4af8bc0c36ed6ef4b15d884a5a48",
        "key": "YkVb2ZZ2WFEraZaj",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[89, 75, 20, 6, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [70, 75, 20, 25, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [77, 75, 20, 18, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [65, 75, 20, 30, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [200, 75, 20, 151, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [81, 75, 20, 14, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [85, 75, 20, 10, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [255, 75, 20, 160, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [10, 75, 20, 85, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [59, 75, 20, 100, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [93, 75, 20, 2, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [17, 75, 20, 78, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [196, 75, 20, 155, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [237, 75, 20, 178, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [145, 75, 20, 206, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [76, 75, 20, 19, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [240, 75, 20, 175, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [184, 75, 20, 231, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [243, 75, 20, 172, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [71, 75, 20, 24, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [192, 75, 20, 159, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [99, 75, 20, 60, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [125, 75, 20, 34, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [202, 75, 20, 149, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [151, 75, 20, 200, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [238, 75, 20, 177, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [152, 75, 20, 199, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [149, 75, 20, 202, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [166, 75, 20, 249, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [158, 75, 20, 193, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [72, 75, 20, 23, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [250, 75, 20, 165, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [141, 75, 20, 210, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [199, 75, 20, 152, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [169, 75, 20, 246, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [28, 75, 20, 67, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [12, 75, 20, 83, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [5, 75, 20, 90, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [205, 75, 20, 146, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [246, 75, 20, 169, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [14, 75, 20, 81, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [159, 75, 20, 192, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [223, 75, 20, 128, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [203, 75, 20, 148, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [75, 75, 20, 20, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [226, 75, 20, 189, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [11, 75, 20, 84, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [47, 75, 20, 112, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [62, 75, 20, 97, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [253, 75, 20, 162, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [25, 75, 20, 70, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [249, 75, 20, 166, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [34, 75, 20, 125, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [172, 75, 20, 243, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [63, 75, 20, 96, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [160, 75, 20, 255, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [61, 75, 20, 98, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [40, 75, 20, 119, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [186, 75, 20, 229, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [216, 75, 20, 135, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [209, 75, 20, 142, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [29, 75, 20, 66, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [136, 75, 20, 215, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [79, 75, 20, 16, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [51, 75, 20, 108, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [185, 75, 20, 230, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [22, 75, 20, 73, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [32, 75, 20, 127, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [33, 75, 20, 126, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [84, 75, 20, 11, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [96, 75, 20, 63, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [154, 75, 20, 197, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [104, 75, 20, 55, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [1, 75, 20, 94, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [236, 75, 20, 179, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [137, 75, 20, 214, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [19, 75, 20, 76, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [217, 75, 20, 134, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [21, 75, 20, 74, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [190, 75, 20, 225, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [105, 75, 20, 54, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [235, 75, 20, 180, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [58, 75, 20, 101, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [215, 75, 20, 136, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [26, 75, 20, 69, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [198, 75, 20, 153, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [139, 75, 20, 212, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [97, 75, 20, 62, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [80, 75, 20, 15, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [241, 75, 20, 174, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [132, 75, 20, 219, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [3, 75, 20, 92, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [112, 75, 20, 47, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [118, 75, 20, 41, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [98, 75, 20, 61, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [245, 75, 20, 170, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [234, 75, 20, 181, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [213, 75, 20, 138, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [144, 75, 20, 207, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [193, 75, 20, 158, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [121, 75, 20, 38, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [119, 75, 20, 40, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [9, 75, 20, 86, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [191, 75, 20, 224, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [127, 75, 20, 32, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [195, 75, 20, 156, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [56, 75, 20, 103, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [69, 75, 20, 26, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [106, 75, 20, 53, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [6, 75, 20, 89, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [165, 75, 20, 250, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [146, 75, 20, 205, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [107, 75, 20, 52, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [153, 75, 20, 198, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [122, 75, 20, 37, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [181, 75, 20, 234, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [168, 75, 20, 247, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [167, 75, 20, 248, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [2, 75, 20, 93, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [207, 75, 20, 144, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [134, 75, 20, 217, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [140, 75, 20, 211, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [224, 75, 20, 191, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [27, 75, 20, 68, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [42, 75, 20, 117, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [197, 75, 20, 154, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [201, 75, 20, 150, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [232, 75, 20, 183, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [247, 75, 20, 168, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [54, 75, 20, 105, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [41, 75, 20, 118, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [214, 75, 20, 137, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [101, 75, 20, 58, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [173, 75, 20, 242, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [126, 75, 20, 33, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [45, 75, 20, 114, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [254, 75, 20, 161, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [157, 75, 20, 194, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [68, 75, 20, 27, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [7, 75, 20, 88, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [94, 75, 20, 1, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [103, 75, 20, 56, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [35, 75, 20, 124, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [73, 75, 20, 22, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [90, 75, 20, 5, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [187, 75, 20, 228, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [117, 75, 20, 42, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [230, 75, 20, 185, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [24, 75, 20, 71, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [16, 75, 20, 79, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [170, 75, 20, 245, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [178, 75, 20, 237, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [124, 75, 20, 35, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [212, 75, 20, 139, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [130, 75, 20, 221, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [46, 75, 20, 113, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [228, 75, 20, 187, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [100, 75, 20, 59, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [49, 75, 20, 110, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [225, 75, 20, 190, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [218, 75, 20, 133, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [8, 75, 20, 87, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [0, 75, 20, 95, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [48, 75, 20, 111, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [115, 75, 20, 44, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [60, 75, 20, 99, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [30, 75, 20, 65, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [102, 75, 20, 57, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [248, 75, 20, 167, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [233, 75, 20, 182, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [150, 75, 20, 201, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [88, 75, 20, 7, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [171, 75, 20, 244, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [175, 75, 20, 240, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [222, 75, 20, 129, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [67, 75, 20, 28, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [221, 75, 20, 130, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [242, 75, 20, 173, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [13, 75, 20, 82, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [87, 75, 20, 8, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [183, 75, 20, 232, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [239, 75, 20, 176, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [116, 75, 20, 43, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [147, 75, 20, 204, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [86, 75, 20, 9, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [108, 75, 20, 51, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [206, 75, 20, 145, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [208, 75, 20, 143, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [95, 75, 20, 0, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [64, 75, 20, 31, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [148, 75, 20, 203, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [50, 75, 20, 109, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [128, 75, 20, 223, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [66, 75, 20, 29, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [31, 75, 20, 64, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [20, 75, 20, 75, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [38, 75, 20, 121, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [156, 75, 20, 195, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [142, 75, 20, 209, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [252, 75, 20, 163, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [210, 75, 20, 141, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [231, 75, 20, 184, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [78, 75, 20, 17, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [37, 75, 20, 122, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [113, 75, 20, 46, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [135, 75, 20, 216, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [177, 75, 20, 238, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [176, 75, 20, 239, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [74, 75, 20, 21, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [4, 75, 20, 91, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [143, 75, 20, 208, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [92, 75, 20, 3, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [114, 75, 20, 45, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [57, 75, 20, 102, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [204, 75, 20, 147, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [52, 75, 20, 107, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [91, 75, 20, 4, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [15, 75, 20, 80, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [109, 75, 20, 50, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [131, 75, 20, 220, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [188, 75, 20, 227, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [251, 75, 20, 164, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [39, 75, 20, 120, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [164, 75, 20, 251, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [219, 75, 20, 132, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [194, 75, 20, 157, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [162, 75, 20, 253, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [43, 75, 20, 116, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [83, 75, 20, 12, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [227, 75, 20, 188, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [180, 75, 20, 235, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [174, 75, 20, 241, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [161, 75, 20, 254, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [36, 75, 20, 123, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [189, 75, 20, 226, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [211, 75, 20, 140, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [244, 75, 20, 171, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [111, 75, 20, 48, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [18, 75, 20, 77, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [229, 75, 20, 186, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [182, 75, 20, 233, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [155, 75, 20, 196, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [179, 75, 20, 236, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [55, 75, 20, 104, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [133, 75, 20, 218, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [220, 75, 20, 131, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [120, 75, 20, 39, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [82, 75, 20, 13, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [123, 75, 20, 36, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [163, 75, 20, 252, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [23, 75, 20, 72, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [53, 75, 20, 106, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [138, 75, 20, 213, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [110, 75, 20, 49, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [129, 75, 20, 222, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16], [44, 75, 20, 115, 124, 172, 2, 210, 180, 16, 73, 237, 117, 150, 243, 16]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[88, 217, 127, 254, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [71, 217, 127, 225, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [76, 217, 127, 234, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [64, 217, 127, 230, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [201, 217, 127, 111, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [80, 217, 127, 246, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [84, 217, 127, 242, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [254, 217, 127, 88, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [11, 217, 127, 173, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [58, 217, 127, 156, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [92, 217, 127, 250, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [16, 217, 127, 182, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [197, 217, 127, 99, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [236, 217, 127, 74, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [144, 217, 127, 54, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [77, 217, 127, 235, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [241, 217, 127, 87, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [185, 217, 127, 31, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [242, 217, 127, 84, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [70, 217, 127, 224, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [193, 217, 127, 103, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [98, 217, 127, 196, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [124, 217, 127, 218, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [203, 217, 127, 109, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [150, 217, 127, 48, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [239, 217, 127, 73, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [153, 217, 127, 63, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [148, 217, 127, 50, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [167, 217, 127, 1, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [159, 217, 127, 57, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [73, 217, 127, 239, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [251, 217, 127, 93, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [140, 217, 127, 42, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [198, 217, 127, 96, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [168, 217, 127, 14, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [29, 217, 127, 187, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [13, 217, 127, 171, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [4, 217, 127, 162, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [204, 217, 127, 106, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [247, 217, 127, 81, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [15, 217, 127, 169, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [158, 217, 127, 56, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [222, 217, 127, 120, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [202, 217, 127, 108, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [74, 217, 127, 236, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [227, 217, 127, 69, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [10, 217, 127, 172, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [46, 217, 127, 136, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [63, 217, 127, 153, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [252, 217, 127, 90, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [24, 217, 127, 190, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [248, 217, 127, 94, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [35, 217, 127, 133, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [173, 217, 127, 11, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [62, 217, 127, 152, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [161, 217, 127, 7, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [60, 217, 127, 154, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [41, 217, 127, 143, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [187, 217, 127, 29, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [217, 217, 127, 127, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [208, 217, 127, 118, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [28, 217, 127, 186, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [137, 217, 127, 47, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [78, 217, 127, 232, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [50, 217, 127, 148, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [184, 217, 127, 30, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [23, 217, 127, 177, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [33, 217, 127, 135, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [32, 217, 127, 134, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [85, 217, 127, 243, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [97, 217, 127, 199, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [155, 217, 127, 61, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [105, 217, 127, 207, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [0, 217, 127, 166, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [237, 217, 127, 75, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [136, 217, 127, 46, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [18, 217, 127, 180, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [216, 217, 127, 126, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [20, 217, 127, 178, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [191, 217, 127, 25, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [104, 217, 127, 206, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [234, 217, 127, 76, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [59, 217, 127, 157, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [214, 217, 127, 112, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [27, 217, 127, 189, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [199, 217, 127, 97, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [138, 217, 127, 44, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [96, 217, 127, 198, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [81, 217, 127, 247, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [240, 217, 127, 86, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [133, 217, 127, 35, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [2, 217, 127, 164, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [113, 217, 127, 215, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [119, 217, 127, 209, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [99, 217, 127, 197, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [244, 217, 127, 82, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [235, 217, 127, 77, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [212, 217, 127, 114, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [145, 217, 127, 55, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [192, 217, 127, 102, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [120, 217, 127, 222, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [118, 217, 127, 208, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [8, 217, 127, 174, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [190, 217, 127, 24, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [126, 217, 127, 216, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [194, 217, 127, 100, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [57, 217, 127, 159, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [68, 217, 127, 226, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [107, 217, 127, 205, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [7, 217, 127, 161, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [164, 217, 127, 2, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [147, 217, 127, 53, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [106, 217, 127, 204, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [152, 217, 127, 62, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [123, 217, 127, 221, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [180, 217, 127, 18, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [169, 217, 127, 15, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [166, 217, 127, 0, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [3, 217, 127, 165, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [206, 217, 127, 104, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [135, 217, 127, 33, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [141, 217, 127, 43, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [225, 217, 127, 71, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [26, 217, 127, 188, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [43, 217, 127, 141, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [196, 217, 127, 98, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [200, 217, 127, 110, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [233, 217, 127, 79, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [246, 217, 127, 80, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [55, 217, 127, 145, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [40, 217, 127, 142, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [215, 217, 127, 113, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [100, 217, 127, 194, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [172, 217, 127, 10, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [127, 217, 127, 217, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [44, 217, 127, 138, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [255, 217, 127, 89, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [156, 217, 127, 58, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [69, 217, 127, 227, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [6, 217, 127, 160, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [95, 217, 127, 249, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [102, 217, 127, 192, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [34, 217, 127, 132, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [72, 217, 127, 238, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [91, 217, 127, 253, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [186, 217, 127, 28, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [116, 217, 127, 210, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [231, 217, 127, 65, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [25, 217, 127, 191, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [17, 217, 127, 183, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [171, 217, 127, 13, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [179, 217, 127, 21, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [125, 217, 127, 219, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [213, 217, 127, 115, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [131, 217, 127, 37, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [47, 217, 127, 137, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [229, 217, 127, 67, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [101, 217, 127, 195, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [48, 217, 127, 150, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [224, 217, 127, 70, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [219, 217, 127, 125, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [9, 217, 127, 175, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [1, 217, 127, 167, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [49, 217, 127, 151, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [114, 217, 127, 212, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [61, 217, 127, 155, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [31, 217, 127, 185, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [103, 217, 127, 193, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [249, 217, 127, 95, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [232, 217, 127, 78, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [151, 217, 127, 49, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [89, 217, 127, 255, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [170, 217, 127, 12, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [174, 217, 127, 8, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [223, 217, 127, 121, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [66, 217, 127, 228, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [220, 217, 127, 122, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [243, 217, 127, 85, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [12, 217, 127, 170, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [86, 217, 127, 240, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [182, 217, 127, 16, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [238, 217, 127, 72, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [117, 217, 127, 211, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [146, 217, 127, 52, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [87, 217, 127, 241, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [109, 217, 127, 203, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [207, 217, 127, 105, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [209, 217, 127, 119, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [94, 217, 127, 248, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [65, 217, 127, 231, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [149, 217, 127, 51, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [51, 217, 127, 149, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [129, 217, 127, 39, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [67, 217, 127, 229, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [30, 217, 127, 184, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [21, 217, 127, 179, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [39, 217, 127, 129, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [157, 217, 127, 59, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [143, 217, 127, 41, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [253, 217, 127, 91, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [211, 217, 127, 117, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [230, 217, 127, 64, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [79, 217, 127, 233, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [36, 217, 127, 130, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [112, 217, 127, 214, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [134, 217, 127, 32, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [176, 217, 127, 22, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [177, 217, 127, 23, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [75, 217, 127, 237, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [5, 217, 127, 163, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [142, 217, 127, 40, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [93, 217, 127, 251, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [115, 217, 127, 213, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [56, 217, 127, 158, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [205, 217, 127, 107, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [53, 217, 127, 147, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [90, 217, 127, 252, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [14, 217, 127, 168, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [108, 217, 127, 202, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [130, 217, 127, 36, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [189, 217, 127, 27, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [250, 217, 127, 92, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [38, 217, 127, 128, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [165, 217, 127, 3, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [218, 217, 127, 124, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [195, 217, 127, 101, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [163, 217, 127, 5, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [42, 217, 127, 140, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [82, 217, 127, 244, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [226, 217, 127, 68, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [181, 217, 127, 19, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [175, 217, 127, 9, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [160, 217, 127, 6, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [37, 217, 127, 131, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [188, 217, 127, 26, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [210, 217, 127, 116, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [245, 217, 127, 83, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [110, 217, 127, 200, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [19, 217, 127, 181, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [228, 217, 127, 66, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [183, 217, 127, 17, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [154, 217, 127, 60, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [178, 217, 127, 20, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [54, 217, 127, 144, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [132, 217, 127, 34, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [221, 217, 127, 123, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [121, 217, 127, 223, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [83, 217, 127, 245, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [122, 217, 127, 220, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [162, 217, 127, 4, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [22, 217, 127, 176, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [52, 217, 127, 146, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [139, 217, 127, 45, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [111, 217, 127, 201, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [128, 217, 127, 38, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220], [45, 217, 127, 139, 119, 119, 236, 236, 56, 195, 75, 176, 194, 158, 128, 220]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[121, 115, 87, 93, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [102, 115, 87, 66, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [109, 115, 87, 73, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [97, 115, 87, 69, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [232, 115, 87, 204, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [113, 115, 87, 85, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [117, 115, 87, 81, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [223, 115, 87, 251, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [42, 115, 87, 14, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [27, 115, 87, 63, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [125, 115, 87, 89, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [49, 115, 87, 21, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [228, 115, 87, 192, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [205, 115, 87, 233, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [177, 115, 87, 149, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [108, 115, 87, 72, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [208, 115, 87, 244, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [152, 115, 87, 188, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [211, 115, 87, 247, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [103, 115, 87, 67, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [224, 115, 87, 196, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [67, 115, 87, 103, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [93, 115, 87, 121, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [234, 115, 87, 206, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [183, 115, 87, 147, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [206, 115, 87, 234, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [184, 115, 87, 156, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [181, 115, 87, 145, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [134, 115, 87, 162, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [190, 115, 87, 154, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [104, 115, 87, 76, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [218, 115, 87, 254, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [173, 115, 87, 137, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [231, 115, 87, 195, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [137, 115, 87, 173, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [60, 115, 87, 24, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [44, 115, 87, 8, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [37, 115, 87, 1, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [237, 115, 87, 201, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [214, 115, 87, 242, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [46, 115, 87, 10, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [191, 115, 87, 155, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [255, 115, 87, 219, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [235, 115, 87, 207, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [107, 115, 87, 79, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [194, 115, 87, 230, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [43, 115, 87, 15, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [15, 115, 87, 43, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [30, 115, 87, 58, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [221, 115, 87, 249, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [57, 115, 87, 29, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [217, 115, 87, 253, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [2, 115, 87, 38, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [140, 115, 87, 168, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [31, 115, 87, 59, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [128, 115, 87, 164, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [29, 115, 87, 57, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [8, 115, 87, 44, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [154, 115, 87, 190, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [248, 115, 87, 220, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [241, 115, 87, 213, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [61, 115, 87, 25, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [168, 115, 87, 140, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [111, 115, 87, 75, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [19, 115, 87, 55, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [153, 115, 87, 189, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [54, 115, 87, 18, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [0, 115, 87, 36, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [1, 115, 87, 37, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [116, 115, 87, 80, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [64, 115, 87, 100, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [186, 115, 87, 158, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [72, 115, 87, 108, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [33, 115, 87, 5, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [204, 115, 87, 232, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [169, 115, 87, 141, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [51, 115, 87, 23, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [249, 115, 87, 221, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [53, 115, 87, 17, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [158, 115, 87, 186, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [73, 115, 87, 109, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [203, 115, 87, 239, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [26, 115, 87, 62, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [247, 115, 87, 211, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [58, 115, 87, 30, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [230, 115, 87, 194, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [171, 115, 87, 143, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [65, 115, 87, 101, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [112, 115, 87, 84, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [209, 115, 87, 245, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [164, 115, 87, 128, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [35, 115, 87, 7, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [80, 115, 87, 116, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [86, 115, 87, 114, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [66, 115, 87, 102, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [213, 115, 87, 241, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [202, 115, 87, 238, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [245, 115, 87, 209, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [176, 115, 87, 148, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [225, 115, 87, 197, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [89, 115, 87, 125, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [87, 115, 87, 115, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [41, 115, 87, 13, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [159, 115, 87, 187, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [95, 115, 87, 123, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [227, 115, 87, 199, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [24, 115, 87, 60, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [101, 115, 87, 65, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [74, 115, 87, 110, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [38, 115, 87, 2, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [133, 115, 87, 161, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [178, 115, 87, 150, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [75, 115, 87, 111, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [185, 115, 87, 157, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [90, 115, 87, 126, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [149, 115, 87, 177, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [136, 115, 87, 172, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [135, 115, 87, 163, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [34, 115, 87, 6, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [239, 115, 87, 203, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [166, 115, 87, 130, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [172, 115, 87, 136, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [192, 115, 87, 228, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [59, 115, 87, 31, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [10, 115, 87, 46, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [229, 115, 87, 193, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [233, 115, 87, 205, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [200, 115, 87, 236, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [215, 115, 87, 243, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [22, 115, 87, 50, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [9, 115, 87, 45, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [246, 115, 87, 210, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [69, 115, 87, 97, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [141, 115, 87, 169, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [94, 115, 87, 122, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [13, 115, 87, 41, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [222, 115, 87, 250, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [189, 115, 87, 153, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [100, 115, 87, 64, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [39, 115, 87, 3, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [126, 115, 87, 90, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [71, 115, 87, 99, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [3, 115, 87, 39, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [105, 115, 87, 77, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [122, 115, 87, 94, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [155, 115, 87, 191, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [85, 115, 87, 113, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [198, 115, 87, 226, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [56, 115, 87, 28, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [48, 115, 87, 20, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [138, 115, 87, 174, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [146, 115, 87, 182, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [92, 115, 87, 120, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [244, 115, 87, 208, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [162, 115, 87, 134, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [14, 115, 87, 42, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [196, 115, 87, 224, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [68, 115, 87, 96, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [17, 115, 87, 53, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [193, 115, 87, 229, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [250, 115, 87, 222, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [40, 115, 87, 12, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [32, 115, 87, 4, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [16, 115, 87, 52, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [83, 115, 87, 119, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [28, 115, 87, 56, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [62, 115, 87, 26, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [70, 115, 87, 98, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [216, 115, 87, 252, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [201, 115, 87, 237, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [182, 115, 87, 146, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [120, 115, 87, 92, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [139, 115, 87, 175, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [143, 115, 87, 171, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [254, 115, 87, 218, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [99, 115, 87, 71, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [253, 115, 87, 217, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [210, 115, 87, 246, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [45, 115, 87, 9, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [119, 115, 87, 83, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [151, 115, 87, 179, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [207, 115, 87, 235, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [84, 115, 87, 112, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [179, 115, 87, 151, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [118, 115, 87, 82, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [76, 115, 87, 104, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [238, 115, 87, 202, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [240, 115, 87, 212, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [127, 115, 87, 91, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [96, 115, 87, 68, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [180, 115, 87, 144, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [18, 115, 87, 54, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [160, 115, 87, 132, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [98, 115, 87, 70, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [63, 115, 87, 27, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [52, 115, 87, 16, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [6, 115, 87, 34, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [188, 115, 87, 152, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [174, 115, 87, 138, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [220, 115, 87, 248, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [242, 115, 87, 214, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [199, 115, 87, 227, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [110, 115, 87, 74, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [5, 115, 87, 33, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [81, 115, 87, 117, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [167, 115, 87, 131, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [145, 115, 87, 181, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [144, 115, 87, 180, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [106, 115, 87, 78, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [36, 115, 87, 0, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [175, 115, 87, 139, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [124, 115, 87, 88, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [82, 115, 87, 118, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [25, 115, 87, 61, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [236, 115, 87, 200, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [20, 115, 87, 48, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [123, 115, 87, 95, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [47, 115, 87, 11, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [77, 115, 87, 105, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [163, 115, 87, 135, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [156, 115, 87, 184, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [219, 115, 87, 255, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [7, 115, 87, 35, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [132, 115, 87, 160, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [251, 115, 87, 223, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [226, 115, 87, 198, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [130, 115, 87, 166, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [11, 115, 87, 47, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [115, 115, 87, 87, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [195, 115, 87, 231, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [148, 115, 87, 176, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [142, 115, 87, 170, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [129, 115, 87, 165, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [4, 115, 87, 32, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [157, 115, 87, 185, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [243, 115, 87, 215, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [212, 115, 87, 240, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [79, 115, 87, 107, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [50, 115, 87, 22, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [197, 115, 87, 225, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [150, 115, 87, 178, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [187, 115, 87, 159, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [147, 115, 87, 183, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [23, 115, 87, 51, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [165, 115, 87, 129, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [252, 115, 87, 216, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [88, 115, 87, 124, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [114, 115, 87, 86, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [91, 115, 87, 127, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [131, 115, 87, 167, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [55, 115, 87, 19, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [21, 115, 87, 49, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [170, 115, 87, 142, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [78, 115, 87, 106, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [161, 115, 87, 133, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228], [12, 115, 87, 40, 237, 131, 253, 147, 220, 206, 227, 241, 136, 13, 97, 228]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[202, 138, 158, 222, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [213, 138, 158, 193, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [222, 138, 158, 202, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [210, 138, 158, 198, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [91, 138, 158, 79, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [194, 138, 158, 214, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [198, 138, 158, 210, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [108, 138, 158, 120, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [153, 138, 158, 141, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [168, 138, 158, 188, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [206, 138, 158, 218, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [130, 138, 158, 150, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [87, 138, 158, 67, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [126, 138, 158, 106, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [2, 138, 158, 22, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [223, 138, 158, 203, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [99, 138, 158, 119, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [43, 138, 158, 63, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [96, 138, 158, 116, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [212, 138, 158, 192, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [83, 138, 158, 71, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [240, 138, 158, 228, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [238, 138, 158, 250, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [89, 138, 158, 77, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [4, 138, 158, 16, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [125, 138, 158, 105, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [11, 138, 158, 31, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [6, 138, 158, 18, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [53, 138, 158, 33, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [13, 138, 158, 25, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [219, 138, 158, 207, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [105, 138, 158, 125, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [30, 138, 158, 10, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [84, 138, 158, 64, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [58, 138, 158, 46, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [143, 138, 158, 155, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [159, 138, 158, 139, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [150, 138, 158, 130, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [94, 138, 158, 74, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [101, 138, 158, 113, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [157, 138, 158, 137, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [12, 138, 158, 24, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [76, 138, 158, 88, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [88, 138, 158, 76, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [216, 138, 158, 204, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [113, 138, 158, 101, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [152, 138, 158, 140, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [188, 138, 158, 168, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [173, 138, 158, 185, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [110, 138, 158, 122, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [138, 138, 158, 158, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [106, 138, 158, 126, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [177, 138, 158, 165, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [63, 138, 158, 43, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [172, 138, 158, 184, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [51, 138, 158, 39, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [174, 138, 158, 186, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [187, 138, 158, 175, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [41, 138, 158, 61, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [75, 138, 158, 95, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [66, 138, 158, 86, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [142, 138, 158, 154, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [27, 138, 158, 15, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [220, 138, 158, 200, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [160, 138, 158, 180, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [42, 138, 158, 62, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [133, 138, 158, 145, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [179, 138, 158, 167, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [178, 138, 158, 166, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [199, 138, 158, 211, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [243, 138, 158, 231, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [9, 138, 158, 29, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [251, 138, 158, 239, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [146, 138, 158, 134, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [127, 138, 158, 107, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [26, 138, 158, 14, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [128, 138, 158, 148, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [74, 138, 158, 94, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [134, 138, 158, 146, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [45, 138, 158, 57, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [250, 138, 158, 238, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [120, 138, 158, 108, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [169, 138, 158, 189, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [68, 138, 158, 80, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [137, 138, 158, 157, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [85, 138, 158, 65, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [24, 138, 158, 12, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [242, 138, 158, 230, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [195, 138, 158, 215, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [98, 138, 158, 118, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [23, 138, 158, 3, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [144, 138, 158, 132, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [227, 138, 158, 247, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [229, 138, 158, 241, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [241, 138, 158, 229, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [102, 138, 158, 114, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [121, 138, 158, 109, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [70, 138, 158, 82, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [3, 138, 158, 23, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [82, 138, 158, 70, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [234, 138, 158, 254, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [228, 138, 158, 240, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [154, 138, 158, 142, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [44, 138, 158, 56, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [236, 138, 158, 248, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [80, 138, 158, 68, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [171, 138, 158, 191, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [214, 138, 158, 194, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [249, 138, 158, 237, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [149, 138, 158, 129, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [54, 138, 158, 34, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [1, 138, 158, 21, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [248, 138, 158, 236, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [10, 138, 158, 30, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [233, 138, 158, 253, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [38, 138, 158, 50, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [59, 138, 158, 47, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [52, 138, 158, 32, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [145, 138, 158, 133, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [92, 138, 158, 72, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [21, 138, 158, 1, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [31, 138, 158, 11, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [115, 138, 158, 103, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [136, 138, 158, 156, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [185, 138, 158, 173, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [86, 138, 158, 66, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [90, 138, 158, 78, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [123, 138, 158, 111, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [100, 138, 158, 112, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [165, 138, 158, 177, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [186, 138, 158, 174, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [69, 138, 158, 81, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [246, 138, 158, 226, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [62, 138, 158, 42, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [237, 138, 158, 249, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [190, 138, 158, 170, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [109, 138, 158, 121, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [14, 138, 158, 26, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [215, 138, 158, 195, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [148, 138, 158, 128, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [205, 138, 158, 217, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [244, 138, 158, 224, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [176, 138, 158, 164, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [218, 138, 158, 206, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [201, 138, 158, 221, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [40, 138, 158, 60, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [230, 138, 158, 242, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [117, 138, 158, 97, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [139, 138, 158, 159, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [131, 138, 158, 151, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [57, 138, 158, 45, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [33, 138, 158, 53, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [239, 138, 158, 251, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [71, 138, 158, 83, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [17, 138, 158, 5, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [189, 138, 158, 169, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [119, 138, 158, 99, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [247, 138, 158, 227, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [162, 138, 158, 182, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [114, 138, 158, 102, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [73, 138, 158, 93, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [155, 138, 158, 143, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [147, 138, 158, 135, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [163, 138, 158, 183, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [224, 138, 158, 244, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [175, 138, 158, 187, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [141, 138, 158, 153, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [245, 138, 158, 225, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [107, 138, 158, 127, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [122, 138, 158, 110, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [5, 138, 158, 17, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [203, 138, 158, 223, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [56, 138, 158, 44, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [60, 138, 158, 40, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [77, 138, 158, 89, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [208, 138, 158, 196, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [78, 138, 158, 90, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [97, 138, 158, 117, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [158, 138, 158, 138, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [196, 138, 158, 208, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [36, 138, 158, 48, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [124, 138, 158, 104, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [231, 138, 158, 243, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [0, 138, 158, 20, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [197, 138, 158, 209, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [255, 138, 158, 235, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [93, 138, 158, 73, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [67, 138, 158, 87, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [204, 138, 158, 216, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [211, 138, 158, 199, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [7, 138, 158, 19, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [161, 138, 158, 181, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [19, 138, 158, 7, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [209, 138, 158, 197, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [140, 138, 158, 152, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [135, 138, 158, 147, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [181, 138, 158, 161, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [15, 138, 158, 27, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [29, 138, 158, 9, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [111, 138, 158, 123, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [65, 138, 158, 85, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [116, 138, 158, 96, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [221, 138, 158, 201, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [182, 138, 158, 162, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [226, 138, 158, 246, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [20, 138, 158, 0, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [34, 138, 158, 54, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [35, 138, 158, 55, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [217, 138, 158, 205, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [151, 138, 158, 131, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [28, 138, 158, 8, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [207, 138, 158, 219, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [225, 138, 158, 245, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [170, 138, 158, 190, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [95, 138, 158, 75, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [167, 138, 158, 179, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [200, 138, 158, 220, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [156, 138, 158, 136, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [254, 138, 158, 234, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [16, 138, 158, 4, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [47, 138, 158, 59, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [104, 138, 158, 124, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [180, 138, 158, 160, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [55, 138, 158, 35, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [72, 138, 158, 92, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [81, 138, 158, 69, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [49, 138, 158, 37, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [184, 138, 158, 172, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [192, 138, 158, 212, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [112, 138, 158, 100, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [39, 138, 158, 51, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [61, 138, 158, 41, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [50, 138, 158, 38, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [183, 138, 158, 163, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [46, 138, 158, 58, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [64, 138, 158, 84, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [103, 138, 158, 115, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [252, 138, 158, 232, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [129, 138, 158, 149, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [118, 138, 158, 98, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [37, 138, 158, 49, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [8, 138, 158, 28, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [32, 138, 158, 52, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [164, 138, 158, 176, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [22, 138, 158, 2, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [79, 138, 158, 91, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [235, 138, 158, 255, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [193, 138, 158, 213, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [232, 138, 158, 252, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [48, 138, 158, 36, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [132, 138, 158, 144, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [166, 138, 158, 178, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [25, 138, 158, 13, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [253, 138, 158, 233, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [18, 138, 158, 6, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247], [191, 138, 158, 171, 69, 227, 29, 187, 245, 32, 17, 196, 248, 164, 171, 247]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[181, 116, 84, 149, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [170, 116, 84, 138, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [161, 116, 84, 129, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [173, 116, 84, 141, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [36, 116, 84, 4, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [189, 116, 84, 157, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [185, 116, 84, 153, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [19, 116, 84, 51, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [230, 116, 84, 198, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [215, 116, 84, 247, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [177, 116, 84, 145, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [253, 116, 84, 221, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [40, 116, 84, 8, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [1, 116, 84, 33, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [125, 116, 84, 93, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [160, 116, 84, 128, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [28, 116, 84, 60, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [84, 116, 84, 116, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [31, 116, 84, 63, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [171, 116, 84, 139, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [44, 116, 84, 12, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [143, 116, 84, 175, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [145, 116, 84, 177, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [38, 116, 84, 6, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [123, 116, 84, 91, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [2, 116, 84, 34, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [116, 116, 84, 84, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [121, 116, 84, 89, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [74, 116, 84, 106, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [114, 116, 84, 82, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [164, 116, 84, 132, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [22, 116, 84, 54, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [97, 116, 84, 65, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [43, 116, 84, 11, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [69, 116, 84, 101, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [240, 116, 84, 208, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [224, 116, 84, 192, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [233, 116, 84, 201, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [33, 116, 84, 1, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [26, 116, 84, 58, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [226, 116, 84, 194, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [115, 116, 84, 83, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [51, 116, 84, 19, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [39, 116, 84, 7, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [167, 116, 84, 135, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [14, 116, 84, 46, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [231, 116, 84, 199, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [195, 116, 84, 227, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [210, 116, 84, 242, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [17, 116, 84, 49, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [245, 116, 84, 213, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [21, 116, 84, 53, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [206, 116, 84, 238, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [64, 116, 84, 96, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [211, 116, 84, 243, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [76, 116, 84, 108, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [209, 116, 84, 241, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [196, 116, 84, 228, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [86, 116, 84, 118, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [52, 116, 84, 20, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [61, 116, 84, 29, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [241, 116, 84, 209, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [100, 116, 84, 68, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [163, 116, 84, 131, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [223, 116, 84, 255, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [85, 116, 84, 117, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [250, 116, 84, 218, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [204, 116, 84, 236, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [205, 116, 84, 237, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [184, 116, 84, 152, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [140, 116, 84, 172, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [118, 116, 84, 86, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [132, 116, 84, 164, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [237, 116, 84, 205, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [0, 116, 84, 32, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [101, 116, 84, 69, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [255, 116, 84, 223, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [53, 116, 84, 21, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [249, 116, 84, 217, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [82, 116, 84, 114, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [133, 116, 84, 165, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [7, 116, 84, 39, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [214, 116, 84, 246, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [59, 116, 84, 27, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [246, 116, 84, 214, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [42, 116, 84, 10, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [103, 116, 84, 71, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [141, 116, 84, 173, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [188, 116, 84, 156, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [29, 116, 84, 61, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [104, 116, 84, 72, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [239, 116, 84, 207, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [156, 116, 84, 188, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [154, 116, 84, 186, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [142, 116, 84, 174, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [25, 116, 84, 57, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [6, 116, 84, 38, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [57, 116, 84, 25, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [124, 116, 84, 92, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [45, 116, 84, 13, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [149, 116, 84, 181, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [155, 116, 84, 187, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [229, 116, 84, 197, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [83, 116, 84, 115, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [147, 116, 84, 179, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [47, 116, 84, 15, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [212, 116, 84, 244, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [169, 116, 84, 137, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [134, 116, 84, 166, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [234, 116, 84, 202, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [73, 116, 84, 105, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [126, 116, 84, 94, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [135, 116, 84, 167, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [117, 116, 84, 85, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [150, 116, 84, 182, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [89, 116, 84, 121, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [68, 116, 84, 100, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [75, 116, 84, 107, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [238, 116, 84, 206, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [35, 116, 84, 3, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [106, 116, 84, 74, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [96, 116, 84, 64, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [12, 116, 84, 44, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [247, 116, 84, 215, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [198, 116, 84, 230, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [41, 116, 84, 9, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [37, 116, 84, 5, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [4, 116, 84, 36, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [27, 116, 84, 59, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [218, 116, 84, 250, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [197, 116, 84, 229, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [58, 116, 84, 26, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [137, 116, 84, 169, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [65, 116, 84, 97, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [146, 116, 84, 178, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [193, 116, 84, 225, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [18, 116, 84, 50, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [113, 116, 84, 81, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [168, 116, 84, 136, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [235, 116, 84, 203, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [178, 116, 84, 146, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [139, 116, 84, 171, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [207, 116, 84, 239, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [165, 116, 84, 133, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [182, 116, 84, 150, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [87, 116, 84, 119, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [153, 116, 84, 185, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [10, 116, 84, 42, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [244, 116, 84, 212, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [252, 116, 84, 220, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [70, 116, 84, 102, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [94, 116, 84, 126, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [144, 116, 84, 176, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [56, 116, 84, 24, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [110, 116, 84, 78, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [194, 116, 84, 226, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [8, 116, 84, 40, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [136, 116, 84, 168, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [221, 116, 84, 253, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [13, 116, 84, 45, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [54, 116, 84, 22, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [228, 116, 84, 196, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [236, 116, 84, 204, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [220, 116, 84, 252, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [159, 116, 84, 191, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [208, 116, 84, 240, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [242, 116, 84, 210, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [138, 116, 84, 170, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [20, 116, 84, 52, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [5, 116, 84, 37, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [122, 116, 84, 90, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [180, 116, 84, 148, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [71, 116, 84, 103, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [67, 116, 84, 99, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [50, 116, 84, 18, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [175, 116, 84, 143, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [49, 116, 84, 17, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [30, 116, 84, 62, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [225, 116, 84, 193, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [187, 116, 84, 155, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [91, 116, 84, 123, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [3, 116, 84, 35, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [152, 116, 84, 184, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [127, 116, 84, 95, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [186, 116, 84, 154, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [128, 116, 84, 160, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [34, 116, 84, 2, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [60, 116, 84, 28, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [179, 116, 84, 147, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [172, 116, 84, 140, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [120, 116, 84, 88, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [222, 116, 84, 254, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [108, 116, 84, 76, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [174, 116, 84, 142, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [243, 116, 84, 211, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [248, 116, 84, 216, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [202, 116, 84, 234, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [112, 116, 84, 80, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [98, 116, 84, 66, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [16, 116, 84, 48, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [62, 116, 84, 30, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [11, 116, 84, 43, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [162, 116, 84, 130, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [201, 116, 84, 233, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [157, 116, 84, 189, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [107, 116, 84, 75, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [93, 116, 84, 125, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [92, 116, 84, 124, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [166, 116, 84, 134, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [232, 116, 84, 200, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [99, 116, 84, 67, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [176, 116, 84, 144, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [158, 116, 84, 190, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [213, 116, 84, 245, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [32, 116, 84, 0, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [216, 116, 84, 248, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [183, 116, 84, 151, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [227, 116, 84, 195, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [129, 116, 84, 161, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [111, 116, 84, 79, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [80, 116, 84, 112, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [23, 116, 84, 55, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [203, 116, 84, 235, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [72, 116, 84, 104, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [55, 116, 84, 23, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [46, 116, 84, 14, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [78, 116, 84, 110, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [199, 116, 84, 231, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [191, 116, 84, 159, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [15, 116, 84, 47, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [88, 116, 84, 120, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [66, 116, 84, 98, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [77, 116, 84, 109, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [200, 116, 84, 232, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [81, 116, 84, 113, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [63, 116, 84, 31, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [24, 116, 84, 56, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [131, 116, 84, 163, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [254, 116, 84, 222, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [9, 116, 84, 41, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [90, 116, 84, 122, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [119, 116, 84, 87, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [95, 116, 84, 127, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [219, 116, 84, 251, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [105, 116, 84, 73, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [48, 116, 84, 16, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [148, 116, 84, 180, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [190, 116, 84, 158, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [151, 116, 84, 183, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [79, 116, 84, 111, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [251, 116, 84, 219, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [217, 116, 84, 249, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [102, 116, 84, 70, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [130, 116, 84, 162, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [109, 116, 84, 77, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204], [192, 116, 84, 224, 110, 248, 230, 112, 126, 147, 120, 149, 228, 6, 46, 204]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[208, 208, 221, 221, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [207, 208, 221, 194, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [196, 208, 221, 201, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [200, 208, 221, 197, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [65, 208, 221, 76, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [216, 208, 221, 213, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [220, 208, 221, 209, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [118, 208, 221, 123, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [131, 208, 221, 142, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [178, 208, 221, 191, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [212, 208, 221, 217, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [152, 208, 221, 149, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [77, 208, 221, 64, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [100, 208, 221, 105, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [24, 208, 221, 21, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [197, 208, 221, 200, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [121, 208, 221, 116, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [49, 208, 221, 60, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [122, 208, 221, 119, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [206, 208, 221, 195, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [73, 208, 221, 68, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [234, 208, 221, 231, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [244, 208, 221, 249, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [67, 208, 221, 78, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [30, 208, 221, 19, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [103, 208, 221, 106, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [17, 208, 221, 28, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [28, 208, 221, 17, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [47, 208, 221, 34, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [23, 208, 221, 26, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [193, 208, 221, 204, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [115, 208, 221, 126, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [4, 208, 221, 9, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [78, 208, 221, 67, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [32, 208, 221, 45, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [149, 208, 221, 152, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [133, 208, 221, 136, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [140, 208, 221, 129, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [68, 208, 221, 73, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [127, 208, 221, 114, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [135, 208, 221, 138, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [22, 208, 221, 27, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [86, 208, 221, 91, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [66, 208, 221, 79, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [194, 208, 221, 207, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [107, 208, 221, 102, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [130, 208, 221, 143, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [166, 208, 221, 171, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [183, 208, 221, 186, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [116, 208, 221, 121, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [144, 208, 221, 157, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [112, 208, 221, 125, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [171, 208, 221, 166, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [37, 208, 221, 40, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [182, 208, 221, 187, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [41, 208, 221, 36, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [180, 208, 221, 185, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [161, 208, 221, 172, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [51, 208, 221, 62, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [81, 208, 221, 92, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [88, 208, 221, 85, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [148, 208, 221, 153, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [1, 208, 221, 12, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [198, 208, 221, 203, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [186, 208, 221, 183, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [48, 208, 221, 61, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [159, 208, 221, 146, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [169, 208, 221, 164, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [168, 208, 221, 165, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [221, 208, 221, 208, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [233, 208, 221, 228, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [19, 208, 221, 30, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [225, 208, 221, 236, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [136, 208, 221, 133, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [101, 208, 221, 104, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [0, 208, 221, 13, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [154, 208, 221, 151, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [80, 208, 221, 93, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [156, 208, 221, 145, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [55, 208, 221, 58, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [224, 208, 221, 237, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [98, 208, 221, 111, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [179, 208, 221, 190, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [94, 208, 221, 83, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [147, 208, 221, 158, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [79, 208, 221, 66, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [2, 208, 221, 15, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [232, 208, 221, 229, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [217, 208, 221, 212, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [120, 208, 221, 117, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [13, 208, 221, 0, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [138, 208, 221, 135, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [249, 208, 221, 244, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [255, 208, 221, 242, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [235, 208, 221, 230, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [124, 208, 221, 113, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [99, 208, 221, 110, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [92, 208, 221, 81, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [25, 208, 221, 20, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [72, 208, 221, 69, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [240, 208, 221, 253, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [254, 208, 221, 243, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [128, 208, 221, 141, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [54, 208, 221, 59, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [246, 208, 221, 251, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [74, 208, 221, 71, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [177, 208, 221, 188, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [204, 208, 221, 193, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [227, 208, 221, 238, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [143, 208, 221, 130, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [44, 208, 221, 33, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [27, 208, 221, 22, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [226, 208, 221, 239, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [16, 208, 221, 29, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [243, 208, 221, 254, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [60, 208, 221, 49, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [33, 208, 221, 44, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [46, 208, 221, 35, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [139, 208, 221, 134, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [70, 208, 221, 75, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [15, 208, 221, 2, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [5, 208, 221, 8, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [105, 208, 221, 100, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [146, 208, 221, 159, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [163, 208, 221, 174, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [76, 208, 221, 65, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [64, 208, 221, 77, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [97, 208, 221, 108, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [126, 208, 221, 115, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [191, 208, 221, 178, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [160, 208, 221, 173, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [95, 208, 221, 82, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [236, 208, 221, 225, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [36, 208, 221, 41, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [247, 208, 221, 250, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [164, 208, 221, 169, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [119, 208, 221, 122, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [20, 208, 221, 25, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [205, 208, 221, 192, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [142, 208, 221, 131, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [215, 208, 221, 218, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [238, 208, 221, 227, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [170, 208, 221, 167, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [192, 208, 221, 205, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [211, 208, 221, 222, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [50, 208, 221, 63, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [252, 208, 221, 241, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [111, 208, 221, 98, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [145, 208, 221, 156, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [153, 208, 221, 148, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [35, 208, 221, 46, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [59, 208, 221, 54, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [245, 208, 221, 248, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [93, 208, 221, 80, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [11, 208, 221, 6, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [167, 208, 221, 170, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [109, 208, 221, 96, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [237, 208, 221, 224, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [184, 208, 221, 181, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [104, 208, 221, 101, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [83, 208, 221, 94, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [129, 208, 221, 140, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [137, 208, 221, 132, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [185, 208, 221, 180, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [250, 208, 221, 247, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [181, 208, 221, 184, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [151, 208, 221, 154, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [239, 208, 221, 226, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [113, 208, 221, 124, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [96, 208, 221, 109, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [31, 208, 221, 18, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [209, 208, 221, 220, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [34, 208, 221, 47, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [38, 208, 221, 43, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [87, 208, 221, 90, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [202, 208, 221, 199, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [84, 208, 221, 89, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [123, 208, 221, 118, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [132, 208, 221, 137, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [222, 208, 221, 211, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [62, 208, 221, 51, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [102, 208, 221, 107, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [253, 208, 221, 240, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [26, 208, 221, 23, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [223, 208, 221, 210, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [229, 208, 221, 232, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [71, 208, 221, 74, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [89, 208, 221, 84, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [214, 208, 221, 219, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [201, 208, 221, 196, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [29, 208, 221, 16, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [187, 208, 221, 182, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [9, 208, 221, 4, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [203, 208, 221, 198, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [150, 208, 221, 155, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [157, 208, 221, 144, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [175, 208, 221, 162, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [21, 208, 221, 24, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [7, 208, 221, 10, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [117, 208, 221, 120, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [91, 208, 221, 86, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [110, 208, 221, 99, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [199, 208, 221, 202, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [172, 208, 221, 161, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [248, 208, 221, 245, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [14, 208, 221, 3, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [56, 208, 221, 53, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [57, 208, 221, 52, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [195, 208, 221, 206, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [141, 208, 221, 128, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [6, 208, 221, 11, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [213, 208, 221, 216, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [251, 208, 221, 246, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [176, 208, 221, 189, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [69, 208, 221, 72, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [189, 208, 221, 176, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [210, 208, 221, 223, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [134, 208, 221, 139, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [228, 208, 221, 233, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [10, 208, 221, 7, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [53, 208, 221, 56, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [114, 208, 221, 127, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [174, 208, 221, 163, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [45, 208, 221, 32, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [82, 208, 221, 95, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [75, 208, 221, 70, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [43, 208, 221, 38, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [162, 208, 221, 175, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [218, 208, 221, 215, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [106, 208, 221, 103, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [61, 208, 221, 48, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [39, 208, 221, 42, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [40, 208, 221, 37, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [173, 208, 221, 160, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [52, 208, 221, 57, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [90, 208, 221, 87, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [125, 208, 221, 112, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [230, 208, 221, 235, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [155, 208, 221, 150, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [108, 208, 221, 97, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [63, 208, 221, 50, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [18, 208, 221, 31, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [58, 208, 221, 55, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [190, 208, 221, 179, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [12, 208, 221, 1, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [85, 208, 221, 88, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [241, 208, 221, 252, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [219, 208, 221, 214, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [242, 208, 221, 255, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [42, 208, 221, 39, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [158, 208, 221, 147, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [188, 208, 221, 177, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [3, 208, 221, 14, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [231, 208, 221, 234, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [8, 208, 221, 5, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70], [165, 208, 221, 168, 22, 117, 97, 2, 4, 176, 237, 89, 204, 156, 22, 70]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[248, 198, 177, 143, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [231, 198, 177, 144, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [236, 198, 177, 155, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [224, 198, 177, 151, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [105, 198, 177, 30, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [240, 198, 177, 135, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [244, 198, 177, 131, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [94, 198, 177, 41, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [171, 198, 177, 220, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [154, 198, 177, 237, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [252, 198, 177, 139, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [176, 198, 177, 199, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [101, 198, 177, 18, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [76, 198, 177, 59, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [48, 198, 177, 71, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [237, 198, 177, 154, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [81, 198, 177, 38, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [25, 198, 177, 110, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [82, 198, 177, 37, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [230, 198, 177, 145, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [97, 198, 177, 22, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [194, 198, 177, 181, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [220, 198, 177, 171, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [107, 198, 177, 28, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [54, 198, 177, 65, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [79, 198, 177, 56, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [57, 198, 177, 78, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [52, 198, 177, 67, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [7, 198, 177, 112, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [63, 198, 177, 72, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [233, 198, 177, 158, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [91, 198, 177, 44, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [44, 198, 177, 91, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [102, 198, 177, 17, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [8, 198, 177, 127, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [189, 198, 177, 202, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [173, 198, 177, 218, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [164, 198, 177, 211, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [108, 198, 177, 27, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [87, 198, 177, 32, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [175, 198, 177, 216, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [62, 198, 177, 73, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [126, 198, 177, 9, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [106, 198, 177, 29, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [234, 198, 177, 157, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [67, 198, 177, 52, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [170, 198, 177, 221, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [142, 198, 177, 249, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [159, 198, 177, 232, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [92, 198, 177, 43, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [184, 198, 177, 207, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [88, 198, 177, 47, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [131, 198, 177, 244, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [13, 198, 177, 122, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [158, 198, 177, 233, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [1, 198, 177, 118, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [156, 198, 177, 235, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [137, 198, 177, 254, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [27, 198, 177, 108, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [121, 198, 177, 14, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [112, 198, 177, 7, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [188, 198, 177, 203, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [41, 198, 177, 94, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [238, 198, 177, 153, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [146, 198, 177, 229, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [24, 198, 177, 111, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [183, 198, 177, 192, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [129, 198, 177, 246, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [128, 198, 177, 247, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [245, 198, 177, 130, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [193, 198, 177, 182, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [59, 198, 177, 76, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [201, 198, 177, 190, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [160, 198, 177, 215, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [77, 198, 177, 58, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [40, 198, 177, 95, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [178, 198, 177, 197, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [120, 198, 177, 15, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [180, 198, 177, 195, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [31, 198, 177, 104, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [200, 198, 177, 191, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [74, 198, 177, 61, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [155, 198, 177, 236, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [118, 198, 177, 1, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [187, 198, 177, 204, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [103, 198, 177, 16, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [42, 198, 177, 93, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [192, 198, 177, 183, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [241, 198, 177, 134, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [80, 198, 177, 39, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [37, 198, 177, 82, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [162, 198, 177, 213, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [209, 198, 177, 166, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [215, 198, 177, 160, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [195, 198, 177, 180, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [84, 198, 177, 35, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [75, 198, 177, 60, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [116, 198, 177, 3, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [49, 198, 177, 70, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [96, 198, 177, 23, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [216, 198, 177, 175, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [214, 198, 177, 161, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [168, 198, 177, 223, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [30, 198, 177, 105, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [222, 198, 177, 169, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [98, 198, 177, 21, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [153, 198, 177, 238, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [228, 198, 177, 147, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [203, 198, 177, 188, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [167, 198, 177, 208, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [4, 198, 177, 115, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [51, 198, 177, 68, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [202, 198, 177, 189, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [56, 198, 177, 79, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [219, 198, 177, 172, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [20, 198, 177, 99, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [9, 198, 177, 126, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [6, 198, 177, 113, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [163, 198, 177, 212, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [110, 198, 177, 25, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [39, 198, 177, 80, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [45, 198, 177, 90, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [65, 198, 177, 54, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [186, 198, 177, 205, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [139, 198, 177, 252, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [100, 198, 177, 19, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [104, 198, 177, 31, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [73, 198, 177, 62, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [86, 198, 177, 33, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [151, 198, 177, 224, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [136, 198, 177, 255, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [119, 198, 177, 0, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [196, 198, 177, 179, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [12, 198, 177, 123, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [223, 198, 177, 168, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [140, 198, 177, 251, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [95, 198, 177, 40, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [60, 198, 177, 75, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [229, 198, 177, 146, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [166, 198, 177, 209, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [255, 198, 177, 136, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [198, 198, 177, 177, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [130, 198, 177, 245, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [232, 198, 177, 159, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [251, 198, 177, 140, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [26, 198, 177, 109, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [212, 198, 177, 163, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [71, 198, 177, 48, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [185, 198, 177, 206, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [177, 198, 177, 198, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [11, 198, 177, 124, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [19, 198, 177, 100, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [221, 198, 177, 170, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [117, 198, 177, 2, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [35, 198, 177, 84, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [143, 198, 177, 248, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [69, 198, 177, 50, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [197, 198, 177, 178, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [144, 198, 177, 231, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [64, 198, 177, 55, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [123, 198, 177, 12, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [169, 198, 177, 222, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [161, 198, 177, 214, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [145, 198, 177, 230, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [210, 198, 177, 165, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [157, 198, 177, 234, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [191, 198, 177, 200, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [199, 198, 177, 176, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [89, 198, 177, 46, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [72, 198, 177, 63, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [55, 198, 177, 64, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [249, 198, 177, 142, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [10, 198, 177, 125, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [14, 198, 177, 121, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [127, 198, 177, 8, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [226, 198, 177, 149, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [124, 198, 177, 11, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [83, 198, 177, 36, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [172, 198, 177, 219, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [246, 198, 177, 129, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [22, 198, 177, 97, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [78, 198, 177, 57, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [213, 198, 177, 162, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [50, 198, 177, 69, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [247, 198, 177, 128, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [205, 198, 177, 186, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [111, 198, 177, 24, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [113, 198, 177, 6, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [254, 198, 177, 137, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [225, 198, 177, 150, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [53, 198, 177, 66, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [147, 198, 177, 228, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [33, 198, 177, 86, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [227, 198, 177, 148, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [190, 198, 177, 201, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [181, 198, 177, 194, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [135, 198, 177, 240, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [61, 198, 177, 74, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [47, 198, 177, 88, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [93, 198, 177, 42, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [115, 198, 177, 4, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [70, 198, 177, 49, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [239, 198, 177, 152, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [132, 198, 177, 243, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [208, 198, 177, 167, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [38, 198, 177, 81, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [16, 198, 177, 103, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [17, 198, 177, 102, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [235, 198, 177, 156, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [165, 198, 177, 210, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [46, 198, 177, 89, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [253, 198, 177, 138, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [211, 198, 177, 164, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [152, 198, 177, 239, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [109, 198, 177, 26, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [149, 198, 177, 226, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [250, 198, 177, 141, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [174, 198, 177, 217, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [204, 198, 177, 187, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [34, 198, 177, 85, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [29, 198, 177, 106, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [90, 198, 177, 45, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [134, 198, 177, 241, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [5, 198, 177, 114, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [122, 198, 177, 13, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [99, 198, 177, 20, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [3, 198, 177, 116, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [138, 198, 177, 253, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [242, 198, 177, 133, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [66, 198, 177, 53, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [21, 198, 177, 98, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [15, 198, 177, 120, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [0, 198, 177, 119, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [133, 198, 177, 242, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [28, 198, 177, 107, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [114, 198, 177, 5, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [85, 198, 177, 34, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [206, 198, 177, 185, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [179, 198, 177, 196, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [68, 198, 177, 51, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [23, 198, 177, 96, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [58, 198, 177, 77, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [18, 198, 177, 101, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [150, 198, 177, 225, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [36, 198, 177, 83, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [125, 198, 177, 10, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [217, 198, 177, 174, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [243, 198, 177, 132, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [218, 198, 177, 173, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [2, 198, 177, 117, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [182, 198, 177, 193, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [148, 198, 177, 227, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [43, 198, 177, 92, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [207, 198, 177, 184, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [32, 198, 177, 87, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254], [141, 198, 177, 250, 104, 209, 115, 202, 86, 130, 195, 23, 236, 8, 26, 254]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[147, 189, 217, 247, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [140, 189, 217, 232, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [135, 189, 217, 227, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [139, 189, 217, 239, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [2, 189, 217, 102, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [155, 189, 217, 255, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [159, 189, 217, 251, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [53, 189, 217, 81, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [192, 189, 217, 164, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [241, 189, 217, 149, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [151, 189, 217, 243, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [219, 189, 217, 191, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [14, 189, 217, 106, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [39, 189, 217, 67, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [91, 189, 217, 63, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [134, 189, 217, 226, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [58, 189, 217, 94, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [114, 189, 217, 22, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [57, 189, 217, 93, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [141, 189, 217, 233, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [10, 189, 217, 110, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [169, 189, 217, 205, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [183, 189, 217, 211, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [0, 189, 217, 100, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [93, 189, 217, 57, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [36, 189, 217, 64, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [82, 189, 217, 54, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [95, 189, 217, 59, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [108, 189, 217, 8, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [84, 189, 217, 48, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [130, 189, 217, 230, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [48, 189, 217, 84, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [71, 189, 217, 35, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [13, 189, 217, 105, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [99, 189, 217, 7, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [214, 189, 217, 178, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [198, 189, 217, 162, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [207, 189, 217, 171, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [7, 189, 217, 99, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [60, 189, 217, 88, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [196, 189, 217, 160, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [85, 189, 217, 49, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [21, 189, 217, 113, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [1, 189, 217, 101, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [129, 189, 217, 229, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [40, 189, 217, 76, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [193, 189, 217, 165, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [229, 189, 217, 129, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [244, 189, 217, 144, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [55, 189, 217, 83, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [211, 189, 217, 183, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [51, 189, 217, 87, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [232, 189, 217, 140, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [102, 189, 217, 2, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [245, 189, 217, 145, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [106, 189, 217, 14, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [247, 189, 217, 147, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [226, 189, 217, 134, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [112, 189, 217, 20, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [18, 189, 217, 118, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [27, 189, 217, 127, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [215, 189, 217, 179, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [66, 189, 217, 38, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [133, 189, 217, 225, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [249, 189, 217, 157, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [115, 189, 217, 23, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [220, 189, 217, 184, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [234, 189, 217, 142, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [235, 189, 217, 143, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [158, 189, 217, 250, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [170, 189, 217, 206, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [80, 189, 217, 52, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [162, 189, 217, 198, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [203, 189, 217, 175, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [38, 189, 217, 66, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [67, 189, 217, 39, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [217, 189, 217, 189, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [19, 189, 217, 119, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [223, 189, 217, 187, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [116, 189, 217, 16, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [163, 189, 217, 199, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [33, 189, 217, 69, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [240, 189, 217, 148, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [29, 189, 217, 121, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [208, 189, 217, 180, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [12, 189, 217, 104, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [65, 189, 217, 37, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [171, 189, 217, 207, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [154, 189, 217, 254, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [59, 189, 217, 95, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [78, 189, 217, 42, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [201, 189, 217, 173, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [186, 189, 217, 222, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [188, 189, 217, 216, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [168, 189, 217, 204, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [63, 189, 217, 91, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [32, 189, 217, 68, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [31, 189, 217, 123, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [90, 189, 217, 62, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [11, 189, 217, 111, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [179, 189, 217, 215, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [189, 189, 217, 217, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [195, 189, 217, 167, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [117, 189, 217, 17, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [181, 189, 217, 209, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [9, 189, 217, 109, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [242, 189, 217, 150, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [143, 189, 217, 235, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [160, 189, 217, 196, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [204, 189, 217, 168, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [111, 189, 217, 11, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [88, 189, 217, 60, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [161, 189, 217, 197, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [83, 189, 217, 55, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [176, 189, 217, 212, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [127, 189, 217, 27, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [98, 189, 217, 6, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [109, 189, 217, 9, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [200, 189, 217, 172, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [5, 189, 217, 97, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [76, 189, 217, 40, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [70, 189, 217, 34, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [42, 189, 217, 78, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [209, 189, 217, 181, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [224, 189, 217, 132, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [15, 189, 217, 107, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [3, 189, 217, 103, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [34, 189, 217, 70, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [61, 189, 217, 89, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [252, 189, 217, 152, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [227, 189, 217, 135, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [28, 189, 217, 120, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [175, 189, 217, 203, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [103, 189, 217, 3, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [180, 189, 217, 208, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [231, 189, 217, 131, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [52, 189, 217, 80, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [87, 189, 217, 51, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [142, 189, 217, 234, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [205, 189, 217, 169, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [148, 189, 217, 240, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [173, 189, 217, 201, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [233, 189, 217, 141, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [131, 189, 217, 231, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [144, 189, 217, 244, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [113, 189, 217, 21, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [191, 189, 217, 219, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [44, 189, 217, 72, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [210, 189, 217, 182, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [218, 189, 217, 190, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [96, 189, 217, 4, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [120, 189, 217, 28, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [182, 189, 217, 210, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [30, 189, 217, 122, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [72, 189, 217, 44, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [228, 189, 217, 128, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [46, 189, 217, 74, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [174, 189, 217, 202, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [251, 189, 217, 159, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [43, 189, 217, 79, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [16, 189, 217, 116, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [194, 189, 217, 166, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [202, 189, 217, 174, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [250, 189, 217, 158, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [185, 189, 217, 221, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [246, 189, 217, 146, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [212, 189, 217, 176, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [172, 189, 217, 200, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [50, 189, 217, 86, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [35, 189, 217, 71, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [92, 189, 217, 56, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [146, 189, 217, 246, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [97, 189, 217, 5, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [101, 189, 217, 1, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [20, 189, 217, 112, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [137, 189, 217, 237, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [23, 189, 217, 115, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [56, 189, 217, 92, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [199, 189, 217, 163, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [157, 189, 217, 249, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [125, 189, 217, 25, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [37, 189, 217, 65, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [190, 189, 217, 218, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [89, 189, 217, 61, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [156, 189, 217, 248, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [166, 189, 217, 194, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [4, 189, 217, 96, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [26, 189, 217, 126, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [149, 189, 217, 241, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [138, 189, 217, 238, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [94, 189, 217, 58, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [248, 189, 217, 156, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [74, 189, 217, 46, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [136, 189, 217, 236, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [213, 189, 217, 177, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [222, 189, 217, 186, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [236, 189, 217, 136, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [86, 189, 217, 50, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [68, 189, 217, 32, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [54, 189, 217, 82, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [24, 189, 217, 124, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [45, 189, 217, 73, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [132, 189, 217, 224, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [239, 189, 217, 139, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [187, 189, 217, 223, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [77, 189, 217, 41, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [123, 189, 217, 31, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [122, 189, 217, 30, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [128, 189, 217, 228, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [206, 189, 217, 170, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [69, 189, 217, 33, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [150, 189, 217, 242, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [184, 189, 217, 220, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [243, 189, 217, 151, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [6, 189, 217, 98, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [254, 189, 217, 154, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [145, 189, 217, 245, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [197, 189, 217, 161, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [167, 189, 217, 195, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [73, 189, 217, 45, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [118, 189, 217, 18, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [49, 189, 217, 85, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [237, 189, 217, 137, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [110, 189, 217, 10, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [17, 189, 217, 117, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [8, 189, 217, 108, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [104, 189, 217, 12, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [225, 189, 217, 133, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [153, 189, 217, 253, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [41, 189, 217, 77, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [126, 189, 217, 26, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [100, 189, 217, 0, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [107, 189, 217, 15, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [238, 189, 217, 138, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [119, 189, 217, 19, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [25, 189, 217, 125, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [62, 189, 217, 90, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [165, 189, 217, 193, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [216, 189, 217, 188, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [47, 189, 217, 75, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [124, 189, 217, 24, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [81, 189, 217, 53, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [121, 189, 217, 29, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [253, 189, 217, 153, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [79, 189, 217, 43, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [22, 189, 217, 114, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [178, 189, 217, 214, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [152, 189, 217, 252, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [177, 189, 217, 213, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [105, 189, 217, 13, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [221, 189, 217, 185, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [255, 189, 217, 155, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [64, 189, 217, 36, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [164, 189, 217, 192, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [75, 189, 217, 47, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91], [230, 189, 217, 130, 186, 78, 140, 120, 192, 104, 55, 159, 131, 77, 149, 91]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[242, 15, 194, 63, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [237, 15, 194, 32, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [230, 15, 194, 43, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [234, 15, 194, 39, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [99, 15, 194, 174, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [250, 15, 194, 55, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [254, 15, 194, 51, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [84, 15, 194, 153, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [161, 15, 194, 108, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [144, 15, 194, 93, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [246, 15, 194, 59, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [186, 15, 194, 119, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [111, 15, 194, 162, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [70, 15, 194, 139, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [58, 15, 194, 247, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [231, 15, 194, 42, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [91, 15, 194, 150, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [19, 15, 194, 222, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [88, 15, 194, 149, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [236, 15, 194, 33, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [107, 15, 194, 166, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [200, 15, 194, 5, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [214, 15, 194, 27, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [97, 15, 194, 172, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [60, 15, 194, 241, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [69, 15, 194, 136, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [51, 15, 194, 254, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [62, 15, 194, 243, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [13, 15, 194, 192, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [53, 15, 194, 248, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [227, 15, 194, 46, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [81, 15, 194, 156, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [38, 15, 194, 235, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [108, 15, 194, 161, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [2, 15, 194, 207, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [183, 15, 194, 122, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [167, 15, 194, 106, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [174, 15, 194, 99, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [102, 15, 194, 171, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [93, 15, 194, 144, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [165, 15, 194, 104, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [52, 15, 194, 249, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [116, 15, 194, 185, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [96, 15, 194, 173, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [224, 15, 194, 45, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [73, 15, 194, 132, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [160, 15, 194, 109, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [132, 15, 194, 73, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [149, 15, 194, 88, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [86, 15, 194, 155, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [178, 15, 194, 127, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [82, 15, 194, 159, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [137, 15, 194, 68, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [7, 15, 194, 202, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [148, 15, 194, 89, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [11, 15, 194, 198, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [150, 15, 194, 91, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [131, 15, 194, 78, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [17, 15, 194, 220, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [115, 15, 194, 190, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [122, 15, 194, 183, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [182, 15, 194, 123, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [35, 15, 194, 238, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [228, 15, 194, 41, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [152, 15, 194, 85, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [18, 15, 194, 223, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [189, 15, 194, 112, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [139, 15, 194, 70, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [138, 15, 194, 71, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [255, 15, 194, 50, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [203, 15, 194, 6, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [49, 15, 194, 252, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [195, 15, 194, 14, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [170, 15, 194, 103, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [71, 15, 194, 138, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [34, 15, 194, 239, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [184, 15, 194, 117, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [114, 15, 194, 191, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [190, 15, 194, 115, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [21, 15, 194, 216, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [194, 15, 194, 15, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [64, 15, 194, 141, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [145, 15, 194, 92, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [124, 15, 194, 177, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [177, 15, 194, 124, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [109, 15, 194, 160, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [32, 15, 194, 237, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [202, 15, 194, 7, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [251, 15, 194, 54, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [90, 15, 194, 151, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [47, 15, 194, 226, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [168, 15, 194, 101, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [219, 15, 194, 22, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [221, 15, 194, 16, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [201, 15, 194, 4, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [94, 15, 194, 147, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [65, 15, 194, 140, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [126, 15, 194, 179, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [59, 15, 194, 246, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [106, 15, 194, 167, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [210, 15, 194, 31, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [220, 15, 194, 17, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [162, 15, 194, 111, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [20, 15, 194, 217, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [212, 15, 194, 25, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [104, 15, 194, 165, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [147, 15, 194, 94, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [238, 15, 194, 35, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [193, 15, 194, 12, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [173, 15, 194, 96, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [14, 15, 194, 195, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [57, 15, 194, 244, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [192, 15, 194, 13, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [50, 15, 194, 255, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [209, 15, 194, 28, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [30, 15, 194, 211, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [3, 15, 194, 206, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [12, 15, 194, 193, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [169, 15, 194, 100, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [100, 15, 194, 169, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [45, 15, 194, 224, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [39, 15, 194, 234, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [75, 15, 194, 134, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [176, 15, 194, 125, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [129, 15, 194, 76, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [110, 15, 194, 163, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [98, 15, 194, 175, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [67, 15, 194, 142, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [92, 15, 194, 145, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [157, 15, 194, 80, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [130, 15, 194, 79, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [125, 15, 194, 176, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [206, 15, 194, 3, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [6, 15, 194, 203, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [213, 15, 194, 24, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [134, 15, 194, 75, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [85, 15, 194, 152, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [54, 15, 194, 251, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [239, 15, 194, 34, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [172, 15, 194, 97, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [245, 15, 194, 56, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [204, 15, 194, 1, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [136, 15, 194, 69, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [226, 15, 194, 47, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [241, 15, 194, 60, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [16, 15, 194, 221, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [222, 15, 194, 19, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [77, 15, 194, 128, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [179, 15, 194, 126, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [187, 15, 194, 118, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [1, 15, 194, 204, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [25, 15, 194, 212, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [215, 15, 194, 26, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [127, 15, 194, 178, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [41, 15, 194, 228, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [133, 15, 194, 72, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [79, 15, 194, 130, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [207, 15, 194, 2, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [154, 15, 194, 87, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [74, 15, 194, 135, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [113, 15, 194, 188, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [163, 15, 194, 110, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [171, 15, 194, 102, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [155, 15, 194, 86, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [216, 15, 194, 21, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [151, 15, 194, 90, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [181, 15, 194, 120, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [205, 15, 194, 0, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [83, 15, 194, 158, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [66, 15, 194, 143, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [61, 15, 194, 240, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [243, 15, 194, 62, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [0, 15, 194, 205, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [4, 15, 194, 201, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [117, 15, 194, 184, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [232, 15, 194, 37, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [118, 15, 194, 187, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [89, 15, 194, 148, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [166, 15, 194, 107, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [252, 15, 194, 49, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [28, 15, 194, 209, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [68, 15, 194, 137, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [223, 15, 194, 18, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [56, 15, 194, 245, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [253, 15, 194, 48, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [199, 15, 194, 10, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [101, 15, 194, 168, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [123, 15, 194, 182, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [244, 15, 194, 57, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [235, 15, 194, 38, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [63, 15, 194, 242, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [153, 15, 194, 84, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [43, 15, 194, 230, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [233, 15, 194, 36, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [180, 15, 194, 121, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [191, 15, 194, 114, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [141, 15, 194, 64, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [55, 15, 194, 250, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [37, 15, 194, 232, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [87, 15, 194, 154, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [121, 15, 194, 180, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [76, 15, 194, 129, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [229, 15, 194, 40, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [142, 15, 194, 67, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [218, 15, 194, 23, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [44, 15, 194, 225, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [26, 15, 194, 215, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [27, 15, 194, 214, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [225, 15, 194, 44, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [175, 15, 194, 98, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [36, 15, 194, 233, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [247, 15, 194, 58, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [217, 15, 194, 20, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [146, 15, 194, 95, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [103, 15, 194, 170, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [159, 15, 194, 82, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [240, 15, 194, 61, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [164, 15, 194, 105, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [198, 15, 194, 11, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [40, 15, 194, 229, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [23, 15, 194, 218, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [80, 15, 194, 157, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [140, 15, 194, 65, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [15, 15, 194, 194, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [112, 15, 194, 189, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [105, 15, 194, 164, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [9, 15, 194, 196, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [128, 15, 194, 77, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [248, 15, 194, 53, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [72, 15, 194, 133, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [31, 15, 194, 210, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [5, 15, 194, 200, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [10, 15, 194, 199, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [143, 15, 194, 66, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [22, 15, 194, 219, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [120, 15, 194, 181, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [95, 15, 194, 146, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [196, 15, 194, 9, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [185, 15, 194, 116, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [78, 15, 194, 131, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [29, 15, 194, 208, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [48, 15, 194, 253, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [24, 15, 194, 213, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [156, 15, 194, 81, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [46, 15, 194, 227, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [119, 15, 194, 186, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [211, 15, 194, 30, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [249, 15, 194, 52, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [208, 15, 194, 29, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [8, 15, 194, 197, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [188, 15, 194, 113, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [158, 15, 194, 83, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [33, 15, 194, 236, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [197, 15, 194, 8, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [42, 15, 194, 231, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53], [135, 15, 194, 74, 8, 154, 212, 70, 116, 176, 240, 52, 41, 31, 3, 53]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted 256 plaintext blocks using a simplified 1-round AES:\n\n- Only the **first byte** of each plaintext varies (from 0x00 to 0xFF)\n- Other plaintext bytes are all 0x00\n- AES round includes: `AddRoundKey → SubBytes → ShiftRows → MixColumns`\n\nYou are given all 256 ciphertexts.\nUse an **integral attack** to recover **key[0]**.\nOutput format: `PCTF{XX}`",
    "rationale": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = [[28, 217, 172, 105, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [3, 217, 172, 118, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [8, 217, 172, 125, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [4, 217, 172, 113, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [141, 217, 172, 248, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [20, 217, 172, 97, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [16, 217, 172, 101, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [186, 217, 172, 207, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [79, 217, 172, 58, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [126, 217, 172, 11, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [24, 217, 172, 109, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [84, 217, 172, 33, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [129, 217, 172, 244, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [168, 217, 172, 221, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [212, 217, 172, 161, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [9, 217, 172, 124, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [181, 217, 172, 192, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [253, 217, 172, 136, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [182, 217, 172, 195, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [2, 217, 172, 119, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [133, 217, 172, 240, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [38, 217, 172, 83, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [56, 217, 172, 77, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [143, 217, 172, 250, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [210, 217, 172, 167, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [171, 217, 172, 222, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [221, 217, 172, 168, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [208, 217, 172, 165, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [227, 217, 172, 150, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [219, 217, 172, 174, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [13, 217, 172, 120, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [191, 217, 172, 202, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [200, 217, 172, 189, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [130, 217, 172, 247, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [236, 217, 172, 153, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [89, 217, 172, 44, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [73, 217, 172, 60, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [64, 217, 172, 53, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [136, 217, 172, 253, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [179, 217, 172, 198, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [75, 217, 172, 62, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [218, 217, 172, 175, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [154, 217, 172, 239, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [142, 217, 172, 251, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [14, 217, 172, 123, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [167, 217, 172, 210, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [78, 217, 172, 59, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [106, 217, 172, 31, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [123, 217, 172, 14, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [184, 217, 172, 205, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [92, 217, 172, 41, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [188, 217, 172, 201, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [103, 217, 172, 18, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [233, 217, 172, 156, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [122, 217, 172, 15, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [229, 217, 172, 144, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [120, 217, 172, 13, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [109, 217, 172, 24, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [255, 217, 172, 138, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [157, 217, 172, 232, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [148, 217, 172, 225, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [88, 217, 172, 45, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [205, 217, 172, 184, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [10, 217, 172, 127, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [118, 217, 172, 3, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [252, 217, 172, 137, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [83, 217, 172, 38, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [101, 217, 172, 16, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [100, 217, 172, 17, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [17, 217, 172, 100, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [37, 217, 172, 80, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [223, 217, 172, 170, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [45, 217, 172, 88, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [68, 217, 172, 49, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [169, 217, 172, 220, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [204, 217, 172, 185, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [86, 217, 172, 35, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [156, 217, 172, 233, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [80, 217, 172, 37, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [251, 217, 172, 142, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [44, 217, 172, 89, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [174, 217, 172, 219, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [127, 217, 172, 10, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [146, 217, 172, 231, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [95, 217, 172, 42, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [131, 217, 172, 246, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [206, 217, 172, 187, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [36, 217, 172, 81, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [21, 217, 172, 96, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [180, 217, 172, 193, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [193, 217, 172, 180, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [70, 217, 172, 51, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [53, 217, 172, 64, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [51, 217, 172, 70, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [39, 217, 172, 82, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [176, 217, 172, 197, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [175, 217, 172, 218, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [144, 217, 172, 229, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [213, 217, 172, 160, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [132, 217, 172, 241, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [60, 217, 172, 73, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [50, 217, 172, 71, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [76, 217, 172, 57, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [250, 217, 172, 143, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [58, 217, 172, 79, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [134, 217, 172, 243, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [125, 217, 172, 8, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [0, 217, 172, 117, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [47, 217, 172, 90, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [67, 217, 172, 54, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [224, 217, 172, 149, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [215, 217, 172, 162, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [46, 217, 172, 91, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [220, 217, 172, 169, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [63, 217, 172, 74, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [240, 217, 172, 133, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [237, 217, 172, 152, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [226, 217, 172, 151, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [71, 217, 172, 50, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [138, 217, 172, 255, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [195, 217, 172, 182, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [201, 217, 172, 188, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [165, 217, 172, 208, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [94, 217, 172, 43, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [111, 217, 172, 26, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [128, 217, 172, 245, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [140, 217, 172, 249, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [173, 217, 172, 216, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [178, 217, 172, 199, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [115, 217, 172, 6, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [108, 217, 172, 25, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [147, 217, 172, 230, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [32, 217, 172, 85, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [232, 217, 172, 157, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [59, 217, 172, 78, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [104, 217, 172, 29, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [187, 217, 172, 206, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [216, 217, 172, 173, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [1, 217, 172, 116, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [66, 217, 172, 55, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [27, 217, 172, 110, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [34, 217, 172, 87, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [102, 217, 172, 19, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [12, 217, 172, 121, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [31, 217, 172, 106, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [254, 217, 172, 139, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [48, 217, 172, 69, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [163, 217, 172, 214, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [93, 217, 172, 40, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [85, 217, 172, 32, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [239, 217, 172, 154, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [247, 217, 172, 130, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [57, 217, 172, 76, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [145, 217, 172, 228, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [199, 217, 172, 178, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [107, 217, 172, 30, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [161, 217, 172, 212, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [33, 217, 172, 84, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [116, 217, 172, 1, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [164, 217, 172, 209, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [159, 217, 172, 234, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [77, 217, 172, 56, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [69, 217, 172, 48, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [117, 217, 172, 0, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [54, 217, 172, 67, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [121, 217, 172, 12, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [91, 217, 172, 46, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [35, 217, 172, 86, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [189, 217, 172, 200, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [172, 217, 172, 217, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [211, 217, 172, 166, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [29, 217, 172, 104, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [238, 217, 172, 155, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [234, 217, 172, 159, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [155, 217, 172, 238, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [6, 217, 172, 115, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [152, 217, 172, 237, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [183, 217, 172, 194, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [72, 217, 172, 61, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [18, 217, 172, 103, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [242, 217, 172, 135, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [170, 217, 172, 223, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [49, 217, 172, 68, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [214, 217, 172, 163, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [19, 217, 172, 102, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [41, 217, 172, 92, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [139, 217, 172, 254, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [149, 217, 172, 224, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [26, 217, 172, 111, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [5, 217, 172, 112, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [209, 217, 172, 164, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [119, 217, 172, 2, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [197, 217, 172, 176, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [7, 217, 172, 114, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [90, 217, 172, 47, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [81, 217, 172, 36, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [99, 217, 172, 22, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [217, 217, 172, 172, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [203, 217, 172, 190, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [185, 217, 172, 204, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [151, 217, 172, 226, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [162, 217, 172, 215, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [11, 217, 172, 126, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [96, 217, 172, 21, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [52, 217, 172, 65, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [194, 217, 172, 183, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [244, 217, 172, 129, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [245, 217, 172, 128, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [15, 217, 172, 122, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [65, 217, 172, 52, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [202, 217, 172, 191, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [25, 217, 172, 108, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [55, 217, 172, 66, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [124, 217, 172, 9, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [137, 217, 172, 252, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [113, 217, 172, 4, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [30, 217, 172, 107, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [74, 217, 172, 63, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [40, 217, 172, 93, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [198, 217, 172, 179, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [249, 217, 172, 140, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [190, 217, 172, 203, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [98, 217, 172, 23, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [225, 217, 172, 148, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [158, 217, 172, 235, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [135, 217, 172, 242, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [231, 217, 172, 146, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [110, 217, 172, 27, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [22, 217, 172, 99, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [166, 217, 172, 211, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [241, 217, 172, 132, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [235, 217, 172, 158, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [228, 217, 172, 145, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [97, 217, 172, 20, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [248, 217, 172, 141, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [150, 217, 172, 227, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [177, 217, 172, 196, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [42, 217, 172, 95, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [87, 217, 172, 34, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [160, 217, 172, 213, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [243, 217, 172, 134, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [222, 217, 172, 171, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [246, 217, 172, 131, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [114, 217, 172, 7, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [192, 217, 172, 181, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [153, 217, 172, 236, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [61, 217, 172, 72, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [23, 217, 172, 98, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [62, 217, 172, 75, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [230, 217, 172, 147, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [82, 217, 172, 39, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [112, 217, 172, 5, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [207, 217, 172, 186, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [43, 217, 172, 94, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [196, 217, 172, 177, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16], [105, 217, 172, 28, 250, 125, 129, 6, 213, 87, 234, 104, 164, 219, 111, 16]]\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
    "final_answer": "PCTF{00}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "AES_IntegralMedium",
      "change_detail": "Recover AES key[0] from 1-round AES using integral attack.",
      "synthesis_code": "def xor_all(cts):\n    acc = [0] * 16\n    for c in cts:\n        for i in range(16):\n            acc[i] ^= c[i]\n    return acc\n\ncts = __CIPHERTEXTS__\n\nacc = xor_all(cts)\nprint(f\"PCTF{{{acc[0]:02X}}}\")\n",
      "original_data": {
        "key_byte": 0
      },
      "difficulty": "medium",
      "compute": "1",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x47fa, 0x21d1)\n(0x4ecf, 0xf762)\n(0xae54, 0x2cc8)\n(0xec9d, 0x6359)\n(0xb6b1, 0x5e57)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(18426, 8657), (20175, 63330), (44628, 11464), (60573, 25433), (46769, 24151)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{0591}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "0591",
        "plaintext": "PCTF{0591}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x38ce, 0xd0b)\n(0x6763, 0xb169)\n(0x6d3e, 0x861a)\n(0xcbff, 0x32e0)\n(0x532d, 0xc462)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(14542, 3339), (26467, 45417), (27966, 34330), (52223, 13024), (21293, 50274)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{C8C5}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "C8C5",
        "plaintext": "PCTF{C8C5}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x7dc0, 0xfd08)\n(0x7386, 0xa5a6)\n(0x8a0d, 0x4f75)\n(0xd7c2, 0xab19)\n(0xe208, 0x6713)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(32192, 64776), (29574, 42406), (35341, 20341), (55234, 43801), (57864, 26387)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{10AC}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "10AC",
        "plaintext": "PCTF{10AC}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x190b, 0x5978)\n(0x19d, 0xab9b)\n(0xa22c, 0x7887)\n(0x37ec, 0x2340)\n(0x3242, 0x96a)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(6411, 22904), (413, 43931), (41516, 30855), (14316, 9024), (12866, 2410)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{15E6}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "15E6",
        "plaintext": "PCTF{15E6}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x7430, 0x2ad9)\n(0x3863, 0xcc14)\n(0x7cd6, 0x64f7)\n(0x1c07, 0x8389)\n(0x5b02, 0x4a7a)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(29744, 10969), (14435, 52244), (31958, 25847), (7175, 33673), (23298, 19066)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{3F0C}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "3F0C",
        "plaintext": "PCTF{3F0C}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0xf767, 0x2233)\n(0x1764, 0x421d)\n(0xb230, 0xab4)\n(0xc161, 0x9c03)\n(0x3a0f, 0x51d9)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(63335, 8755), (5988, 16925), (45616, 2740), (49505, 39939), (14863, 20953)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{BA9F}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "BA9F",
        "plaintext": "PCTF{BA9F}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0xe264, 0x5cfa)\n(0x3cd7, 0xcec2)\n(0x47dc, 0xaba7)\n(0x1cd, 0xb00e)\n(0x1433, 0x5344)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(57956, 23802), (15575, 52930), (18396, 43943), (461, 45070), (5171, 21316)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{850D}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "850D",
        "plaintext": "PCTF{850D}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x9df3, 0x700d)\n(0x626, 0xdaf7)\n(0x33b8, 0x389b)\n(0x5f36, 0x3b62)\n(0x8a22, 0xc6d4)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(40435, 28685), (1574, 56055), (13240, 14491), (24374, 15202), (35362, 50900)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{36A0}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "36A0",
        "plaintext": "PCTF{36A0}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x5d61, 0x6bda)\n(0x824, 0x2fb)\n(0xf8be, 0xea52)\n(0xe0f7, 0x3065)\n(0x81ed, 0xdaec)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(23905, 27610), (2084, 763), (63678, 59986), (57591, 12389), (33261, 56044)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{414D}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "414D",
        "plaintext": "PCTF{414D}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 16-bit plaintexts using a simplified ARX cipher:\n\n```python\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= ((m << 3) | (m >> 13)) & 0xFFFF\n    return m\n```\n\nYou are given the following (plaintext, ciphertext) pairs:\n\n(0x668f, 0x831f)\n(0xbd29, 0x2eca)\n(0x5910, 0x21e8)\n(0x92dc, 0xcdd5)\n(0x8c4a, 0x88f3)\n\nRecover the 16-bit key used. Submit your answer as `PCTF{XXXX}`.",
    "rationale": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = [(26255, 33567), (48425, 11978), (22800, 8680), (37596, 52693), (35914, 35059)]\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
    "final_answer": "PCTF{AB98}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "LiteARX_KeyRecovery",
      "change_detail": "This challenge demonstrates how to recover a 16-bit key used in a lightweight ARX cipher.",
      "synthesis_code": "def rotate_left(x, n, bits=16):\n    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)\n\ndef arx_encrypt(m, key):\n    m = (m + key) & 0xFFFF\n    m ^= rotate_left(m, 3)\n    return m\n\npairs = __PAIRS__\n\n# 暴力破解 16-bit key\nfor guess in range(0x0000, 0x10000):\n    match = True\n    for m, c in pairs:\n        if arx_encrypt(m, guess) != c:\n            match = False\n            break\n    if match:\n        print(f\"PCTF{{{guess:04X}}}\")\n        break\n",
      "compute": "1",
      "original_data": {
        "key_hex": "AB98",
        "plaintext": "PCTF{AB98}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 1073741824, and the following public key:\np = \"597417177528107\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 597417177528107\ng = 2\nciphertext = 1073741824\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{30}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "30",
        "ciphertext": 1073741824,
        "p": 597417177528107,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 522838398782710, and the following public key:\np = \"997190776027939\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 997190776027939\ng = 2\nciphertext = 522838398782710\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{195}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "195",
        "ciphertext": 522838398782710,
        "p": 997190776027939,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 398435734058820, and the following public key:\np = \"699763098988717\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 699763098988717\ng = 2\nciphertext = 398435734058820\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{145}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "145",
        "ciphertext": 398435734058820,
        "p": 699763098988717,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 469582413155317, and the following public key:\np = \"960593370374233\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 960593370374233\ng = 2\nciphertext = 469582413155317\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{64}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "64",
        "ciphertext": 469582413155317,
        "p": 960593370374233,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 59442630689233, and the following public key:\np = \"210354519559601\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 210354519559601\ng = 2\nciphertext = 59442630689233\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{232}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "232",
        "ciphertext": 59442630689233,
        "p": 210354519559601,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 538981136445048, and the following public key:\np = \"959004578835577\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 959004578835577\ng = 2\nciphertext = 538981136445048\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{386}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "386",
        "ciphertext": 538981136445048,
        "p": 959004578835577,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 492873949061185, and the following public key:\np = \"636543371703391\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 636543371703391\ng = 2\nciphertext = 492873949061185\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{292}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "292",
        "ciphertext": 492873949061185,
        "p": 636543371703391,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 299238808682422, and the following public key:\np = \"330747303755191\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 330747303755191\ng = 2\nciphertext = 299238808682422\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{137}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "137",
        "ciphertext": 299238808682422,
        "p": 330747303755191,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 258713962910620, and the following public key:\np = \"714266928798209\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 714266928798209\ng = 2\nciphertext = 258713962910620\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{216}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "216",
        "ciphertext": 258713962910620,
        "p": 714266928798209,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using DISCRETE_LOG: 259294879266047, and the following public key:\np = \"845567044451359\", g = \"2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\np = 845567044451359\ng = 2\nciphertext = 259294879266047\n\nfor x in range(p):\n    if pow(g, x, p) == ciphertext:\n        plaintext = str(x)\n        print(f'PCTF{{{plaintext}}}')\n        break\n",
    "final_answer": "PCTF{66}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG",
      "change_detail": "Use p and g to decrypt the ciphertext.",
      "synthesis_code": "\np = {p}\ng = {g}\nplaintext = {plaintext}\nx = int(plaintext)\n\nciphertext = pow(g, x, p)\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "66",
        "ciphertext": 259294879266047,
        "p": 845567044451359,
        "g": 2,
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 0x + 3 defined over the finite field modulo 9739,\nwith generator point G = (9102, 238), and a point P = ((, 1) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (9102, 238)\ntarget_P = (1702, 3971)\np = 9739\na = 0\nb = 3\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{70}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 9739,
        "a": 0,
        "b": 3,
        "G": [
          9102,
          238
        ],
        "plaintext": "70",
        "ciphertext": "(1702, 3971)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 6x + 7 defined over the finite field modulo 3851,\nwith generator point G = (1808, 1021), and a point P = ((, 5) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (1808, 1021)\ntarget_P = (533, 2614)\np = 3851\na = 6\nb = 7\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{19}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 3851,
        "a": 6,
        "b": 7,
        "G": [
          1808,
          1021
        ],
        "plaintext": "19",
        "ciphertext": "(533, 2614)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 10x + 1 defined over the finite field modulo 3851,\nwith generator point G = (3114, 9), and a point P = ((, 1) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (3114, 9)\ntarget_P = (1668, 3363)\np = 3851\na = 10\nb = 1\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{27}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 3851,
        "a": 10,
        "b": 1,
        "G": [
          3114,
          9
        ],
        "plaintext": "27",
        "ciphertext": "(1668, 3363)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 9x + 1 defined over the finite field modulo 9739,\nwith generator point G = (7987, 2321), and a point P = ((, 6) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (7987, 2321)\ntarget_P = (6721, 577)\np = 9739\na = 9\nb = 1\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{50}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 9739,
        "a": 9,
        "b": 1,
        "G": [
          7987,
          2321
        ],
        "plaintext": "50",
        "ciphertext": "(6721, 577)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 1x + 7 defined over the finite field modulo 3851,\nwith generator point G = (715, 156), and a point P = ((, 1) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (715, 156)\ntarget_P = (11, 3402)\np = 3851\na = 1\nb = 7\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{50}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 3851,
        "a": 1,
        "b": 7,
        "G": [
          715,
          156
        ],
        "plaintext": "50",
        "ciphertext": "(11, 3402)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 7x + 9 defined over the finite field modulo 6271,\nwith generator point G = (3850, 1214), and a point P = ((, 4) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (3850, 1214)\ntarget_P = (4570, 3660)\np = 6271\na = 7\nb = 9\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{94}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 6271,
        "a": 7,
        "b": 9,
        "G": [
          3850,
          1214
        ],
        "plaintext": "94",
        "ciphertext": "(4570, 3660)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 2x + 1 defined over the finite field modulo 7919,\nwith generator point G = (3187, 1894), and a point P = ((, 3) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (3187, 1894)\ntarget_P = (344, 1720)\np = 7919\na = 2\nb = 1\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{12}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 7919,
        "a": 2,
        "b": 1,
        "G": [
          3187,
          1894
        ],
        "plaintext": "12",
        "ciphertext": "(344, 1720)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 2x + 9 defined over the finite field modulo 3851,\nwith generator point G = (3681, 497), and a point P = ((, 1) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (3681, 497)\ntarget_P = (1566, 1481)\np = 3851\na = 2\nb = 9\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{15}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 3851,
        "a": 2,
        "b": 9,
        "G": [
          3681,
          497
        ],
        "plaintext": "15",
        "ciphertext": "(1566, 1481)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 0x + 2 defined over the finite field modulo 6271,\nwith generator point G = (4877, 1471), and a point P = ((, 5) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (4877, 1471)\ntarget_P = (5513, 2328)\np = 6271\na = 0\nb = 2\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{82}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 6271,
        "a": 0,
        "b": 2,
        "G": [
          4877,
          1471
        ],
        "plaintext": "82",
        "ciphertext": "(5513, 2328)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the elliptic curve E: y² = x³ + 1x + 7 defined over the finite field modulo 6271,\nwith generator point G = (637, 1555), and a point P = ((, 2) which is a multiple of G.\n\nFind the smallest positive integer m such that P = mG.\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\nG = (637, 1555)\ntarget_P = (2165, 3881)\np = 6271\na = 1\nb = 7\n\nR = G\nfor i in range(1, 10000):\n    if R == target_P:\n        plaintext = str(i)\n        print(f'PCTF{{{plaintext}}}')\n        break\n    R = point_add(R, G)\n",
    "final_answer": "PCTF{43}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "DISCRETE_LOG_ECC",
      "change_detail": "The private key is recovered by solving the elliptic curve discrete logarithm problem over a small finite field using brute-force.",
      "synthesis_code": "\ndef inverse_mod(k, p):\n    return pow(k, -1, p)\n\ndef point_add(P, Q):\n    if P is None: return Q\n    if Q is None: return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and y1 != y2:\n        return None\n    if P == Q:\n        m = (3 * x1**2 + a) * inverse_mod(2 * y1, p) % p\n    else:\n        m = (y2 - y1) * inverse_mod(x2 - x1, p) % p\n    x3 = (m**2 - x1 - x2) % p\n    y3 = (m * (x1 - x3) - y1) % p\n    return (x3, y3)\n\np = {p}\na = {a}\nb = {b}\n\nG = ({Gx}, {Gy})\nm = int({plaintext})\nP = G\nfor _ in range(m - 1):\n    P = point_add(P, G)\n\nciphertext = str(P)\n\nprint(\"ciphertext:\", ciphertext)\n",
      "original_data": {
        "p": 6271,
        "a": 1,
        "b": 7,
        "G": [
          637,
          1555
        ],
        "plaintext": "43",
        "ciphertext": "(2165, 3881)",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message using RSA.\nUnfortunately, her private key `d` was too small.\n\nn = 6979835347697856367377858694732049082047740558118558496377418500989005906482873360261217472995594957946596228605327831234868284131508456416227302264750887\ne = 4600309267558424655260280369599078243669756274536457445039193111271084036495169009157081496558482201329867829658532006045110645473263919432108737007879669\nc = 6899646512386223043138441998987966501862376160975162325308840720985364141461810347856369384464538793695087302402656328666269919936186275708160688204817490\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\n\nn = 6979835347697856367377858694732049082047740558118558496377418500989005906482873360261217472995594957946596228605327831234868284131508456416227302264750887\ne = 4600309267558424655260280369599078243669756274536457445039193111271084036495169009157081496558482201329867829658532006045110645473263919432108737007879669\nc = 6899646512386223043138441998987966501862376160975162325308840720985364141461810347856369384464538793695087302402656328666269919936186275708160688204817490\n\nfor d in range(1, 2**20):\n    m = pow(c, d, n)\n    try:\n        plaintext = long_to_bytes(m).decode()\n        if plaintext.startswith(\"PCTF{\"):\n            print(plaintext)\n            break\n    except:\n        continue\n",
    "final_answer": "PCTF{0xgd5n}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_d_Bruteforce",
      "change_detail": "This challenge demonstrates RSA decryption when private key d is too small.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\n\nn = {n}\ne = {e}\nc = {c}\n\nfor d in range(1, 2**20):\n    m = pow(c, d, n)\n    try:\n        plaintext = long_to_bytes(m).decode()\n        if plaintext.startswith(\"PCTF{{\"):\n            print(plaintext)\n            break\n    except:\n        continue\n",
      "compute": "5",
      "original_data": {
        "n": 6979835347697856367377858694732049082047740558118558496377418500989005906482873360261217472995594957946596228605327831234868284131508456416227302264750887,
        "e": 4600309267558424655260280369599078243669756274536457445039193111271084036495169009157081496558482201329867829658532006045110645473263919432108737007879669,
        "ciphertext": 6899646512386223043138441998987966501862376160975162325308840720985364141461810347856369384464538793695087302402656328666269919936186275708160688204817490,
        "plaintext": "PCTF{0xgd5n}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message using RSA.\nUnfortunately, her private key `d` was too small.\n\nn = 3831745072887248529665937129241683173094673281628071000400300200192562638349640235154756649182043805837076540201112628224488315829525883520263455964795833\ne = 2840127687476894621591510429926821531434124589850655251810645955848822557478160052199641471892656550601562316948890144885031009621840903245719004011364727\nc = 1621497733755920743214070216863865116584939448848240208335043446919415874874658474205735277591628003589572625445130929253754833916990521803302886949280837\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\n\nn = 3831745072887248529665937129241683173094673281628071000400300200192562638349640235154756649182043805837076540201112628224488315829525883520263455964795833\ne = 2840127687476894621591510429926821531434124589850655251810645955848822557478160052199641471892656550601562316948890144885031009621840903245719004011364727\nc = 1621497733755920743214070216863865116584939448848240208335043446919415874874658474205735277591628003589572625445130929253754833916990521803302886949280837\n\nfor d in range(1, 2**20):\n    m = pow(c, d, n)\n    try:\n        plaintext = long_to_bytes(m).decode()\n        if plaintext.startswith(\"PCTF{\"):\n            print(plaintext)\n            break\n    except:\n        continue\n",
    "final_answer": "PCTF{ejc0qs}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_d_Bruteforce",
      "change_detail": "This challenge demonstrates RSA decryption when private key d is too small.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\n\nn = {n}\ne = {e}\nc = {c}\n\nfor d in range(1, 2**20):\n    m = pow(c, d, n)\n    try:\n        plaintext = long_to_bytes(m).decode()\n        if plaintext.startswith(\"PCTF{{\"):\n            print(plaintext)\n            break\n    except:\n        continue\n",
      "compute": "5",
      "original_data": {
        "n": 3831745072887248529665937129241683173094673281628071000400300200192562638349640235154756649182043805837076540201112628224488315829525883520263455964795833,
        "e": 2840127687476894621591510429926821531434124589850655251810645955848822557478160052199641471892656550601562316948890144885031009621840903245719004011364727,
        "ciphertext": 1621497733755920743214070216863865116584939448848240208335043446919415874874658474205735277591628003589572625445130929253754833916990521803302886949280837,
        "plaintext": "PCTF{ejc0qs}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 8748f7a9d03b3bfdad9c6fdd6021326bbe6f48a599ec5212d32aa803f5afb9dc, and the following public key:\nkey = \"e93ce8e8f33dfa415f4897a847b6f9c8\", iv = \"3b08f31a5dfbba3b86c2f5ef3c8977da\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"e93ce8e8f33dfa415f4897a847b6f9c8\")\niv = bytes.fromhex(\"3b08f31a5dfbba3b86c2f5ef3c8977da\")\nciphertext = bytes.fromhex(\"8748f7a9d03b3bfdad9c6fdd6021326bbe6f48a599ec5212d32aa803f5afb9dc\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{ZwWzeYhvsAIhoioBNlpPaJ9nNlZt}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "ZwWzeYhvsAIhoioBNlpPaJ9nNlZt",
        "ciphertext": "8748f7a9d03b3bfdad9c6fdd6021326bbe6f48a599ec5212d32aa803f5afb9dc",
        "key": "e93ce8e8f33dfa415f4897a847b6f9c8",
        "iv": "3b08f31a5dfbba3b86c2f5ef3c8977da",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: e9196578b0e4fa4cc4237ad122d32e69a6928380ac0cec37779e2a0528afd6da, and the following public key:\nkey = \"bf486031760782e582541ffbfbbe8aa7\", iv = \"4df36d5db52621406b73c616b724e6a1\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"bf486031760782e582541ffbfbbe8aa7\")\niv = bytes.fromhex(\"4df36d5db52621406b73c616b724e6a1\")\nciphertext = bytes.fromhex(\"e9196578b0e4fa4cc4237ad122d32e69a6928380ac0cec37779e2a0528afd6da\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{TvVfWSTJgekWbWQbZfg3pA6aTnH}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "TvVfWSTJgekWbWQbZfg3pA6aTnH",
        "ciphertext": "e9196578b0e4fa4cc4237ad122d32e69a6928380ac0cec37779e2a0528afd6da",
        "key": "bf486031760782e582541ffbfbbe8aa7",
        "iv": "4df36d5db52621406b73c616b724e6a1",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 10af052124627143922257d933241c2675e38a0dd98e62a40299feda2f3bb725, and the following public key:\nkey = \"a4a39ba21df2235e2d28e2a144db2a9a\", iv = \"60507727427fe8b23432b300d6685cbe\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"a4a39ba21df2235e2d28e2a144db2a9a\")\niv = bytes.fromhex(\"60507727427fe8b23432b300d6685cbe\")\nciphertext = bytes.fromhex(\"10af052124627143922257d933241c2675e38a0dd98e62a40299feda2f3bb725\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{6zcsoKwFz7cgT22QuLE}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "6zcsoKwFz7cgT22QuLE",
        "ciphertext": "10af052124627143922257d933241c2675e38a0dd98e62a40299feda2f3bb725",
        "key": "a4a39ba21df2235e2d28e2a144db2a9a",
        "iv": "60507727427fe8b23432b300d6685cbe",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: b21a7fc21504a162ad76104737dc2ccbffbd9394ab83d07bd177c9d3330d22b4, and the following public key:\nkey = \"8f6734fee752dd76948ca52b03c0df90\", iv = \"67718d40ebc7be145074ccabae8deaeb\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"8f6734fee752dd76948ca52b03c0df90\")\niv = bytes.fromhex(\"67718d40ebc7be145074ccabae8deaeb\")\nciphertext = bytes.fromhex(\"b21a7fc21504a162ad76104737dc2ccbffbd9394ab83d07bd177c9d3330d22b4\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{YZmTSu12Hlz0Jwye5FQIPDShGF}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "YZmTSu12Hlz0Jwye5FQIPDShGF",
        "ciphertext": "b21a7fc21504a162ad76104737dc2ccbffbd9394ab83d07bd177c9d3330d22b4",
        "key": "8f6734fee752dd76948ca52b03c0df90",
        "iv": "67718d40ebc7be145074ccabae8deaeb",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 5d942a3608c329738f6ff36a5c96ba64, and the following public key:\nkey = \"f15b15a93c1dee4d792194a770169cf7\", iv = \"03d5c2933b3c94da423a20790528ebad\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"f15b15a93c1dee4d792194a770169cf7\")\niv = bytes.fromhex(\"03d5c2933b3c94da423a20790528ebad\")\nciphertext = bytes.fromhex(\"5d942a3608c329738f6ff36a5c96ba64\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{oUUAFbwrO}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "oUUAFbwrO",
        "ciphertext": "5d942a3608c329738f6ff36a5c96ba64",
        "key": "f15b15a93c1dee4d792194a770169cf7",
        "iv": "03d5c2933b3c94da423a20790528ebad",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: e2433516cb3e6a7ed6678b203f9e15f9414d52419b1ea1e3551ec6ae28973d47, and the following public key:\nkey = \"6013a88a24d08c06286e4d80da59cd7f\", iv = \"380315f2c395d304ba8a87fd2f46df10\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"6013a88a24d08c06286e4d80da59cd7f\")\niv = bytes.fromhex(\"380315f2c395d304ba8a87fd2f46df10\")\nciphertext = bytes.fromhex(\"e2433516cb3e6a7ed6678b203f9e15f9414d52419b1ea1e3551ec6ae28973d47\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{7lmadsiH3dBptbFhR6IHuHFmddf}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "7lmadsiH3dBptbFhR6IHuHFmddf",
        "ciphertext": "e2433516cb3e6a7ed6678b203f9e15f9414d52419b1ea1e3551ec6ae28973d47",
        "key": "6013a88a24d08c06286e4d80da59cd7f",
        "iv": "380315f2c395d304ba8a87fd2f46df10",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 44f4023ce374bbb3936bc9d96e00f6a86fa7d31b12e57fdf8df1e73e982fc536, and the following public key:\nkey = \"051f363a303175e8b63d48e5ff401ae6\", iv = \"420f70ee06941e6b8318722aa52b33c8\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"051f363a303175e8b63d48e5ff401ae6\")\niv = bytes.fromhex(\"420f70ee06941e6b8318722aa52b33c8\")\nciphertext = bytes.fromhex(\"44f4023ce374bbb3936bc9d96e00f6a86fa7d31b12e57fdf8df1e73e982fc536\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{RmFNnseN19kYH7Kb6q}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "RmFNnseN19kYH7Kb6q",
        "ciphertext": "44f4023ce374bbb3936bc9d96e00f6a86fa7d31b12e57fdf8df1e73e982fc536",
        "key": "051f363a303175e8b63d48e5ff401ae6",
        "iv": "420f70ee06941e6b8318722aa52b33c8",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: a8d6ba32d1476b17ce00ebc8cef33be4, and the following public key:\nkey = \"69a28dbc32cf7b58b81149b4405f3045\", iv = \"5c1b99bb6c7f4c404dd93329b28007a3\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"69a28dbc32cf7b58b81149b4405f3045\")\niv = bytes.fromhex(\"5c1b99bb6c7f4c404dd93329b28007a3\")\nciphertext = bytes.fromhex(\"a8d6ba32d1476b17ce00ebc8cef33be4\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{wzpeCn0JbpX8}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "wzpeCn0JbpX8",
        "ciphertext": "a8d6ba32d1476b17ce00ebc8cef33be4",
        "key": "69a28dbc32cf7b58b81149b4405f3045",
        "iv": "5c1b99bb6c7f4c404dd93329b28007a3",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: 357f527d6a865704e1f10633ecdb1ae2ece4b611831f65b28ee736af4d4cf982, and the following public key:\nkey = \"73f2af7eaa7e0c60e4504a1172e4a33f\", iv = \"5de14a117ffdb647b7ba437a76481d37\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"73f2af7eaa7e0c60e4504a1172e4a33f\")\niv = bytes.fromhex(\"5de14a117ffdb647b7ba437a76481d37\")\nciphertext = bytes.fromhex(\"357f527d6a865704e1f10633ecdb1ae2ece4b611831f65b28ee736af4d4cf982\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{c3rCRy3CO3mmnzIfltA1FZ239}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "c3rCRy3CO3mmnzIfltA1FZ239",
        "ciphertext": "357f527d6a865704e1f10633ecdb1ae2ece4b611831f65b28ee736af4d4cf982",
        "key": "73f2af7eaa7e0c60e4504a1172e4a33f",
        "iv": "5de14a117ffdb647b7ba437a76481d37",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_PADDING: dc64a994c3eec8fc6dfbb22a906bc1d58b6ac74bb75c9e72d05c0ea575f2d86c, and the following public key:\nkey = \"68130d2cd4700a088429b818b2c5cea9\", iv = \"3bdb66c4720d1103d73e899f89806e11\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nkey = bytes.fromhex(\"68130d2cd4700a088429b818b2c5cea9\")\niv = bytes.fromhex(\"3bdb66c4720d1103d73e899f89806e11\")\nciphertext = bytes.fromhex(\"dc64a994c3eec8fc6dfbb22a906bc1d58b6ac74bb75c9e72d05c0ea575f2d86c\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = cipher.decrypt(ciphertext)\nplaintext = unpad(decrypted, 16)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{r1yQZXeMaxcHxM71o1jCKsiEQz193u}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_PADDING",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = bytes.fromhex(\"{plaintext}\")\ncipher = AES.new(key, AES.MODE_CBC, iv)\npadded = pad(plaintext, 16)  # block size 16\nciphertext = cipher.encrypt(padded)\nprint(ciphertext.hex())\n",
      "original_data": {
        "plaintext": "r1yQZXeMaxcHxM71o1jCKsiEQz193u",
        "ciphertext": "dc64a994c3eec8fc6dfbb22a906bc1d58b6ac74bb75c9e72d05c0ea575f2d86c",
        "key": "68130d2cd4700a088429b818b2c5cea9",
        "iv": "3bdb66c4720d1103d73e899f89806e11",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x416767ae85721674 and the known public and private keys:\nN=6407142332584240411 e=2563477502823866089 d=2473256110289813353\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 6407142332584240411\nd = 2473256110289813353\nciphertext = 0x416767ae85721674\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{abcd}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x416767ae85721674",
        "p": 3445867459,
        "q": 1859369929,
        "N": 6407142332584240411,
        "e": 2563477502823866089,
        "d": 2473256110289813353,
        "plaintext": "abcd",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x1a341d3d5781d851 and the known public and private keys:\nN=1908041966795977543 e=37 d=1031374034191325773\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 1908041966795977543\nd = 1031374034191325773\nciphertext = 0x1a341d3d5781d851\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xyz}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x1a341d3d5781d851",
        "p": 2879363941,
        "q": 662660923,
        "N": 1908041966795977543,
        "e": 37,
        "d": 1031374034191325773,
        "plaintext": "xyz",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x655b1dfd4dddcf6 and the known public and private keys:\nN=14344107061224685963 e=61 d=11992614094026080389\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 14344107061224685963\nd = 11992614094026080389\nciphertext = 0x655b1dfd4dddcf6\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{1234}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x655b1dfd4dddcf6",
        "p": 3996316937,
        "q": 3589331699,
        "N": 14344107061224685963,
        "e": 61,
        "d": 11992614094026080389,
        "plaintext": "1234",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x1309abf87083b19e and the known public and private keys:\nN=2734243703789752151 e=83 d=560025817917773843\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 2734243703789752151\nd = 560025817917773843\nciphertext = 0x1309abf87083b19e\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{qwer}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x1309abf87083b19e",
        "p": 713844779,
        "q": 3830305669,
        "N": 2734243703789752151,
        "e": 83,
        "d": 560025817917773843,
        "plaintext": "qwer",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x283754f02f0d6d53 and the known public and private keys:\nN=4958733380064749767 e=4076500036402232389 d=2939293256936841469\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 4958733380064749767\nd = 2939293256936841469\nciphertext = 0x283754f02f0d6d53\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rty}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x283754f02f0d6d53",
        "p": 1228870549,
        "q": 4035195883,
        "N": 4958733380064749767,
        "e": 4076500036402232389,
        "d": 2939293256936841469,
        "plaintext": "rty",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x2069c260f44591da and the known public and private keys:\nN=2714772657451474649 e=421 d=528768070262157901\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 2714772657451474649\nd = 528768070262157901\nciphertext = 0x2069c260f44591da\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{asdz}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x2069c260f44591da",
        "p": 854199821,
        "q": 3178147069,
        "N": 2714772657451474649,
        "e": 421,
        "d": 528768070262157901,
        "plaintext": "asdz",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x78743c51cb020a and the known public and private keys:\nN=58932996058187401 e=32200795795042493 d=24350336940328469\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 58932996058187401\nd = 24350336940328469\nciphertext = 0x78743c51cb020a\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{zxcv}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x78743c51cb020a",
        "p": 24430033,
        "q": 2412317497,
        "N": 58932996058187401,
        "e": 32200795795042493,
        "d": 24350336940328469,
        "plaintext": "zxcv",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x46b0ba606e4ad55 and the known public and private keys:\nN=889292536149662737 e=1123 d=49889073548202943\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 889292536149662737\nd = 49889073548202943\nciphertext = 0x46b0ba606e4ad55\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{jklm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x46b0ba606e4ad55",
        "p": 348299999,
        "q": 2553237263,
        "N": 889292536149662737,
        "e": 1123,
        "d": 49889073548202943,
        "plaintext": "jklm",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x5469e777b8036a3 and the known public and private keys:\nN=519519252918498667 e=2075 d=16023726307345939\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 519519252918498667\nd = 16023726307345939\nciphertext = 0x5469e777b8036a3\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{mnop}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x5469e777b8036a3",
        "p": 492363779,
        "q": 1055153273,
        "N": 519519252918498667,
        "e": 2075,
        "d": 16023726307345939,
        "plaintext": "mnop",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an RSA encrypted message: 0x20d2251189b9b5ee and the known public and private keys:\nN=3434028513193169797 e=4099 d=1287655969077075467\nPlease decrypt the message and submit the result in ASCII format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\n\nN = 3434028513193169797\nd = 1287655969077075467\nciphertext = 0x20d2251189b9b5ee\n\n# Directly use the leaked d to decrypt\nm = gmpy2.powmod(ciphertext, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{pqrs}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_D_Leakage",
      "change_detail": "In RSA, if the private key exponent d is leaked, decryption becomes trivial.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\nd = {d}  # Leaked private exponent\ne = {e}  # Public exponent\nciphertext = {ciphertext}  # Encrypted message\nm = gmpy2.powmod(ciphertext, d, N)\nprint(bytes.fromhex(format(int(m), 'x')).decode('ascii'))",
      "original_data": {
        "ciphertext": "0x20d2251189b9b5ee",
        "p": 847411673,
        "q": 4052373389,
        "N": 3434028513193169797,
        "e": 4099,
        "d": 1287655969077075467,
        "plaintext": "pqrs",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x5dbbd924 and the public key parameters are:\nN=1855723879 e=23\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 1855723879\ne = 23\nc = 0x5dbbd924\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{hey}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x5dbbd924",
        "p": 34127,
        "q": 54377,
        "N": 1855723879,
        "e": 23,
        "plaintext": "hey",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x31f15c15 and the public key parameters are:\nN=1425369263 e=640291861\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 1425369263\ne = 640291861\nc = 0x31f15c15\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{bye}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x31f15c15",
        "p": 63607,
        "q": 22409,
        "N": 1425369263,
        "e": 640291861,
        "plaintext": "bye",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x792041 and the public key parameters are:\nN=10859851 e=3330913\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 10859851\ne = 3330913\nc = 0x792041\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{yes}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x792041",
        "p": 9619,
        "q": 1129,
        "N": 10859851,
        "e": 3330913,
        "plaintext": "yes",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x2b7a6b34 and the public key parameters are:\nN=936422147 e=605897483\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 936422147\ne = 605897483\nc = 0x2b7a6b34\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{cat}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x2b7a6b34",
        "p": 54421,
        "q": 17207,
        "N": 936422147,
        "e": 605897483,
        "plaintext": "cat",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x17aee46 and the public key parameters are:\nN=605338109 e=279829709\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 605338109\ne = 279829709\nc = 0x17aee46\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{dog}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x17aee46",
        "p": 22189,
        "q": 27281,
        "N": 605338109,
        "e": 279829709,
        "plaintext": "dog",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x273b510 and the public key parameters are:\nN=89972867 e=457\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 89972867\ne = 457\nc = 0x273b510\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{sun}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x273b510",
        "p": 2287,
        "q": 39341,
        "N": 89972867,
        "e": 457,
        "plaintext": "sun",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x21b64cde and the public key parameters are:\nN=783695141 e=353671799\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 783695141\ne = 353671799\nc = 0x21b64cde\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{fun}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x21b64cde",
        "p": 34483,
        "q": 22727,
        "N": 783695141,
        "e": 353671799,
        "plaintext": "fun",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x541b1d and the public key parameters are:\nN=18058679 e=14711\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 18058679\ne = 14711\nc = 0x541b1d\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{run}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x541b1d",
        "p": 3319,
        "q": 5441,
        "N": 18058679,
        "e": 14711,
        "plaintext": "run",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x20dfe62c and the public key parameters are:\nN=2197131847 e=2047\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 2197131847\ne = 2047\nc = 0x20dfe62c\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{top}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x20dfe62c",
        "p": 47353,
        "q": 46399,
        "N": 2197131847,
        "e": 2047,
        "plaintext": "top",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x17c09866 and the public key parameters are:\nN=2094945067 e=65537\nPlease decrypt the message, and submit the result in ASCII code format.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 2094945067\ne = 65537\nc = 0x17c09866\n\n# Use Fermat's factorization method\nx = gmpy2.isqrt(N)\nwhile True:\n    y2 = x * x - N\n    if gmpy2.is_square(y2):\n        y = gmpy2.isqrt(y2)\n        p, q = x - y, x + y\n        break\n    x += 1\n\n# Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{big}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Bad_Factorization",
      "change_detail": "In RSA, if p and q are too close, Fermat's factorization method can efficiently recover them.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x17c09866",
        "p": 60077,
        "q": 34871,
        "N": 2094945067,
        "e": 65537,
        "plaintext": "big",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0xe1781596888 and the public key used for encryption is:\nN=7476892639475486677 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 7476892639475486677\ne = 3\nc = 0xe1781596888\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ab}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0xe1781596888",
        "p": 2126119901,
        "q": 3516684377,
        "N": 7476892639475486677,
        "e": 3,
        "plaintext": "ab",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x12ea2658c8c0 and the public key used for encryption is:\nN=4873565229656223511 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 4873565229656223511\ne = 3\nc = 0x12ea2658c8c0\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{kl}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x12ea2658c8c0",
        "p": 3873985169,
        "q": 1258023719,
        "N": 4873565229656223511,
        "e": 3,
        "plaintext": "kl",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x1a04bf739e00 and the public key used for encryption is:\nN=201776857651242451 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 201776857651242451\ne = 3\nc = 0x1a04bf739e00\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{wx}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x1a04bf739e00",
        "p": 154408439,
        "q": 1306773509,
        "N": 201776857651242451,
        "e": 3,
        "plaintext": "wx",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x24c85a78318 and the public key used for encryption is:\nN=3466726207583408323 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 3466726207583408323\ne = 3\nc = 0x24c85a78318\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{56}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x24c85a78318",
        "p": 2069579177,
        "q": 1675087499,
        "N": 3466726207583408323,
        "e": 3,
        "plaintext": "56",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x1067dfdce348 and the public key used for encryption is:\nN=9259483779327392509 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 9259483779327392509\ne = 3\nc = 0x1067dfdce348\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{fr}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x1067dfdce348",
        "p": 3863420111,
        "q": 2396706419,
        "N": 9259483779327392509,
        "e": 3,
        "plaintext": "fr",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x11662e8ec029 and the public key used for encryption is:\nN=4392172608298784047 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 4392172608298784047\ne = 3\nc = 0x11662e8ec029\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{hy}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x11662e8ec029",
        "p": 2984131301,
        "q": 1471842947,
        "N": 4392172608298784047,
        "e": 3,
        "plaintext": "hy",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x1374414ea24f and the public key used for encryption is:\nN=991464612260192167 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 991464612260192167\ne = 3\nc = 0x1374414ea24f\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{lo}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x1374414ea24f",
        "p": 755717861,
        "q": 1311950747,
        "N": 991464612260192167,
        "e": 3,
        "plaintext": "lo",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x1aa61b176ab5 and the public key used for encryption is:\nN=3186028506212570257 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 3186028506212570257\ne = 3\nc = 0x1aa61b176ab5\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{xm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x1aa61b176ab5",
        "p": 1577666459,
        "q": 2019456323,
        "N": 3186028506212570257,
        "e": 3,
        "plaintext": "xm",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x1950c2c6e488 and the public key used for encryption is:\nN=11566670349323090689 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 11566670349323090689\ne = 3\nc = 0x1950c2c6e488\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{vb}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x1950c2c6e488",
        "p": 4217959919,
        "q": 2742242831,
        "N": 11566670349323090689,
        "e": 3,
        "plaintext": "vb",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The given RSA encrypted message is: 0x148bd3c31cb5 and the public key used for encryption is:\nN=4672190145100818727 e=3\nPlease decrypt the message, and submit the result by converting the numbers to ASCII code.\nSubmission format: PCTF{Plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\nN = 4672190145100818727\ne = 3\nc = 0x148bd3c31cb5\n\n# Small public exponent attack\nm = gmpy2.iroot(c, e)[0]\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{nm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Small_Public_Exponent_Attack",
      "change_detail": "In RSA, a small public exponent (like e = 3) can sometimes leak information about the plaintext if the ciphertext is small enough.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne = {e}  # Public exponent (small value, e.g., 3)\nciphertext = {ciphertext}  # Encrypted message\n# Attack\nm = gmpy2.iroot(ciphertext, e)[0]\nprint(m)",
      "original_data": {
        "ciphertext": "0x148bd3c31cb5",
        "p": 1965693797,
        "q": 2376865691,
        "N": 4672190145100818727,
        "e": 3,
        "plaintext": "nm",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x2875941861234b9, 0x302cfaa88d03f9a, and the known public key:\nN=311813242885154233 e1=17, e2=23\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 311813242885154233\ne1 = 17\ne2 = 23\nc1 = 0x2875941861234b9\nc2 = 0x302cfaa88d03f9a\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{apple}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x2875941861234b9",
        "ciphertext2": "0x302cfaa88d03f9a",
        "p": 398249239,
        "q": 782960047,
        "N": 311813242885154233,
        "e1": 17,
        "e2": 23,
        "plaintext": "apple",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x10a4e3443ad5dae7, 0x5e6297f9cd84a993, and the known public key:\nN=7195462239046648033 e1=37, e2=51\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 7195462239046648033\ne1 = 37\ne2 = 51\nc1 = 0x10a4e3443ad5dae7\nc2 = 0x5e6297f9cd84a993\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{stone}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x10a4e3443ad5dae7",
        "ciphertext2": "0x5e6297f9cd84a993",
        "p": 1783354211,
        "q": 4034791403,
        "N": 7195462239046648033,
        "e1": 37,
        "e2": 51,
        "plaintext": "stone",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x35e391f95783614c, 0x25f28e47ce53a5b, and the known public key:\nN=6465070740881694589 e1=61, e2=79\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 6465070740881694589\ne1 = 61\ne2 = 79\nc1 = 0x35e391f95783614c\nc2 = 0x25f28e47ce53a5b\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rain}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x35e391f95783614c",
        "ciphertext2": "0x25f28e47ce53a5b",
        "p": 2105151661,
        "q": 3071071249,
        "N": 6465070740881694589,
        "e1": 61,
        "e2": 79,
        "plaintext": "rain",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x2f2ead6e7920d62, 0x9c1937084f6d2e4, and the known public key:\nN=733768686146678531 e1=83, e2=97\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 733768686146678531\ne1 = 83\ne2 = 97\nc1 = 0x2f2ead6e7920d62\nc2 = 0x9c1937084f6d2e4\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{light}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x2f2ead6e7920d62",
        "ciphertext2": "0x9c1937084f6d2e4",
        "p": 730880021,
        "q": 1003952311,
        "N": 733768686146678531,
        "e1": 83,
        "e2": 97,
        "plaintext": "light",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0xa49502d5f069463, 0x9db6100e41ef0f6, and the known public key:\nN=1455686863419187093 e1=107, e2=123\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 1455686863419187093\ne1 = 107\ne2 = 123\nc1 = 0xa49502d5f069463\nc2 = 0x9db6100e41ef0f6\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{cloud}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0xa49502d5f069463",
        "ciphertext2": "0x9db6100e41ef0f6",
        "p": 395819273,
        "q": 3677655341,
        "N": 1455686863419187093,
        "e1": 107,
        "e2": 123,
        "plaintext": "cloud",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x7cb7f9a12b621f2, 0x33c9e8046bc6e64, and the known public key:\nN=5874191946694815137 e1=421, e2=457\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 5874191946694815137\ne1 = 421\ne2 = 457\nc1 = 0x7cb7f9a12b621f2\nc2 = 0x33c9e8046bc6e64\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{shine}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x7cb7f9a12b621f2",
        "ciphertext2": "0x33c9e8046bc6e64",
        "p": 3967073597,
        "q": 1480736821,
        "N": 5874191946694815137,
        "e1": 421,
        "e2": 457,
        "plaintext": "shine",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x1efb99b5784927c, 0x5b442230598dc9c, and the known public key:\nN=606199343675835323 e1=757, e2=679\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 606199343675835323\ne1 = 757\ne2 = 679\nc1 = 0x1efb99b5784927c\nc2 = 0x5b442230598dc9c\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{wave}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x1efb99b5784927c",
        "ciphertext2": "0x5b442230598dc9c",
        "p": 3656399303,
        "q": 165791341,
        "N": 606199343675835323,
        "e1": 757,
        "e2": 679,
        "plaintext": "wave",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x2433aba82711a925, 0x85316012e9f7df6, and the known public key:\nN=2665379583284114833 e1=1123, e2=1025\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 2665379583284114833\ne1 = 1123\ne2 = 1025\nc1 = 0x2433aba82711a925\nc2 = 0x85316012e9f7df6\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{sky}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x2433aba82711a925",
        "ciphertext2": "0x85316012e9f7df6",
        "p": 951360847,
        "q": 2801649439,
        "N": 2665379583284114833,
        "e1": 1123,
        "e2": 1025,
        "plaintext": "sky",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x696107a8be38612, 0x1e5732abbdda84d8, and the known public key:\nN=5285705541781036291 e1=2075, e2=2047\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 5285705541781036291\ne1 = 2075\ne2 = 2047\nc1 = 0x696107a8be38612\nc2 = 0x1e5732abbdda84d8\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{heart}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x696107a8be38612",
        "ciphertext2": "0x1e5732abbdda84d8",
        "p": 1589064853,
        "q": 3326299447,
        "N": 5285705541781036291,
        "e1": 2075,
        "e2": 2047,
        "plaintext": "heart",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given two RSA encrypted messages: 0x7ef80eb6c9cfe10, 0x14f4a0e43e3cde6b, and the known public key:\nN=2662849553477873219 e1=4099, e2=3001\nPlease decrypt the plaintext and submit the result as ASCII values.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n\nN = 2662849553477873219\ne1 = 4099\ne2 = 3001\nc1 = 0x7ef80eb6c9cfe10\nc2 = 0x14f4a0e43e3cde6b\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n\n# Use the Extended Euclidean Algorithm to find a and b\n_, a, b = extended_gcd(e1, e2)\n\n# Compute c1^a * c2^b (mod N)\nif a < 0:\n    c1 = gmpy2.invert(c1, N)\n    a = -a\nif b < 0:\n    c2 = gmpy2.invert(c2, N)\n    b = -b\n\nm = (gmpy2.powmod(c1, a, N) * gmpy2.powmod(c2, b, N)) % N\n\n# Convert to ASCII\nhex_str = format(int(m), 'x')\nif len(hex_str) % 2:\n    hex_str = '0' + hex_str\nplaintext = bytes.fromhex(hex_str).decode('ascii')\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{rock}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Common_Modulus_Attack",
      "change_detail": "If two different public exponents e1 and e2 share the same modulus N, and gcd(e1, e2) = 1, the plaintext can be efficiently recovered using the Extended Euclidean Algorithm.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\ne1, e2 = {e1}, {e2}  # Public exponents\nc1, c2 = {c1}, {c2}  # Encrypted ciphertexts\nprint(c1, c2)",
      "original_data": {
        "ciphertext1": "0x7ef80eb6c9cfe10",
        "ciphertext2": "0x14f4a0e43e3cde6b",
        "p": 2117145487,
        "q": 1257754637,
        "N": 2662849553477873219,
        "e1": 4099,
        "e2": 3001,
        "plaintext": "rock",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 34953805687679291400, and the following information:\nPublic key: pub_key = \"[3788212055899933445, 1507895535487029964, 1373616739511343484, 3635460042741888430, 3979182135685400558, 1146971857623864329, 1402022508092055489, 1288760193824137600, 3081383780622775757, 3382282291294619183, 80061677945044645, 1918103266146133679, 936221040111535375, 480352123529368731, 1218177908700695301, 2559550683067661961, 569552255618932081, 135072368725334755, 389644959680469162, 529205544591923899, 1439079616492076996, 1870432447035152878, 2098690562607589312, 3686128445367734653, 807254208321075237, 987450158001378558, 1082979108847083947, 3054184781413369356, 670593888591145409, 87071259900746986, 797506135005794181, 3237186601474304806, 2566660924818876515, 2229641714020549340, 286708201396464330, 2465675109024659529, 3289175886586602614, 644101992836054782, 3561131219212069631, 557259756009745193, 3514336254662193519, 2602318264474266556, 1800787643793300572, 1198063901507426304, 3657633607169339854, 3153775918003460479, 1254139332516028560, 3639200316647329593, 3997746613805698005, 661764203707600131, 569580639671685280, 3535283378549601986, 3916802246712985857, 2149439087857835693, 380081967276523168, 3163675320632221176]\", Private key: priv_key = \"[10, 68, 137, 239, 544, 1006, 2079, 4154, 8320, 16654, 33221, 66532, 133019, 266061, 532080, 1064187, 2128394, 4256732, 8513523, 17027024, 34054033, 68108042, 136216085, 272432222, 544864416, 1089728793, 2179457653, 4358915271, 8717830597, 17435661116, 34871322303, 69742644605, 139485289141, 278970578269, 557941156575, 1115882313171, 2231764626343, 4463529252665, 8927058505336, 17854117010644, 35708234021289, 71416468042625, 142832936085193, 285665872170417, 571331744340848, 1142663488681637, 2285326977363282, 4570653954726615, 9141307909453200, 18282615818906466, 36565231637812898, 73130463275625829, 146260926551251623, 292521853102503247, 585043706205006521, 1170087412410013011]\", and additional parameters: m = \"4041991074105419577\", w = \"2399816742642703133\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 34953805687679291400\nm = 4041991074105419577\nw = 2399816742642703133\npub_key = [3788212055899933445, 1507895535487029964, 1373616739511343484, 3635460042741888430, 3979182135685400558, 1146971857623864329, 1402022508092055489, 1288760193824137600, 3081383780622775757, 3382282291294619183, 80061677945044645, 1918103266146133679, 936221040111535375, 480352123529368731, 1218177908700695301, 2559550683067661961, 569552255618932081, 135072368725334755, 389644959680469162, 529205544591923899, 1439079616492076996, 1870432447035152878, 2098690562607589312, 3686128445367734653, 807254208321075237, 987450158001378558, 1082979108847083947, 3054184781413369356, 670593888591145409, 87071259900746986, 797506135005794181, 3237186601474304806, 2566660924818876515, 2229641714020549340, 286708201396464330, 2465675109024659529, 3289175886586602614, 644101992836054782, 3561131219212069631, 557259756009745193, 3514336254662193519, 2602318264474266556, 1800787643793300572, 1198063901507426304, 3657633607169339854, 3153775918003460479, 1254139332516028560, 3639200316647329593, 3997746613805698005, 661764203707600131, 569580639671685280, 3535283378549601986, 3916802246712985857, 2149439087857835693, 380081967276523168, 3163675320632221176]\npriv_key = [10, 68, 137, 239, 544, 1006, 2079, 4154, 8320, 16654, 33221, 66532, 133019, 266061, 532080, 1064187, 2128394, 4256732, 8513523, 17027024, 34054033, 68108042, 136216085, 272432222, 544864416, 1089728793, 2179457653, 4358915271, 8717830597, 17435661116, 34871322303, 69742644605, 139485289141, 278970578269, 557941156575, 1115882313171, 2231764626343, 4463529252665, 8927058505336, 17854117010644, 35708234021289, 71416468042625, 142832936085193, 285665872170417, 571331744340848, 1142663488681637, 2285326977363282, 4570653954726615, 9141307909453200, 18282615818906466, 36565231637812898, 73130463275625829, 146260926551251623, 292521853102503247, 585043706205006521, 1170087412410013011]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{W7XL5PX}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "W7XL5PX",
        "ciphertext": 34953805687679291400,
        "pub_key": "[3788212055899933445, 1507895535487029964, 1373616739511343484, 3635460042741888430, 3979182135685400558, 1146971857623864329, 1402022508092055489, 1288760193824137600, 3081383780622775757, 3382282291294619183, 80061677945044645, 1918103266146133679, 936221040111535375, 480352123529368731, 1218177908700695301, 2559550683067661961, 569552255618932081, 135072368725334755, 389644959680469162, 529205544591923899, 1439079616492076996, 1870432447035152878, 2098690562607589312, 3686128445367734653, 807254208321075237, 987450158001378558, 1082979108847083947, 3054184781413369356, 670593888591145409, 87071259900746986, 797506135005794181, 3237186601474304806, 2566660924818876515, 2229641714020549340, 286708201396464330, 2465675109024659529, 3289175886586602614, 644101992836054782, 3561131219212069631, 557259756009745193, 3514336254662193519, 2602318264474266556, 1800787643793300572, 1198063901507426304, 3657633607169339854, 3153775918003460479, 1254139332516028560, 3639200316647329593, 3997746613805698005, 661764203707600131, 569580639671685280, 3535283378549601986, 3916802246712985857, 2149439087857835693, 380081967276523168, 3163675320632221176]",
        "priv_key": "[10, 68, 137, 239, 544, 1006, 2079, 4154, 8320, 16654, 33221, 66532, 133019, 266061, 532080, 1064187, 2128394, 4256732, 8513523, 17027024, 34054033, 68108042, 136216085, 272432222, 544864416, 1089728793, 2179457653, 4358915271, 8717830597, 17435661116, 34871322303, 69742644605, 139485289141, 278970578269, 557941156575, 1115882313171, 2231764626343, 4463529252665, 8927058505336, 17854117010644, 35708234021289, 71416468042625, 142832936085193, 285665872170417, 571331744340848, 1142663488681637, 2285326977363282, 4570653954726615, 9141307909453200, 18282615818906466, 36565231637812898, 73130463275625829, 146260926551251623, 292521853102503247, 585043706205006521, 1170087412410013011]",
        "w": 2399816742642703133,
        "m": 4041991074105419577,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 35161964184014964548, and the following information:\nPublic key: pub_key = \"[2021223912019341549, 2323041794124784058, 810259887489220948, 1372570827044438780, 194813324357923979, 1592472370433907173, 2614515498500535128, 1612375529034831225, 21343836660095279, 509804854048301811, 1143584182063605180, 981010580769983180, 2044670810851300732, 658647864686864770, 2251530090829952046, 2159355975207286441, 681394070120500258, 118617593867274115, 787002017773993855, 1044899617836375678, 1738538226099580275, 2232905905825434149, 609325698562687537, 90337021906588845, 469947816402847992, 1427675225861640830, 1797141616300057596, 568719419328988972, 2526246271326539496, 2316202501971623074, 424657881281894306, 1200576772136959693, 1417476055349968308, 1301507791736539913, 1668781222016857320, 1006402347096869196, 2707208410528019168, 2066372713351636014, 1396455386021816110, 2057182231053684258, 30591813413018232, 1917108240222709269, 1978291867048745733, 1220293693416035548, 254064176190060803, 694090063330623943, 2144571079979029441, 734473928975320630, 1915402626350918920, 1342464159954385038, 1990524603574489300, 1244759166467522682, 811437127676813510, 1870823203287630136, 2352838973906698720, 291306701873709668]\", Private key: priv_key = \"[9, 84, 110, 268, 496, 1026, 2029, 4091, 8135, 16313, 32602, 65190, 130364, 260725, 521536, 1042992, 2086021, 4172016, 8344059, 16688087, 33376242, 66752458, 133504862, 267009809, 534019562, 1068039163, 2136078264, 4272156580, 8544313158, 17088626312, 34177252638, 68354505208, 136709010473, 273418020976, 546836041866, 1093672083783, 2187344167565, 4374688335111, 8749376670218, 17498753340445, 34997506680880, 69995013361801, 139990026723561, 279980053447118, 559960106894259, 1119920213788482, 2239840427576951, 4479680855153923, 8959361710307893, 17918723420615734, 35837446841231469, 71674893682462934, 143349787364925926, 286699574729851804, 573399149459703610, 1146798298919407274]\", and additional parameters: m = \"2756952453009289511\", w = \"2062548736675008735\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 35161964184014964548\nm = 2756952453009289511\nw = 2062548736675008735\npub_key = [2021223912019341549, 2323041794124784058, 810259887489220948, 1372570827044438780, 194813324357923979, 1592472370433907173, 2614515498500535128, 1612375529034831225, 21343836660095279, 509804854048301811, 1143584182063605180, 981010580769983180, 2044670810851300732, 658647864686864770, 2251530090829952046, 2159355975207286441, 681394070120500258, 118617593867274115, 787002017773993855, 1044899617836375678, 1738538226099580275, 2232905905825434149, 609325698562687537, 90337021906588845, 469947816402847992, 1427675225861640830, 1797141616300057596, 568719419328988972, 2526246271326539496, 2316202501971623074, 424657881281894306, 1200576772136959693, 1417476055349968308, 1301507791736539913, 1668781222016857320, 1006402347096869196, 2707208410528019168, 2066372713351636014, 1396455386021816110, 2057182231053684258, 30591813413018232, 1917108240222709269, 1978291867048745733, 1220293693416035548, 254064176190060803, 694090063330623943, 2144571079979029441, 734473928975320630, 1915402626350918920, 1342464159954385038, 1990524603574489300, 1244759166467522682, 811437127676813510, 1870823203287630136, 2352838973906698720, 291306701873709668]\npriv_key = [9, 84, 110, 268, 496, 1026, 2029, 4091, 8135, 16313, 32602, 65190, 130364, 260725, 521536, 1042992, 2086021, 4172016, 8344059, 16688087, 33376242, 66752458, 133504862, 267009809, 534019562, 1068039163, 2136078264, 4272156580, 8544313158, 17088626312, 34177252638, 68354505208, 136709010473, 273418020976, 546836041866, 1093672083783, 2187344167565, 4374688335111, 8749376670218, 17498753340445, 34997506680880, 69995013361801, 139990026723561, 279980053447118, 559960106894259, 1119920213788482, 2239840427576951, 4479680855153923, 8959361710307893, 17918723420615734, 35837446841231469, 71674893682462934, 143349787364925926, 286699574729851804, 573399149459703610, 1146798298919407274]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{U72NQBE}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "U72NQBE",
        "ciphertext": 35161964184014964548,
        "pub_key": "[2021223912019341549, 2323041794124784058, 810259887489220948, 1372570827044438780, 194813324357923979, 1592472370433907173, 2614515498500535128, 1612375529034831225, 21343836660095279, 509804854048301811, 1143584182063605180, 981010580769983180, 2044670810851300732, 658647864686864770, 2251530090829952046, 2159355975207286441, 681394070120500258, 118617593867274115, 787002017773993855, 1044899617836375678, 1738538226099580275, 2232905905825434149, 609325698562687537, 90337021906588845, 469947816402847992, 1427675225861640830, 1797141616300057596, 568719419328988972, 2526246271326539496, 2316202501971623074, 424657881281894306, 1200576772136959693, 1417476055349968308, 1301507791736539913, 1668781222016857320, 1006402347096869196, 2707208410528019168, 2066372713351636014, 1396455386021816110, 2057182231053684258, 30591813413018232, 1917108240222709269, 1978291867048745733, 1220293693416035548, 254064176190060803, 694090063330623943, 2144571079979029441, 734473928975320630, 1915402626350918920, 1342464159954385038, 1990524603574489300, 1244759166467522682, 811437127676813510, 1870823203287630136, 2352838973906698720, 291306701873709668]",
        "priv_key": "[9, 84, 110, 268, 496, 1026, 2029, 4091, 8135, 16313, 32602, 65190, 130364, 260725, 521536, 1042992, 2086021, 4172016, 8344059, 16688087, 33376242, 66752458, 133504862, 267009809, 534019562, 1068039163, 2136078264, 4272156580, 8544313158, 17088626312, 34177252638, 68354505208, 136709010473, 273418020976, 546836041866, 1093672083783, 2187344167565, 4374688335111, 8749376670218, 17498753340445, 34997506680880, 69995013361801, 139990026723561, 279980053447118, 559960106894259, 1119920213788482, 2239840427576951, 4479680855153923, 8959361710307893, 17918723420615734, 35837446841231469, 71674893682462934, 143349787364925926, 286699574729851804, 573399149459703610, 1146798298919407274]",
        "w": 2062548736675008735,
        "m": 2756952453009289511,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 127105064429877767, and the following information:\nPublic key: pub_key = \"[5318427608549934, 861209526161131, 3034478128596264, 8693074409740532, 7821077038904105, 2381180708160338, 9940406417962758, 1611878800932729, 4606007981593386, 9212015963186772, 465564834585776, 9805076259884547, 9664422492533190, 11245916617060590, 2840648819400465, 4439429865980854, 245188780999806, 9434515456166533, 9303959131756107, 1891318944544522, 467394546677076, 2176656866174228, 9812123947806242, 4459983292669887, 7367631869314679, 11109553453012371, 5742783226808143, 5546204958656314, 8778758707969643, 8853655161523458, 7831771599264938, 4335562791566044, 1900256291400300, 11192315760942426, 11056651114921020, 1841183928711287, 2300117477694646, 3909109765525328, 7818219531050656, 231898819407622, 5301673967862992, 2139761321061249, 8596358117603449, 4001934169012952, 7242551844708014, 3848248472316160, 8077155191291265, 10004374977260780]\", Private key: priv_key = \"[6, 67, 144, 308, 569, 1106, 2286, 4545, 9066, 18132, 36248, 72555, 145086, 290214, 580425, 1160806, 2321598, 4643221, 9286395, 18572818, 37145628, 74291300, 148582538, 297165159, 594330263, 1188660507, 2377321087, 4754642146, 9509284283, 19018568586, 38037137114, 76074274228, 152148548508, 304297096986, 608594193972, 1217188387919, 2434376775862, 4868753551736, 9737507103472, 19475014206982, 38950028413880, 77900056827825, 155800113655657, 311600227311248, 623200454622542, 1246400909245072, 2492801818490121, 4985603636980316]\", and additional parameters: m = \"11327980406963832\", w = \"10326388273894849\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 127105064429877767\nm = 11327980406963832\nw = 10326388273894849\npub_key = [5318427608549934, 861209526161131, 3034478128596264, 8693074409740532, 7821077038904105, 2381180708160338, 9940406417962758, 1611878800932729, 4606007981593386, 9212015963186772, 465564834585776, 9805076259884547, 9664422492533190, 11245916617060590, 2840648819400465, 4439429865980854, 245188780999806, 9434515456166533, 9303959131756107, 1891318944544522, 467394546677076, 2176656866174228, 9812123947806242, 4459983292669887, 7367631869314679, 11109553453012371, 5742783226808143, 5546204958656314, 8778758707969643, 8853655161523458, 7831771599264938, 4335562791566044, 1900256291400300, 11192315760942426, 11056651114921020, 1841183928711287, 2300117477694646, 3909109765525328, 7818219531050656, 231898819407622, 5301673967862992, 2139761321061249, 8596358117603449, 4001934169012952, 7242551844708014, 3848248472316160, 8077155191291265, 10004374977260780]\npriv_key = [6, 67, 144, 308, 569, 1106, 2286, 4545, 9066, 18132, 36248, 72555, 145086, 290214, 580425, 1160806, 2321598, 4643221, 9286395, 18572818, 37145628, 74291300, 148582538, 297165159, 594330263, 1188660507, 2377321087, 4754642146, 9509284283, 19018568586, 38037137114, 76074274228, 152148548508, 304297096986, 608594193972, 1217188387919, 2434376775862, 4868753551736, 9737507103472, 19475014206982, 38950028413880, 77900056827825, 155800113655657, 311600227311248, 623200454622542, 1246400909245072, 2492801818490121, 4985603636980316]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{KSXFWE}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "KSXFWE",
        "ciphertext": 127105064429877767,
        "pub_key": "[5318427608549934, 861209526161131, 3034478128596264, 8693074409740532, 7821077038904105, 2381180708160338, 9940406417962758, 1611878800932729, 4606007981593386, 9212015963186772, 465564834585776, 9805076259884547, 9664422492533190, 11245916617060590, 2840648819400465, 4439429865980854, 245188780999806, 9434515456166533, 9303959131756107, 1891318944544522, 467394546677076, 2176656866174228, 9812123947806242, 4459983292669887, 7367631869314679, 11109553453012371, 5742783226808143, 5546204958656314, 8778758707969643, 8853655161523458, 7831771599264938, 4335562791566044, 1900256291400300, 11192315760942426, 11056651114921020, 1841183928711287, 2300117477694646, 3909109765525328, 7818219531050656, 231898819407622, 5301673967862992, 2139761321061249, 8596358117603449, 4001934169012952, 7242551844708014, 3848248472316160, 8077155191291265, 10004374977260780]",
        "priv_key": "[6, 67, 144, 308, 569, 1106, 2286, 4545, 9066, 18132, 36248, 72555, 145086, 290214, 580425, 1160806, 2321598, 4643221, 9286395, 18572818, 37145628, 74291300, 148582538, 297165159, 594330263, 1188660507, 2377321087, 4754642146, 9509284283, 19018568586, 38037137114, 76074274228, 152148548508, 304297096986, 608594193972, 1217188387919, 2434376775862, 4868753551736, 9737507103472, 19475014206982, 38950028413880, 77900056827825, 155800113655657, 311600227311248, 623200454622542, 1246400909245072, 2492801818490121, 4985603636980316]",
        "w": 10326388273894849,
        "m": 11327980406963832,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 52295849050655928, and the following information:\nPublic key: pub_key = \"[5673649875288810, 4019939760128051, 1451545422776520, 3844281430907266, 2714179334750528, 6127625017725862, 4483801115488496, 685798473591470, 3240724936309665, 121786830687441, 3537740710114673, 3297465897230715, 947788282336074, 3536033498251180, 914568646954710, 901199890136921, 834702831756162, 3081191541543663, 4280001912378874, 5723178887113343, 3432984617134038, 6140196522879816, 2573550228761044, 441147530750958, 1581561409726722, 3862389167678250, 1365115293424611, 364000941881930, 3780244695374231, 3311878575072718, 2845741627146805, 1671543494165559, 3840188644171685, 7209781995666257, 477363540239909, 941473898898091, 5674216502376540, 915817476366232, 1629470260348225, 1094875568113397, 5268500311000619, 4177337580069349, 6445787626266792, 1772946557503657, 1192916651621749, 2856428595920611, 6667300958777175, 4837380286202862]\", Private key: priv_key = \"[2, 4, 78, 146, 267, 511, 1089, 2157, 4263, 8578, 17121, 34251, 68562, 137091, 274154, 548349, 1096646, 2193277, 4386574, 8773147, 17546348, 35092657, 70185277, 140370604, 280741185, 561482347, 1122964746, 2245929486, 4491858924, 8983717862, 17967435733, 35934871462, 71869742981, 143739485967, 287478971942, 574957943853, 1149915887728, 2299831775380, 4599663550840, 9199327101594, 18398654203202, 36797308406456, 73594616812870, 147189233625718, 294378467251461, 588756934502917, 1177513869005855, 2355027738011738]\", and additional parameters: m = \"7327359990449569\", w = \"2836824937644405\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 52295849050655928\nm = 7327359990449569\nw = 2836824937644405\npub_key = [5673649875288810, 4019939760128051, 1451545422776520, 3844281430907266, 2714179334750528, 6127625017725862, 4483801115488496, 685798473591470, 3240724936309665, 121786830687441, 3537740710114673, 3297465897230715, 947788282336074, 3536033498251180, 914568646954710, 901199890136921, 834702831756162, 3081191541543663, 4280001912378874, 5723178887113343, 3432984617134038, 6140196522879816, 2573550228761044, 441147530750958, 1581561409726722, 3862389167678250, 1365115293424611, 364000941881930, 3780244695374231, 3311878575072718, 2845741627146805, 1671543494165559, 3840188644171685, 7209781995666257, 477363540239909, 941473898898091, 5674216502376540, 915817476366232, 1629470260348225, 1094875568113397, 5268500311000619, 4177337580069349, 6445787626266792, 1772946557503657, 1192916651621749, 2856428595920611, 6667300958777175, 4837380286202862]\npriv_key = [2, 4, 78, 146, 267, 511, 1089, 2157, 4263, 8578, 17121, 34251, 68562, 137091, 274154, 548349, 1096646, 2193277, 4386574, 8773147, 17546348, 35092657, 70185277, 140370604, 280741185, 561482347, 1122964746, 2245929486, 4491858924, 8983717862, 17967435733, 35934871462, 71869742981, 143739485967, 287478971942, 574957943853, 1149915887728, 2299831775380, 4599663550840, 9199327101594, 18398654203202, 36797308406456, 73594616812870, 147189233625718, 294378467251461, 588756934502917, 1177513869005855, 2355027738011738]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{RJH1L9}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "RJH1L9",
        "ciphertext": 52295849050655928,
        "pub_key": "[5673649875288810, 4019939760128051, 1451545422776520, 3844281430907266, 2714179334750528, 6127625017725862, 4483801115488496, 685798473591470, 3240724936309665, 121786830687441, 3537740710114673, 3297465897230715, 947788282336074, 3536033498251180, 914568646954710, 901199890136921, 834702831756162, 3081191541543663, 4280001912378874, 5723178887113343, 3432984617134038, 6140196522879816, 2573550228761044, 441147530750958, 1581561409726722, 3862389167678250, 1365115293424611, 364000941881930, 3780244695374231, 3311878575072718, 2845741627146805, 1671543494165559, 3840188644171685, 7209781995666257, 477363540239909, 941473898898091, 5674216502376540, 915817476366232, 1629470260348225, 1094875568113397, 5268500311000619, 4177337580069349, 6445787626266792, 1772946557503657, 1192916651621749, 2856428595920611, 6667300958777175, 4837380286202862]",
        "priv_key": "[2, 4, 78, 146, 267, 511, 1089, 2157, 4263, 8578, 17121, 34251, 68562, 137091, 274154, 548349, 1096646, 2193277, 4386574, 8773147, 17546348, 35092657, 70185277, 140370604, 280741185, 561482347, 1122964746, 2245929486, 4491858924, 8983717862, 17967435733, 35934871462, 71869742981, 143739485967, 287478971942, 574957943853, 1149915887728, 2299831775380, 4599663550840, 9199327101594, 18398654203202, 36797308406456, 73594616812870, 147189233625718, 294378467251461, 588756934502917, 1177513869005855, 2355027738011738]",
        "w": 2836824937644405,
        "m": 7327359990449569,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 245709150001756, and the following information:\nPublic key: pub_key = \"[8060011216230, 15611864605244, 2470275116854, 20044257011736, 9881100467416, 19762200934832, 28704779613359, 31705052096380, 7717005410361, 5122546391633, 1458101835825, 13954647831950, 29941926972764, 1212322219059, 27112835914024, 25253395830419, 28070053397791, 955165840399, 31390765505643, 13186326155479, 17296325440296, 9904459404686, 28087751929597, 11083205429105, 21658253030994, 1781312422411, 18158173795634, 11628156115362, 25288943539588, 2725977609012, 15763419647113, 1538247642165, 9612033018912, 9928917263167, 8748876346808, 31366321913217, 29765619230303, 6378928814287, 15517468668649, 19198999426561]\", Private key: priv_key = \"[2, 12, 90, 200, 360, 720, 1417, 2852, 5743, 11455, 22855, 45794, 91556, 183069, 366136, 732277, 1464585, 2929201, 5858389, 11716721, 23433456, 46866914, 93733891, 187467783, 374935574, 749871093, 1499742214, 2999484430, 5998968828, 11997937636, 23995875303, 47991750627, 95983501280, 191967002513, 383934005072, 767868010119, 1535736020177, 3071472040353, 6142944080727, 12285888161447]\", and additional parameters: m = \"32748202692136\", w = \"20404106954183\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 245709150001756\nm = 32748202692136\nw = 20404106954183\npub_key = [8060011216230, 15611864605244, 2470275116854, 20044257011736, 9881100467416, 19762200934832, 28704779613359, 31705052096380, 7717005410361, 5122546391633, 1458101835825, 13954647831950, 29941926972764, 1212322219059, 27112835914024, 25253395830419, 28070053397791, 955165840399, 31390765505643, 13186326155479, 17296325440296, 9904459404686, 28087751929597, 11083205429105, 21658253030994, 1781312422411, 18158173795634, 11628156115362, 25288943539588, 2725977609012, 15763419647113, 1538247642165, 9612033018912, 9928917263167, 8748876346808, 31366321913217, 29765619230303, 6378928814287, 15517468668649, 19198999426561]\npriv_key = [2, 12, 90, 200, 360, 720, 1417, 2852, 5743, 11455, 22855, 45794, 91556, 183069, 366136, 732277, 1464585, 2929201, 5858389, 11716721, 23433456, 46866914, 93733891, 187467783, 374935574, 749871093, 1499742214, 2999484430, 5998968828, 11997937636, 23995875303, 47991750627, 95983501280, 191967002513, 383934005072, 767868010119, 1535736020177, 3071472040353, 6142944080727, 12285888161447]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{251H8}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "251H8",
        "ciphertext": 245709150001756,
        "pub_key": "[8060011216230, 15611864605244, 2470275116854, 20044257011736, 9881100467416, 19762200934832, 28704779613359, 31705052096380, 7717005410361, 5122546391633, 1458101835825, 13954647831950, 29941926972764, 1212322219059, 27112835914024, 25253395830419, 28070053397791, 955165840399, 31390765505643, 13186326155479, 17296325440296, 9904459404686, 28087751929597, 11083205429105, 21658253030994, 1781312422411, 18158173795634, 11628156115362, 25288943539588, 2725977609012, 15763419647113, 1538247642165, 9612033018912, 9928917263167, 8748876346808, 31366321913217, 29765619230303, 6378928814287, 15517468668649, 19198999426561]",
        "priv_key": "[2, 12, 90, 200, 360, 720, 1417, 2852, 5743, 11455, 22855, 45794, 91556, 183069, 366136, 732277, 1464585, 2929201, 5858389, 11716721, 23433456, 46866914, 93733891, 187467783, 374935574, 749871093, 1499742214, 2999484430, 5998968828, 11997937636, 23995875303, 47991750627, 95983501280, 191967002513, 383934005072, 767868010119, 1535736020177, 3071472040353, 6142944080727, 12285888161447]",
        "w": 20404106954183,
        "m": 32748202692136,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 303213958575099, and the following information:\nPublic key: pub_key = \"[1329970104467, 18206725565, 17307818083636, 10730794463561, 20149825548220, 29678096986269, 24813384707526, 34997098265915, 27471566640016, 17795003982781, 9045226052917, 22043948968105, 24192966545900, 20492974349123, 35647861554813, 880134475135, 4456622610334, 2245187972768, 16441900160174, 32883800320348, 36599291970247, 34647657636516, 13509397787678, 34998616202158, 23521105650231, 7215935068712, 7782019615089, 26203800065914, 1923356338777, 2498535847522, 3703515041707, 4747089874480, 22757467342500, 33581617195927, 21962457565541, 28019894054173, 21496978843334, 9799325251688, 6317156184271, 21944103099811]\", Private key: priv_key = \"[3, 29, 68, 169, 364, 733, 1446, 2859, 5680, 11421, 22869, 45689, 91420, 182835, 365629, 731215, 1462494, 2924944, 5849886, 11699772, 23399623, 46799188, 93598366, 187196750, 374393511, 748787048, 1497574081, 2995148186, 5990296345, 11980592658, 23961185371, 47922370736, 95844741444, 191689482919, 383378965765, 766757931581, 1533515863142, 3067031726296, 6134063452591, 12268126905203]\", and additional parameters: m = \"38514512852848\", w = \"13281494319105\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 303213958575099\nm = 38514512852848\nw = 13281494319105\npub_key = [1329970104467, 18206725565, 17307818083636, 10730794463561, 20149825548220, 29678096986269, 24813384707526, 34997098265915, 27471566640016, 17795003982781, 9045226052917, 22043948968105, 24192966545900, 20492974349123, 35647861554813, 880134475135, 4456622610334, 2245187972768, 16441900160174, 32883800320348, 36599291970247, 34647657636516, 13509397787678, 34998616202158, 23521105650231, 7215935068712, 7782019615089, 26203800065914, 1923356338777, 2498535847522, 3703515041707, 4747089874480, 22757467342500, 33581617195927, 21962457565541, 28019894054173, 21496978843334, 9799325251688, 6317156184271, 21944103099811]\npriv_key = [3, 29, 68, 169, 364, 733, 1446, 2859, 5680, 11421, 22869, 45689, 91420, 182835, 365629, 731215, 1462494, 2924944, 5849886, 11699772, 23399623, 46799188, 93598366, 187196750, 374393511, 748787048, 1497574081, 2995148186, 5990296345, 11980592658, 23961185371, 47922370736, 95844741444, 191689482919, 383378965765, 766757931581, 1533515863142, 3067031726296, 6134063452591, 12268126905203]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{I1UGO}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "I1UGO",
        "ciphertext": 303213958575099,
        "pub_key": "[1329970104467, 18206725565, 17307818083636, 10730794463561, 20149825548220, 29678096986269, 24813384707526, 34997098265915, 27471566640016, 17795003982781, 9045226052917, 22043948968105, 24192966545900, 20492974349123, 35647861554813, 880134475135, 4456622610334, 2245187972768, 16441900160174, 32883800320348, 36599291970247, 34647657636516, 13509397787678, 34998616202158, 23521105650231, 7215935068712, 7782019615089, 26203800065914, 1923356338777, 2498535847522, 3703515041707, 4747089874480, 22757467342500, 33581617195927, 21962457565541, 28019894054173, 21496978843334, 9799325251688, 6317156184271, 21944103099811]",
        "priv_key": "[3, 29, 68, 169, 364, 733, 1446, 2859, 5680, 11421, 22869, 45689, 91420, 182835, 365629, 731215, 1462494, 2924944, 5849886, 11699772, 23399623, 46799188, 93598366, 187196750, 374393511, 748787048, 1497574081, 2995148186, 5990296345, 11980592658, 23961185371, 47922370736, 95844741444, 191689482919, 383378965765, 766757931581, 1533515863142, 3067031726296, 6134063452591, 12268126905203]",
        "w": 13281494319105,
        "m": 38514512852848,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 11749602720496588077460, and the following information:\nPublic key: pub_key = \"[557414106326337925458, 397782366016230012614, 78518885396014186926, 633825391488912486953, 392432303885190963443, 385947380089992115963, 454738879793208031669, 590538525155960180024, 144767723055258696058, 609123172920493160178, 102607517713910613505, 444824768987863067463, 571520919019670107547, 106570387687798579917, 372610392590825101491, 506908036380648132025, 694228345951320495988, 434232958129352881026, 151257946527379952563, 700622505260749860114, 47941925972941827168, 573157841927407680998, 190470719132727539176, 698907934126631134544, 521786773686228402690, 168517191374702766104, 655649370990101473148, 674393011688571006790, 392454689370414277199, 467267129069412440580, 58505163571791014762, 513819954590532215016, 709835536414768345027, 66367988280978796994, 212713969811891521597, 583924818269731157729, 610597653308004361187, 185372348643986971945, 212247818642025829355, 344517644034117731101, 132107551026537450305, 264215102053074900610, 289306839830747874328, 419468308636027749373, 519348890462079730684, 83663431676471494483, 166678370973423104218, 174373494016258180340, 429535596756850144224, 619785706143418390369, 44116714004707117465, 88557674199174177304, 415914466483990339126, 114783086331534839950, 549316022567925419149, 142624957318883044291, 205434044482712132160, 330403726430850423150, 25036584234228705103, 128592053864471597132, 18709235833061152120, 516313692596446042772, 474078417202394361777, 630190338543612667362]\", Private key: priv_key = \"[2, 22, 62, 181, 319, 679, 1281, 2584, 5226, 10394, 20829, 41619, 83215, 166497, 332983, 665933, 1331924, 2663770, 5327567, 10655138, 21310248, 42620526, 85241064, 170482160, 340964322, 681928592, 1363857180, 2727714350, 5455428739, 10910857428, 21821714858, 43643429792, 87286859543, 174573719058, 349147438097, 698294876237, 1396589752463, 2793179504957, 5586359009871, 11172718019761, 22345436039493, 44690872078986, 89381744157984, 178763488315961, 357526976631980, 715053953263927, 1430107906527890, 2860215813055764, 5720431626111464, 11440863252222949, 22881726504445949, 45763453008891880, 91526906017783766, 183053812035567550, 366107624071135033, 732215248142270087, 1464430496284540184, 2928860992569080414, 5857721985138160755, 11715443970276321572, 23430887940552643120, 46861775881105286180, 93723551762210572421, 187447103524421144810]\", and additional parameters: m = \"716721600446685895928\", w = \"637067853386511910693\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 11749602720496588077460\nm = 716721600446685895928\nw = 637067853386511910693\npub_key = [557414106326337925458, 397782366016230012614, 78518885396014186926, 633825391488912486953, 392432303885190963443, 385947380089992115963, 454738879793208031669, 590538525155960180024, 144767723055258696058, 609123172920493160178, 102607517713910613505, 444824768987863067463, 571520919019670107547, 106570387687798579917, 372610392590825101491, 506908036380648132025, 694228345951320495988, 434232958129352881026, 151257946527379952563, 700622505260749860114, 47941925972941827168, 573157841927407680998, 190470719132727539176, 698907934126631134544, 521786773686228402690, 168517191374702766104, 655649370990101473148, 674393011688571006790, 392454689370414277199, 467267129069412440580, 58505163571791014762, 513819954590532215016, 709835536414768345027, 66367988280978796994, 212713969811891521597, 583924818269731157729, 610597653308004361187, 185372348643986971945, 212247818642025829355, 344517644034117731101, 132107551026537450305, 264215102053074900610, 289306839830747874328, 419468308636027749373, 519348890462079730684, 83663431676471494483, 166678370973423104218, 174373494016258180340, 429535596756850144224, 619785706143418390369, 44116714004707117465, 88557674199174177304, 415914466483990339126, 114783086331534839950, 549316022567925419149, 142624957318883044291, 205434044482712132160, 330403726430850423150, 25036584234228705103, 128592053864471597132, 18709235833061152120, 516313692596446042772, 474078417202394361777, 630190338543612667362]\npriv_key = [2, 22, 62, 181, 319, 679, 1281, 2584, 5226, 10394, 20829, 41619, 83215, 166497, 332983, 665933, 1331924, 2663770, 5327567, 10655138, 21310248, 42620526, 85241064, 170482160, 340964322, 681928592, 1363857180, 2727714350, 5455428739, 10910857428, 21821714858, 43643429792, 87286859543, 174573719058, 349147438097, 698294876237, 1396589752463, 2793179504957, 5586359009871, 11172718019761, 22345436039493, 44690872078986, 89381744157984, 178763488315961, 357526976631980, 715053953263927, 1430107906527890, 2860215813055764, 5720431626111464, 11440863252222949, 22881726504445949, 45763453008891880, 91526906017783766, 183053812035567550, 366107624071135033, 732215248142270087, 1464430496284540184, 2928860992569080414, 5857721985138160755, 11715443970276321572, 23430887940552643120, 46861775881105286180, 93723551762210572421, 187447103524421144810]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{OAOMZZ33}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "OAOMZZ33",
        "ciphertext": 11749602720496588077460,
        "pub_key": "[557414106326337925458, 397782366016230012614, 78518885396014186926, 633825391488912486953, 392432303885190963443, 385947380089992115963, 454738879793208031669, 590538525155960180024, 144767723055258696058, 609123172920493160178, 102607517713910613505, 444824768987863067463, 571520919019670107547, 106570387687798579917, 372610392590825101491, 506908036380648132025, 694228345951320495988, 434232958129352881026, 151257946527379952563, 700622505260749860114, 47941925972941827168, 573157841927407680998, 190470719132727539176, 698907934126631134544, 521786773686228402690, 168517191374702766104, 655649370990101473148, 674393011688571006790, 392454689370414277199, 467267129069412440580, 58505163571791014762, 513819954590532215016, 709835536414768345027, 66367988280978796994, 212713969811891521597, 583924818269731157729, 610597653308004361187, 185372348643986971945, 212247818642025829355, 344517644034117731101, 132107551026537450305, 264215102053074900610, 289306839830747874328, 419468308636027749373, 519348890462079730684, 83663431676471494483, 166678370973423104218, 174373494016258180340, 429535596756850144224, 619785706143418390369, 44116714004707117465, 88557674199174177304, 415914466483990339126, 114783086331534839950, 549316022567925419149, 142624957318883044291, 205434044482712132160, 330403726430850423150, 25036584234228705103, 128592053864471597132, 18709235833061152120, 516313692596446042772, 474078417202394361777, 630190338543612667362]",
        "priv_key": "[2, 22, 62, 181, 319, 679, 1281, 2584, 5226, 10394, 20829, 41619, 83215, 166497, 332983, 665933, 1331924, 2663770, 5327567, 10655138, 21310248, 42620526, 85241064, 170482160, 340964322, 681928592, 1363857180, 2727714350, 5455428739, 10910857428, 21821714858, 43643429792, 87286859543, 174573719058, 349147438097, 698294876237, 1396589752463, 2793179504957, 5586359009871, 11172718019761, 22345436039493, 44690872078986, 89381744157984, 178763488315961, 357526976631980, 715053953263927, 1430107906527890, 2860215813055764, 5720431626111464, 11440863252222949, 22881726504445949, 45763453008891880, 91526906017783766, 183053812035567550, 366107624071135033, 732215248142270087, 1464430496284540184, 2928860992569080414, 5857721985138160755, 11715443970276321572, 23430887940552643120, 46861775881105286180, 93723551762210572421, 187447103524421144810]",
        "w": 637067853386511910693,
        "m": 716721600446685895928,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 29408700134156515375, and the following information:\nPublic key: pub_key = \"[992097654901611187, 365172363275244603, 290856154203869512, 394275589127992134, 1153723541531228871, 594705776894606526, 730520830874095004, 216892153779706017, 298057305741726455, 764149180194701446, 138720775318984145, 1844754779703884750, 1223817035080115298, 1778700136356051878, 758842952002767908, 1549993470899098773, 269122054195298741, 955126189127903396, 866445005892134294, 1471137083433146607, 1627012790867249558, 1896755563557643326, 1683289890778627876, 1611829833211592402, 1927800440992639502, 963325201636069711, 1800624476738703020, 1429616924394436776, 1876837269171511542, 1142553936913434126, 876128138187951151, 1939692995655649192, 1801472321868202565, 1450714765221934220, 1178987148991768047, 916686995451056036, 631233125111440215, 1566227820751814545, 1513432694975651319, 1731006164520757336, 1258072733064982451, 386522079224807772, 427273945742869295, 2024381190382847490, 1156486700416485687, 1007413100118176895, 302084894068502574, 1605968518322865512, 1447486013015818497, 335561142064109347, 1110610856474838388, 1019080847159004919, 1527561253940830479, 809174269727316603, 1356595611103511225, 321814906950743339]\", Private key: priv_key = \"[7, 23, 96, 158, 339, 670, 1300, 2677, 5351, 10646, 21321, 42602, 85254, 170538, 341044, 682029, 1364085, 2728224, 5456410, 10912859, 21825674, 43651318, 87302664, 174605334, 349210714, 698421379, 1396842800, 2793685552, 5587371142, 11174742286, 22349484511, 44698969056, 89397938081, 178795876204, 357591752355, 715183504708, 1430367009479, 2860734018905, 5721468037819, 11442936075684, 22885872151379, 45771744302696, 91543488605459, 183086977210914, 366173954421779, 732347908843559, 1464695817687110, 2929391635374272, 5858783270748505, 11717566541497043, 23435133082994036, 46870266165988135, 93740532331976199, 187481064663952423, 374962129327904885, 749924258655809747]\", and additional parameters: m = \"2026203951981034508\", w = \"720643651266240029\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 29408700134156515375\nm = 2026203951981034508\nw = 720643651266240029\npub_key = [992097654901611187, 365172363275244603, 290856154203869512, 394275589127992134, 1153723541531228871, 594705776894606526, 730520830874095004, 216892153779706017, 298057305741726455, 764149180194701446, 138720775318984145, 1844754779703884750, 1223817035080115298, 1778700136356051878, 758842952002767908, 1549993470899098773, 269122054195298741, 955126189127903396, 866445005892134294, 1471137083433146607, 1627012790867249558, 1896755563557643326, 1683289890778627876, 1611829833211592402, 1927800440992639502, 963325201636069711, 1800624476738703020, 1429616924394436776, 1876837269171511542, 1142553936913434126, 876128138187951151, 1939692995655649192, 1801472321868202565, 1450714765221934220, 1178987148991768047, 916686995451056036, 631233125111440215, 1566227820751814545, 1513432694975651319, 1731006164520757336, 1258072733064982451, 386522079224807772, 427273945742869295, 2024381190382847490, 1156486700416485687, 1007413100118176895, 302084894068502574, 1605968518322865512, 1447486013015818497, 335561142064109347, 1110610856474838388, 1019080847159004919, 1527561253940830479, 809174269727316603, 1356595611103511225, 321814906950743339]\npriv_key = [7, 23, 96, 158, 339, 670, 1300, 2677, 5351, 10646, 21321, 42602, 85254, 170538, 341044, 682029, 1364085, 2728224, 5456410, 10912859, 21825674, 43651318, 87302664, 174605334, 349210714, 698421379, 1396842800, 2793685552, 5587371142, 11174742286, 22349484511, 44698969056, 89397938081, 178795876204, 357591752355, 715183504708, 1430367009479, 2860734018905, 5721468037819, 11442936075684, 22885872151379, 45771744302696, 91543488605459, 183086977210914, 366173954421779, 732347908843559, 1464695817687110, 2929391635374272, 5858783270748505, 11717566541497043, 23435133082994036, 46870266165988135, 93740532331976199, 187481064663952423, 374962129327904885, 749924258655809747]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{0774IK2}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "0774IK2",
        "ciphertext": 29408700134156515375,
        "pub_key": "[992097654901611187, 365172363275244603, 290856154203869512, 394275589127992134, 1153723541531228871, 594705776894606526, 730520830874095004, 216892153779706017, 298057305741726455, 764149180194701446, 138720775318984145, 1844754779703884750, 1223817035080115298, 1778700136356051878, 758842952002767908, 1549993470899098773, 269122054195298741, 955126189127903396, 866445005892134294, 1471137083433146607, 1627012790867249558, 1896755563557643326, 1683289890778627876, 1611829833211592402, 1927800440992639502, 963325201636069711, 1800624476738703020, 1429616924394436776, 1876837269171511542, 1142553936913434126, 876128138187951151, 1939692995655649192, 1801472321868202565, 1450714765221934220, 1178987148991768047, 916686995451056036, 631233125111440215, 1566227820751814545, 1513432694975651319, 1731006164520757336, 1258072733064982451, 386522079224807772, 427273945742869295, 2024381190382847490, 1156486700416485687, 1007413100118176895, 302084894068502574, 1605968518322865512, 1447486013015818497, 335561142064109347, 1110610856474838388, 1019080847159004919, 1527561253940830479, 809174269727316603, 1356595611103511225, 321814906950743339]",
        "priv_key": "[7, 23, 96, 158, 339, 670, 1300, 2677, 5351, 10646, 21321, 42602, 85254, 170538, 341044, 682029, 1364085, 2728224, 5456410, 10912859, 21825674, 43651318, 87302664, 174605334, 349210714, 698421379, 1396842800, 2793685552, 5587371142, 11174742286, 22349484511, 44698969056, 89397938081, 178795876204, 357591752355, 715183504708, 1430367009479, 2860734018905, 5721468037819, 11442936075684, 22885872151379, 45771744302696, 91543488605459, 183086977210914, 366173954421779, 732347908843559, 1464695817687110, 2929391635374272, 5858783270748505, 11717566541497043, 23435133082994036, 46870266165988135, 93740532331976199, 187481064663952423, 374962129327904885, 749924258655809747]",
        "w": 720643651266240029,
        "m": 2026203951981034508,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 371719105000068, and the following information:\nPublic key: pub_key = \"[36913412676621, 12459318877890, 13548973179531, 38467610935311, 2018742215739, 30566701776059, 25726385406866, 261089555556, 23574063435906, 1252728337088, 16471170083435, 39536647306827, 2442050312538, 2392236849498, 31626246215873, 7285453737278, 7976600334599, 35111011744477, 21834761178652, 46161386132882, 20987810688100, 24220019774858, 40860263165550, 47403162487489, 9401464930623, 22592818053329, 7078384070964, 6576991757762, 31013770174298, 8448180372274, 30862074153807, 47758434898355, 7620145976777, 42082064470431, 34374657156623, 15274139394356, 7704764578782, 12917665381986, 22045442571889, 42584490612409]\", Private key: priv_key = \"[5, 100, 167, 367, 657, 1391, 2692, 5478, 10908, 21836, 43687, 87291, 174666, 349312, 698587, 1397152, 2794387, 5588753, 11177506, 22355032, 44710074, 89420122, 178840222, 357680421, 715360875, 1430721761, 2861443488, 5722886954, 11445773896, 22891547828, 45783095671, 91566191327, 183132382667, 366264765297, 732529530641, 1465059061280, 2930118122532, 5860236245044, 11720472490077, 23440944980239]\", and additional parameters: m = \"48387262310302\", w = \"26737587459445\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 371719105000068\nm = 48387262310302\nw = 26737587459445\npub_key = [36913412676621, 12459318877890, 13548973179531, 38467610935311, 2018742215739, 30566701776059, 25726385406866, 261089555556, 23574063435906, 1252728337088, 16471170083435, 39536647306827, 2442050312538, 2392236849498, 31626246215873, 7285453737278, 7976600334599, 35111011744477, 21834761178652, 46161386132882, 20987810688100, 24220019774858, 40860263165550, 47403162487489, 9401464930623, 22592818053329, 7078384070964, 6576991757762, 31013770174298, 8448180372274, 30862074153807, 47758434898355, 7620145976777, 42082064470431, 34374657156623, 15274139394356, 7704764578782, 12917665381986, 22045442571889, 42584490612409]\npriv_key = [5, 100, 167, 367, 657, 1391, 2692, 5478, 10908, 21836, 43687, 87291, 174666, 349312, 698587, 1397152, 2794387, 5588753, 11177506, 22355032, 44710074, 89420122, 178840222, 357680421, 715360875, 1430721761, 2861443488, 5722886954, 11445773896, 22891547828, 45783095671, 91566191327, 183132382667, 366264765297, 732529530641, 1465059061280, 2930118122532, 5860236245044, 11720472490077, 23440944980239]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{5IOT2}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "5IOT2",
        "ciphertext": 371719105000068,
        "pub_key": "[36913412676621, 12459318877890, 13548973179531, 38467610935311, 2018742215739, 30566701776059, 25726385406866, 261089555556, 23574063435906, 1252728337088, 16471170083435, 39536647306827, 2442050312538, 2392236849498, 31626246215873, 7285453737278, 7976600334599, 35111011744477, 21834761178652, 46161386132882, 20987810688100, 24220019774858, 40860263165550, 47403162487489, 9401464930623, 22592818053329, 7078384070964, 6576991757762, 31013770174298, 8448180372274, 30862074153807, 47758434898355, 7620145976777, 42082064470431, 34374657156623, 15274139394356, 7704764578782, 12917665381986, 22045442571889, 42584490612409]",
        "priv_key": "[5, 100, 167, 367, 657, 1391, 2692, 5478, 10908, 21836, 43687, 87291, 174666, 349312, 698587, 1397152, 2794387, 5588753, 11177506, 22355032, 44710074, 89420122, 178840222, 357680421, 715360875, 1430721761, 2861443488, 5722886954, 11445773896, 22891547828, 45783095671, 91566191327, 183132382667, 366264765297, 732529530641, 1465059061280, 2930118122532, 5860236245044, 11720472490077, 23440944980239]",
        "w": 26737587459445,
        "m": 48387262310302,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using KNAPSACK: 47835941487717861216, and the following information:\nPublic key: pub_key = \"[3257963276432371716, 1596363025078685988, 22303482865855683, 4658056881911869381, 5008777459249480176, 374697282526033787, 509075920495356988, 4407147310747274275, 1861222263699717106, 2191876469369937067, 732135341560747566, 1354984231888973129, 1310432599072637696, 1396410751721677676, 343912610596159920, 3027447662806993269, 872709670405362825, 805332763901360783, 2550752104712086433, 2718390283626166277, 2003735872538249992, 224821954573184833, 362103200005514243, 4594396899655199060, 814439834718591534, 2153566183508126503, 2142591343683290423, 2994933273893794287, 2316503208516795426, 3911492742589269991, 1088486029848752544, 55922520547875665, 1926780968639481324, 4990475674561704941, 2109538156510880151, 64517943863356879, 304117306008424604, 2357375572511390359, 2659496572922340138, 2891829995089151424, 3137923936957729990, 3936225432300786551, 3696146753351503099, 3522103007058835624, 1009474491140538091, 4161744263522372185, 1916848425412522941, 663274283533529589, 4103316813611820619, 4730097448326225516, 3337922664534462452, 553573096950936324, 4365109470334244364, 5702139513260450, 3466194715832270042, 4592766990049866655]\", Private key: priv_key = \"[6, 78, 183, 301, 666, 1247, 2578, 5095, 10246, 20497, 40956, 81929, 163796, 327596, 655200, 1310409, 2620785, 5241623, 10483193, 20966477, 41932882, 83865793, 167731553, 335463110, 670926264, 1341852493, 2683705043, 5367410007, 10734820026, 21469640071, 42939280164, 85878560285, 171757120614, 343514241191, 687028482441, 1374056964829, 2748113929724, 5496227859409, 10992455718858, 21984911437674, 43969822875340, 87939645750671, 175879291501339, 351758583002674, 703517166005401, 1407034332010795, 2814068664021561, 5628137328043149, 11256274656086239, 22512549312172506, 45025098624345032, 90050197248690084, 180100394497380174, 360200788994760260, 720401577989520542, 1440803155979041075]\", and additional parameters: m = \"5094644946067768290\", w = \"4788531334461868861\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nimport gmpy2\nciphertext = 47835941487717861216\nm = 5094644946067768290\nw = 4788531334461868861\npub_key = [3257963276432371716, 1596363025078685988, 22303482865855683, 4658056881911869381, 5008777459249480176, 374697282526033787, 509075920495356988, 4407147310747274275, 1861222263699717106, 2191876469369937067, 732135341560747566, 1354984231888973129, 1310432599072637696, 1396410751721677676, 343912610596159920, 3027447662806993269, 872709670405362825, 805332763901360783, 2550752104712086433, 2718390283626166277, 2003735872538249992, 224821954573184833, 362103200005514243, 4594396899655199060, 814439834718591534, 2153566183508126503, 2142591343683290423, 2994933273893794287, 2316503208516795426, 3911492742589269991, 1088486029848752544, 55922520547875665, 1926780968639481324, 4990475674561704941, 2109538156510880151, 64517943863356879, 304117306008424604, 2357375572511390359, 2659496572922340138, 2891829995089151424, 3137923936957729990, 3936225432300786551, 3696146753351503099, 3522103007058835624, 1009474491140538091, 4161744263522372185, 1916848425412522941, 663274283533529589, 4103316813611820619, 4730097448326225516, 3337922664534462452, 553573096950936324, 4365109470334244364, 5702139513260450, 3466194715832270042, 4592766990049866655]\npriv_key = [6, 78, 183, 301, 666, 1247, 2578, 5095, 10246, 20497, 40956, 81929, 163796, 327596, 655200, 1310409, 2620785, 5241623, 10483193, 20966477, 41932882, 83865793, 167731553, 335463110, 670926264, 1341852493, 2683705043, 5367410007, 10734820026, 21469640071, 42939280164, 85878560285, 171757120614, 343514241191, 687028482441, 1374056964829, 2748113929724, 5496227859409, 10992455718858, 21984911437674, 43969822875340, 87939645750671, 175879291501339, 351758583002674, 703517166005401, 1407034332010795, 2814068664021561, 5628137328043149, 11256274656086239, 22512549312172506, 45025098624345032, 90050197248690084, 180100394497380174, 360200788994760260, 720401577989520542, 1440803155979041075]\n\nw_inv = gmpy2.invert(w, m)\n\ns = (w_inv * ciphertext) % m\n\nbits = []\nfor val in reversed(priv_key):\n    if val <= s:\n        bits.append(1)\n        s -= val\n    else:\n        bits.append(0)\nbits = list(reversed(bits))\n\nchars = [chr(int(''.join(map(str, bits[i:i+8])), 2)) for i in range(0, len(bits), 8)]\nplaintext = ''.join(chars)\nprint(f'PCTF{{{plaintext}}}')\n\n",
    "final_answer": "PCTF{E23R46D}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "KNAPSACK",
      "change_detail": "Use public key, private key, m and w to decrypt the block.",
      "synthesis_code": "\nimport random\nimport gmpy2\nm = random.randint(sum(priv_key) + 1, 2 * sum(priv_key))\nw = random.randint(2, m - 1)\nwhile gmpy2.gcd(w, m) != 1:\n    w = random.randint(2, m - 1)\npub_key = [(w * x) % m for x in priv_key]\n\nplaintext = \"{plaintext}\"  \npub_key = \"{pub_key}\"\npriv_key = \"{priv_key}\"\nm = \"{m}\"\nw = \"{w}\"\n\nmsg_bits = ''.join(format(ord(c), '08b') for c in plaintext)\npub_key = pub_key.replace(' ', '').replace('L', '').strip('[]').split(',')\npub_key = [int(x) for x in pub_key]\n\nciphertext = sum(int(b) * pk for b, pk in zip(msg_bits, pub_key))\nprint(ciphertext)\n",
      "original_data": {
        "plaintext": "E23R46D",
        "ciphertext": 47835941487717861216,
        "pub_key": "[3257963276432371716, 1596363025078685988, 22303482865855683, 4658056881911869381, 5008777459249480176, 374697282526033787, 509075920495356988, 4407147310747274275, 1861222263699717106, 2191876469369937067, 732135341560747566, 1354984231888973129, 1310432599072637696, 1396410751721677676, 343912610596159920, 3027447662806993269, 872709670405362825, 805332763901360783, 2550752104712086433, 2718390283626166277, 2003735872538249992, 224821954573184833, 362103200005514243, 4594396899655199060, 814439834718591534, 2153566183508126503, 2142591343683290423, 2994933273893794287, 2316503208516795426, 3911492742589269991, 1088486029848752544, 55922520547875665, 1926780968639481324, 4990475674561704941, 2109538156510880151, 64517943863356879, 304117306008424604, 2357375572511390359, 2659496572922340138, 2891829995089151424, 3137923936957729990, 3936225432300786551, 3696146753351503099, 3522103007058835624, 1009474491140538091, 4161744263522372185, 1916848425412522941, 663274283533529589, 4103316813611820619, 4730097448326225516, 3337922664534462452, 553573096950936324, 4365109470334244364, 5702139513260450, 3466194715832270042, 4592766990049866655]",
        "priv_key": "[6, 78, 183, 301, 666, 1247, 2578, 5095, 10246, 20497, 40956, 81929, 163796, 327596, 655200, 1310409, 2620785, 5241623, 10483193, 20966477, 41932882, 83865793, 167731553, 335463110, 670926264, 1341852493, 2683705043, 5367410007, 10734820026, 21469640071, 42939280164, 85878560285, 171757120614, 343514241191, 687028482441, 1374056964829, 2748113929724, 5496227859409, 10992455718858, 21984911437674, 43969822875340, 87939645750671, 175879291501339, 351758583002674, 703517166005401, 1407034332010795, 2814068664021561, 5628137328043149, 11256274656086239, 22512549312172506, 45025098624345032, 90050197248690084, 180100394497380174, 360200788994760260, 720401577989520542, 1440803155979041075]",
        "w": 4788531334461868861,
        "m": 5094644946067768290,
        "compute": 1
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x94481e39ea9d8a and the public key used for encryption:\nN=2258359228425034087 e = 23\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 2258359228425034087\ne = 23\nc = 0x94481e39ea9d8a\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{hey}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x94481e39ea9d8a",
        "p": 563890441,
        "q": 4004961007,
        "N": 2258359228425034087,
        "e": 23,
        "plaintext": "hey",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x1a1ee545e2502181 and the public key used for encryption:\nN=4341529267120529251 e = 2845007187134162515\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 4341529267120529251\ne = 2845007187134162515\nc = 0x1a1ee545e2502181\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{nihao}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x1a1ee545e2502181",
        "p": 1459284829,
        "q": 2975107519,
        "N": 4341529267120529251,
        "e": 2845007187134162515,
        "plaintext": "nihao",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x16691a762d7dcb3d and the public key used for encryption:\nN=2441910617965773509 e = 603134646325348783\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 2441910617965773509\ne = 603134646325348783\nc = 0x16691a762d7dcb3d\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{camel}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x16691a762d7dcb3d",
        "p": 1850649751,
        "q": 1319488259,
        "N": 2441910617965773509,
        "e": 603134646325348783,
        "plaintext": "camel",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x6f063633534e42 and the public key used for encryption:\nN=522376429967292827 e = 193248801611151089\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 522376429967292827\ne = 193248801611151089\nc = 0x6f063633534e42\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{ai}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x6f063633534e42",
        "p": 2202794591,
        "q": 237142597,
        "N": 522376429967292827,
        "e": 193248801611151089,
        "plaintext": "ai",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x609ad702d9451443 and the public key used for encryption:\nN=13266860596078837907 e = 197994784017516463\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 13266860596078837907\ne = 197994784017516463\nc = 0x609ad702d9451443\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{hi}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x609ad702d9451443",
        "p": 3397561159,
        "q": 3904818773,
        "N": 13266860596078837907,
        "e": 197994784017516463,
        "plaintext": "hi",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x11b02fc5c950cae1 and the public key used for encryption:\nN=1540706013873891259 e = 457\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 1540706013873891259\ne = 457\nc = 0x11b02fc5c950cae1\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{test}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x11b02fc5c950cae1",
        "p": 813366401,
        "q": 1894233659,
        "N": 1540706013873891259,
        "e": 457,
        "plaintext": "test",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0xa0dd131ced72975 and the public key used for encryption:\nN=1568628860290297703 e = 679\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 1568628860290297703\ne = 679\nc = 0xa0dd131ced72975\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{openai}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xa0dd131ced72975",
        "p": 645004069,
        "q": 2431967387,
        "N": 1568628860290297703,
        "e": 679,
        "plaintext": "openai",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0xd9f3e5e67be0e5b and the public key used for encryption:\nN=1506382705373134739 e = 1236253583239884445\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 1506382705373134739\ne = 1236253583239884445\nc = 0xd9f3e5e67be0e5b\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{claude}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xd9f3e5e67be0e5b",
        "p": 1678407607,
        "q": 897507077,
        "N": 1506382705373134739,
        "e": 1236253583239884445,
        "plaintext": "claude",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0xb95b45c1fb25fb and the public key used for encryption:\nN=1138732167217225253 e = 2047\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 1138732167217225253\ne = 2047\nc = 0xb95b45c1fb25fb\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{llama}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xb95b45c1fb25fb",
        "p": 763596697,
        "q": 1491274349,
        "N": 1138732167217225253,
        "e": 2047,
        "plaintext": "llama",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted information: 0x42587042dbfb71f and the public key used for encryption:\nN=388530894333266117 e = 65537\nPlease decrypt the plaintext and submit the result as ASCII code.\nFor example, if the decrypted plaintext is 0x6162, submit the string 'ab'\nSubmit in the format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nimport sympy\n\n# Given public key parameters and ciphertext\nN = 388530894333266117\ne = 65537\nc = 0x42587042dbfb71f\n\n# Step 1: Factor N\nfactors = sympy.factorint(N)\np, q = list(factors.keys())\n\n# Step 2: Calculate φ(N)\nphi_n = (p - 1) * (q - 1)\n\n# Step 3: Calculate the private exponent d\nd = gmpy2.invert(e, phi_n)\n\n# Step 4: RSA decryption\nm = gmpy2.powmod(c, d, N)\n\n# Step 5: Convert the integer plaintext to ASCII string\ntmp = hex(m)[2:]\n\n# Ensure length is even (otherwise bytes.fromhex will raise an error)\nif len(tmp) % 2 != 0:\n    tmp = '0' + tmp\n\n# Convert hex to bytes and decode\nplaintext = bytes.fromhex(tmp).decode('utf-8')\n\nprint(f'PCTF{{{plaintext}}}')\n",
    "final_answer": "PCTF{mistral}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_N_Factorization",
      "change_detail": "In the RSA algorithm, when the bit length of N is less than 512, one can use a large-integer factorization strategy to obtain p and q.",
      "synthesis_code": "import gmpy2\nN = {N} # RSA modulus (product of two primes)\ne = {e}               # Public exponent\nplaintext = \"{plaintext}\"  # The message you want to encrypt\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nif m >= N:\n    raise ValueError(\"Message too large for the given modulus N\")\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x42587042dbfb71f",
        "p": 1513448257,
        "q": 256718981,
        "N": 388530894333266117,
        "e": 65537,
        "plaintext": "mistral",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 0594e93f52601bb91c42898516298524, and the following public key:\nkey = \"15cc2f87d760a8787e5bcd10b2708e28\", iv = \"dcd7a73044f332804ef4c22dcd792fd2\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"15cc2f87d760a8787e5bcd10b2708e28\")\niv = bytes.fromhex(\"dcd7a73044f332804ef4c22dcd792fd2\")\nciphertext = bytes.fromhex(\"0594e93f52601bb91c42898516298524\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{Cs1FGjy0}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "Cs1FGjy0",
        "ciphertext": "0594e93f52601bb91c42898516298524",
        "key": "15cc2f87d760a8787e5bcd10b2708e28",
        "iv": "dcd7a73044f332804ef4c22dcd792fd2",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 90e039503b122c598cfe17ad363011fd53e56944fed43b6002f19f04d05ff29a, and the following public key:\nkey = \"dc13e20088aea7c220c1f999ed7ee73a\", iv = \"5f6775c7057489d07b0eb63c760f4ff4\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"dc13e20088aea7c220c1f999ed7ee73a\")\niv = bytes.fromhex(\"5f6775c7057489d07b0eb63c760f4ff4\")\nciphertext = bytes.fromhex(\"90e039503b122c598cfe17ad363011fd53e56944fed43b6002f19f04d05ff29a\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{1ceZ06rkPqci7oOdiONFzA2dwB3}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "1ceZ06rkPqci7oOdiONFzA2dwB3",
        "ciphertext": "90e039503b122c598cfe17ad363011fd53e56944fed43b6002f19f04d05ff29a",
        "key": "dc13e20088aea7c220c1f999ed7ee73a",
        "iv": "5f6775c7057489d07b0eb63c760f4ff4",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 662604bfbbddaa8ffa921453cfa669ca, and the following public key:\nkey = \"538307148b5afb479ed989a45e9b02bd\", iv = \"e6fd630bafb556b9975da26d9accb692\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"538307148b5afb479ed989a45e9b02bd\")\niv = bytes.fromhex(\"e6fd630bafb556b9975da26d9accb692\")\nciphertext = bytes.fromhex(\"662604bfbbddaa8ffa921453cfa669ca\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{Q3aiegmHWm6Xr2}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "Q3aiegmHWm6Xr2",
        "ciphertext": "662604bfbbddaa8ffa921453cfa669ca",
        "key": "538307148b5afb479ed989a45e9b02bd",
        "iv": "e6fd630bafb556b9975da26d9accb692",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 71aed16f937057cd0fd7ec72718df8acaa0ca4164f9fe2ef49e805ba57c02816, and the following public key:\nkey = \"21ac0029387dc8ed7f62f506d24d9616\", iv = \"001d59e9476aeddfefdd5314c753504f\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"21ac0029387dc8ed7f62f506d24d9616\")\niv = bytes.fromhex(\"001d59e9476aeddfefdd5314c753504f\")\nciphertext = bytes.fromhex(\"71aed16f937057cd0fd7ec72718df8acaa0ca4164f9fe2ef49e805ba57c02816\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{fX1HKfgWMKYqLsqDw2onkEQqXRJHgkj}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "fX1HKfgWMKYqLsqDw2onkEQqXRJHgkj",
        "ciphertext": "71aed16f937057cd0fd7ec72718df8acaa0ca4164f9fe2ef49e805ba57c02816",
        "key": "21ac0029387dc8ed7f62f506d24d9616",
        "iv": "001d59e9476aeddfefdd5314c753504f",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 706488b0f21f6cce0091e863bfe8997b, and the following public key:\nkey = \"4c2f274760e3b7263268bdef33807dde\", iv = \"9a7089e8a423d268c4a3e5404539b035\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"4c2f274760e3b7263268bdef33807dde\")\niv = bytes.fromhex(\"9a7089e8a423d268c4a3e5404539b035\")\nciphertext = bytes.fromhex(\"706488b0f21f6cce0091e863bfe8997b\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{pH0Ci84nNtHzk}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "pH0Ci84nNtHzk",
        "ciphertext": "706488b0f21f6cce0091e863bfe8997b",
        "key": "4c2f274760e3b7263268bdef33807dde",
        "iv": "9a7089e8a423d268c4a3e5404539b035",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: 5726b2ccb1053f4d94937e249960f70992af654526cc67702ae50b7d7a461adfdd0cc3757815c5cb7305a133e058a7a2, and the following public key:\nkey = \"7213112a4fbff6837b7783f354853faf\", iv = \"9b564d7e0d6158aa2d1df7b8ec451de8\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"7213112a4fbff6837b7783f354853faf\")\niv = bytes.fromhex(\"9b564d7e0d6158aa2d1df7b8ec451de8\")\nciphertext = bytes.fromhex(\"5726b2ccb1053f4d94937e249960f70992af654526cc67702ae50b7d7a461adfdd0cc3757815c5cb7305a133e058a7a2\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{glww9iQoSRYRnH2kNIifgjhz7u7pMolv}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "glww9iQoSRYRnH2kNIifgjhz7u7pMolv",
        "ciphertext": "5726b2ccb1053f4d94937e249960f70992af654526cc67702ae50b7d7a461adfdd0cc3757815c5cb7305a133e058a7a2",
        "key": "7213112a4fbff6837b7783f354853faf",
        "iv": "9b564d7e0d6158aa2d1df7b8ec451de8",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: ba816908c1d2294e27b9b82c4f62cb718c625c43072f3cec72362de108177aa2, and the following public key:\nkey = \"48e76d06c0cf32bd12faea778b6d8c33\", iv = \"4e7e6bf81964c72bdee692a524d3b533\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"48e76d06c0cf32bd12faea778b6d8c33\")\niv = bytes.fromhex(\"4e7e6bf81964c72bdee692a524d3b533\")\nciphertext = bytes.fromhex(\"ba816908c1d2294e27b9b82c4f62cb718c625c43072f3cec72362de108177aa2\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{3PfsiWBGRzwrVdGWndK2NhT}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "3PfsiWBGRzwrVdGWndK2NhT",
        "ciphertext": "ba816908c1d2294e27b9b82c4f62cb718c625c43072f3cec72362de108177aa2",
        "key": "48e76d06c0cf32bd12faea778b6d8c33",
        "iv": "4e7e6bf81964c72bdee692a524d3b533",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: f4a3201c1e2950e7722663e9f2595808e5f1374950e3edb7f12af83799626d31, and the following public key:\nkey = \"963e2f168fa4da2681b86653b4372947\", iv = \"00b971475ca2d16cbf5fc33ed7321a38\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"963e2f168fa4da2681b86653b4372947\")\niv = bytes.fromhex(\"00b971475ca2d16cbf5fc33ed7321a38\")\nciphertext = bytes.fromhex(\"f4a3201c1e2950e7722663e9f2595808e5f1374950e3edb7f12af83799626d31\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{tEbeYcoL5JtPiuRa}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "tEbeYcoL5JtPiuRa",
        "ciphertext": "f4a3201c1e2950e7722663e9f2595808e5f1374950e3edb7f12af83799626d31",
        "key": "963e2f168fa4da2681b86653b4372947",
        "iv": "00b971475ca2d16cbf5fc33ed7321a38",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: cc6a53ce8deaa7c2bbba8ea11359be78e8952deecfbce39803e5e6ebd66bfc8b, and the following public key:\nkey = \"2e3a6ac51da2f125e55f281209843198\", iv = \"5de4c6e371ddb5526ce696cd724f4c87\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"2e3a6ac51da2f125e55f281209843198\")\niv = bytes.fromhex(\"5de4c6e371ddb5526ce696cd724f4c87\")\nciphertext = bytes.fromhex(\"cc6a53ce8deaa7c2bbba8ea11359be78e8952deecfbce39803e5e6ebd66bfc8b\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{3U6e7IEAXRXimcQMTQsjTZ219Zcm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "3U6e7IEAXRXimcQMTQsjTZ219Zcm",
        "ciphertext": "cc6a53ce8deaa7c2bbba8ea11359be78e8952deecfbce39803e5e6ebd66bfc8b",
        "key": "2e3a6ac51da2f125e55f281209843198",
        "iv": "5de4c6e371ddb5526ce696cd724f4c87",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given an encrypted message using BLOCKCIPHER_CBC: d808ca79cae013dee3b042f42427f1de, and the following public key:\nkey = \"f9a29e9ee7a58b73bed2c408c9674dfd\", iv = \"982c3a67daee1a260ffa5e601d3ffa75\"\nPlease decrypt the plaintext. When submitting, convert the decrypted number into an ASCII string.\n\nFor example, if the decrypted plaintext is 0x6162, then submit the string ab.\nSubmission format: PCTF{plaintext_string}",
    "rationale": "\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\n\nkey = bytes.fromhex(\"f9a29e9ee7a58b73bed2c408c9674dfd\")\niv = bytes.fromhex(\"982c3a67daee1a260ffa5e601d3ffa75\")\nciphertext = bytes.fromhex(\"d808ca79cae013dee3b042f42427f1de\")\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nplaintext_padded = cipher.decrypt(ciphertext)\nplaintext = unpad(plaintext_padded, AES.block_size)\nprint(plaintext.decode())\n",
    "final_answer": "PCTF{BK9toiwv8T8F}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "BLOCKCIPHER_CBC",
      "change_detail": "Use key and iv to decrypt the ciphertext.",
      "synthesis_code": "\nfrom Crypto.Util.Padding import pad\nimport os, base64\nfrom Crypto.Cipher import AES\n\nkey = bytes.fromhex(\"{key}\")\niv = bytes.fromhex(\"{iv}\")\nplaintext = {plaintext}.encode()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(base64.b64encode(ciphertext).decode())\n",
      "original_data": {
        "plaintext": "BK9toiwv8T8F",
        "ciphertext": "d808ca79cae013dee3b042f42427f1de",
        "key": "f9a29e9ee7a58b73bed2c408c9674dfd",
        "iv": "982c3a67daee1a260ffa5e601d3ffa75",
        "compute": 2
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x3b99e12d4fb3a7f7 and the known public key parameters:\nN=5844029647524615251 e=263989130254450669\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 5844029647524615251\ne = 263989130254450669\nc = 0x3b99e12d4fb3a7f7\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{dlt}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x3b99e12d4fb3a7f7",
        "p": 1831460291,
        "q": 3190912561,
        "N": 5844029647524615251,
        "e": 263989130254450669,
        "plaintext": "dlt",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0xae4aab226a1c3e4 and the known public key parameters:\nN=2915464297671221287 e=96908390618786247\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 2915464297671221287\ne = 96908390618786247\nc = 0xae4aab226a1c3e4\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{xsnr}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xae4aab226a1c3e4",
        "p": 1198139693,
        "q": 2433325859,
        "N": 2915464297671221287,
        "e": 96908390618786247,
        "plaintext": "xsnr",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x4e3293a46b55b504 and the known public key parameters:\nN=6565970015934591211 e=2118762695651982957\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 6565970015934591211\ne = 2118762695651982957\nc = 0x4e3293a46b55b504\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{gaj}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x4e3293a46b55b504",
        "p": 2471709521,
        "q": 2656448891,
        "N": 6565970015934591211,
        "e": 2118762695651982957,
        "plaintext": "gaj",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x146297c706b8b78d and the known public key parameters:\nN=2808959928652689913 e=2199776855680382399\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 2808959928652689913\ne = 2199776855680382399\nc = 0x146297c706b8b78d\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{izb}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x146297c706b8b78d",
        "p": 3430143263,
        "q": 818904551,
        "N": 2808959928652689913,
        "e": 2199776855680382399,
        "plaintext": "izb",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x1e378897dd4ab1 and the known public key parameters:\nN=118351491374339287 e=72327473102163391\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 118351491374339287\ne = 72327473102163391\nc = 0x1e378897dd4ab1\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{gth}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x1e378897dd4ab1",
        "p": 63124639,
        "q": 1874885833,
        "N": 118351491374339287,
        "e": 72327473102163391,
        "plaintext": "gth",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x156bf80f45747d31 and the known public key parameters:\nN=2072383754214327503 e=1696270937039565613\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 2072383754214327503\ne = 1696270937039565613\nc = 0x156bf80f45747d31\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{mtgv}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x156bf80f45747d31",
        "p": 574345831,
        "q": 3608250713,
        "N": 2072383754214327503,
        "e": 1696270937039565613,
        "plaintext": "mtgv",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x159275aacb763fd and the known public key parameters:\nN=565399631604770821 e=302037333725332703\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 565399631604770821\ne = 302037333725332703\nc = 0x159275aacb763fd\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{ipxi}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x159275aacb763fd",
        "p": 3652620473,
        "q": 154792877,
        "N": 565399631604770821,
        "e": 302037333725332703,
        "plaintext": "ipxi",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x111d9c717e44f6a9 and the known public key parameters:\nN=4887477008888993513 e=4845021153597446219\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 4887477008888993513\ne = 4845021153597446219\nc = 0x111d9c717e44f6a9\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{qfbc}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x111d9c717e44f6a9",
        "p": 1143915257,
        "q": 4272586609,
        "N": 4887477008888993513,
        "e": 4845021153597446219,
        "plaintext": "qfbc",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x2554a8c5c9bdc7cb and the known public key parameters:\nN=3956128179510166357 e=3759896687345556643\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 3956128179510166357\ne = 3759896687345556643\nc = 0x2554a8c5c9bdc7cb\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{actm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x2554a8c5c9bdc7cb",
        "p": 1771763839,
        "q": 2232875563,
        "N": 3956128179510166357,
        "e": 3759896687345556643,
        "plaintext": "actm",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Given the RSA encrypted ciphertext: 0x4991256f25b29fe5 and the known public key parameters:\nN=6628041834217945997 e=1101155955479939387\nPlease decrypt the plaintext. When submitting, convert the number to ASCII code and submit.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 6628041834217945997\ne = 1101155955479939387\nc = 0x4991256f25b29fe5\n\ndef extended_wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Calculate the continued fraction convergents\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                sqrt_delta = gmpy2.isqrt(delta)\n                p = (b + sqrt_delta) // 2\n                q = (b - sqrt_delta) // 2\n                if p * q == N:\n                    return d, p, q\n    return None, None, None\n\nd, p, q = extended_wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Extended Wiener's attack failed\")\n",
    "final_answer": "PCTF{bct}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Extended_Wieners_Attack",
      "change_detail": "When the private exponent d is small-to-moderate, an extended form of Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x4991256f25b29fe5",
        "p": 1631121113,
        "q": 4063488469,
        "N": 6628041834217945997,
        "e": 1101155955479939387,
        "plaintext": "bct",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 322031312741681098922245889803538913169\nc1 = 152868220790087315388880619162356164043\n\nn2 = 305181267483902805208558754030757617099\nc2 = 275858918360996186077320733404510923694\n\nn3 = 292077978990717417541683253385873516111\nc3 = 11990867626768164215605386694694834793\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [322031312741681098922245889803538913169, 305181267483902805208558754030757617099, 292077978990717417541683253385873516111]\nc = [152868220790087315388880619162356164043, 275858918360996186077320733404510923694, 11990867626768164215605386694694834793]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{x3y5psdc}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          322031312741681098922245889803538913169,
          305181267483902805208558754030757617099,
          292077978990717417541683253385873516111
        ],
        "c": [
          152868220790087315388880619162356164043,
          275858918360996186077320733404510923694,
          11990867626768164215605386694694834793
        ],
        "e": 3,
        "plaintext": "PCTF{x3y5psdc}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 190810277404313764859888053972816399243\nc1 = 8563107500393746248373908705151789172\n\nn2 = 234572096558120953894166539858480889759\nc2 = 159155599381927332052904062935234730819\n\nn3 = 190341996252441488057239961433745886947\nc3 = 106501735020687267942130117892230374956\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [190810277404313764859888053972816399243, 234572096558120953894166539858480889759, 190341996252441488057239961433745886947]\nc = [8563107500393746248373908705151789172, 159155599381927332052904062935234730819, 106501735020687267942130117892230374956]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{osscqjmj}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          190810277404313764859888053972816399243,
          234572096558120953894166539858480889759,
          190341996252441488057239961433745886947
        ],
        "c": [
          8563107500393746248373908705151789172,
          159155599381927332052904062935234730819,
          106501735020687267942130117892230374956
        ],
        "e": 3,
        "plaintext": "PCTF{osscqjmj}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 258505201029884882867709458481165036941\nc1 = 109180116965223833933502353960707116872\n\nn2 = 214041773674106149356108466698380076031\nc2 = 82284741266509314846010622495535112725\n\nn3 = 309633029453246325241196665608692307941\nc3 = 41516990742992021574840295900761809700\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [258505201029884882867709458481165036941, 214041773674106149356108466698380076031, 309633029453246325241196665608692307941]\nc = [109180116965223833933502353960707116872, 82284741266509314846010622495535112725, 41516990742992021574840295900761809700]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{n9t93fls}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          258505201029884882867709458481165036941,
          214041773674106149356108466698380076031,
          309633029453246325241196665608692307941
        ],
        "c": [
          109180116965223833933502353960707116872,
          82284741266509314846010622495535112725,
          41516990742992021574840295900761809700
        ],
        "e": 3,
        "plaintext": "PCTF{n9t93fls}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 291710736732287329831476735525720609527\nc1 = 131614724460879954116005003320295513702\n\nn2 = 316702408299910057610865576596804884421\nc2 = 4670146811808513273983541553892910726\n\nn3 = 298619084055969118642746617519534811779\nc3 = 281900867099918210443281220299390498159\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [291710736732287329831476735525720609527, 316702408299910057610865576596804884421, 298619084055969118642746617519534811779]\nc = [131614724460879954116005003320295513702, 4670146811808513273983541553892910726, 281900867099918210443281220299390498159]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{b01o91v1}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          291710736732287329831476735525720609527,
          316702408299910057610865576596804884421,
          298619084055969118642746617519534811779
        ],
        "c": [
          131614724460879954116005003320295513702,
          4670146811808513273983541553892910726,
          281900867099918210443281220299390498159
        ],
        "e": 3,
        "plaintext": "PCTF{b01o91v1}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 337852168728667403137860305754563784749\nc1 = 198186925452935870859403959917779260796\n\nn2 = 289079145826522718334553075727689247027\nc2 = 65322167541843759827678614782337264829\n\nn3 = 270790007922291510242801264016787856401\nc3 = 54387015962665741925874463722810046706\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [337852168728667403137860305754563784749, 289079145826522718334553075727689247027, 270790007922291510242801264016787856401]\nc = [198186925452935870859403959917779260796, 65322167541843759827678614782337264829, 54387015962665741925874463722810046706]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{3v7g57pr}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          337852168728667403137860305754563784749,
          289079145826522718334553075727689247027,
          270790007922291510242801264016787856401
        ],
        "c": [
          198186925452935870859403959917779260796,
          65322167541843759827678614782337264829,
          54387015962665741925874463722810046706
        ],
        "e": 3,
        "plaintext": "PCTF{3v7g57pr}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 202277048349047342951672875407775368437\nc1 = 107685650218682423735992666413902463272\n\nn2 = 200025964575074558188865896140821914241\nc2 = 81932131252518738243686478433409764030\n\nn3 = 307820316395131118899629713779827651473\nc3 = 12916742007987143284585732036663155495\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [202277048349047342951672875407775368437, 200025964575074558188865896140821914241, 307820316395131118899629713779827651473]\nc = [107685650218682423735992666413902463272, 81932131252518738243686478433409764030, 12916742007987143284585732036663155495]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{zvansjv2}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          202277048349047342951672875407775368437,
          200025964575074558188865896140821914241,
          307820316395131118899629713779827651473
        ],
        "c": [
          107685650218682423735992666413902463272,
          81932131252518738243686478433409764030,
          12916742007987143284585732036663155495
        ],
        "e": 3,
        "plaintext": "PCTF{zvansjv2}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 222765137972683128945772943673506813081\nc1 = 64104376283671337257379807326369988585\n\nn2 = 262203871719603644194631280597994727803\nc2 = 203364181406944429007017787336204230447\n\nn3 = 249776737274203675867121637872255332247\nc3 = 146291051282526313501058092384431142729\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [222765137972683128945772943673506813081, 262203871719603644194631280597994727803, 249776737274203675867121637872255332247]\nc = [64104376283671337257379807326369988585, 203364181406944429007017787336204230447, 146291051282526313501058092384431142729]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{l2zsxisn}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          222765137972683128945772943673506813081,
          262203871719603644194631280597994727803,
          249776737274203675867121637872255332247
        ],
        "c": [
          64104376283671337257379807326369988585,
          203364181406944429007017787336204230447,
          146291051282526313501058092384431142729
        ],
        "e": 3,
        "plaintext": "PCTF{l2zsxisn}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 321027495315984212133420412326313597567\nc1 = 163201342408276256292545024264010074499\n\nn2 = 327791304495158180369069846257542785527\nc2 = 117616604654296605621994693156404932222\n\nn3 = 333660551036653046593624648843440013111\nc3 = 112648580322617977486566187160002186086\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [321027495315984212133420412326313597567, 327791304495158180369069846257542785527, 333660551036653046593624648843440013111]\nc = [163201342408276256292545024264010074499, 117616604654296605621994693156404932222, 112648580322617977486566187160002186086]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{avhf3fe7}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          321027495315984212133420412326313597567,
          327791304495158180369069846257542785527,
          333660551036653046593624648843440013111
        ],
        "c": [
          163201342408276256292545024264010074499,
          117616604654296605621994693156404932222,
          112648580322617977486566187160002186086
        ],
        "e": 3,
        "plaintext": "PCTF{avhf3fe7}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 192679866091804734033280845579727525699\nc1 = 1050012219066794612234077163206348223\n\nn2 = 185194910325643246901340690302541829373\nc2 = 104220870727645566570418091368158491207\n\nn3 = 286878285808265593723927777438441796423\nc3 = 44034493984009360344701912732571175759\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [192679866091804734033280845579727525699, 185194910325643246901340690302541829373, 286878285808265593723927777438441796423]\nc = [1050012219066794612234077163206348223, 104220870727645566570418091368158491207, 44034493984009360344701912732571175759]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{x3z0nspc}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          192679866091804734033280845579727525699,
          185194910325643246901340690302541829373,
          286878285808265593723927777438441796423
        ],
        "c": [
          1050012219066794612234077163206348223,
          104220870727645566570418091368158491207,
          44034493984009360344701912732571175759
        ],
        "e": 3,
        "plaintext": "PCTF{x3z0nspc}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Three spies shared the same encrypted message using RSA with public exponent e = 3.\nHowever, they used different public moduli, and no padding!\n\nn1 = 175859834661678143345464015371863246257\nc1 = 169748899533037547947751720138364716660\n\nn2 = 245715404766395488479164647681781510437\nc2 = 64562327873563024059846950515740299564\n\nn3 = 216928999493887889091068915221012992109\nc3 = 36366030490885908038415865854207085793\n\nRecover the original plaintext. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = [175859834661678143345464015371863246257, 245715404766395488479164647681781510437, 216928999493887889091068915221012992109]\nc = [169748899533037547947751720138364716660, 64562327873563024059846950515740299564, 36366030490885908038415865854207085793]\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
    "final_answer": "PCTF{e6qgaypu}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Broadcast",
      "change_detail": "This challenge demonstrates a textbook RSA Broadcast Attack with e=3 and identical plaintexts sent to different moduli.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes\nfrom sympy.ntheory.modular import crt\nfrom gmpy2 import iroot\n\nn = {n_list}\nc = {c_list}\ne = 3\n\nM, _ = crt(n, c)\nm_root, _ = iroot(M, e)\nprint(long_to_bytes(m_root).decode())\n",
      "compute": "3",
      "original_data": {
        "n": [
          175859834661678143345464015371863246257,
          245715404766395488479164647681781510437,
          216928999493887889091068915221012992109
        ],
        "c": [
          169748899533037547947751720138364716660,
          64562327873563024059846950515740299564,
          36366030490885908038415865854207085793
        ],
        "e": 3,
        "plaintext": "PCTF{e6qgaypu}",
        "compute": "3"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x21a79ac22e217346 and the public key parameters are known: \nN=8904210831345307021 e=6906850536521784979\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 8904210831345307021\ne = 6906850536521784979\nc = 0x21a79ac22e217346\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{abcd}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x21a79ac22e217346",
        "p": 2206081883,
        "q": 4036210487,
        "N": 8904210831345307021,
        "e": 6906850536521784979,
        "plaintext": "abcd",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x2c4dd0ae2f682d3 and the public key parameters are known: \nN=297238978972816379 e=224758501253124857\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 297238978972816379\ne = 224758501253124857\nc = 0x2c4dd0ae2f682d3\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{xyz}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x2c4dd0ae2f682d3",
        "p": 110220709,
        "q": 2696761631,
        "N": 297238978972816379,
        "e": 224758501253124857,
        "plaintext": "xyz",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0xa27ac3dff2a40f0 and the public key parameters are known: \nN=1386203306323413839 e=435576155469324173\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 1386203306323413839\ne = 435576155469324173\nc = 0xa27ac3dff2a40f0\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{1234}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xa27ac3dff2a40f0",
        "p": 664773203,
        "q": 2085227413,
        "N": 1386203306323413839,
        "e": 435576155469324173,
        "plaintext": "1234",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x338962feef34b0c and the public key parameters are known: \nN=558166795562241659 e=488780328543221159\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 558166795562241659\ne = 488780328543221159\nc = 0x338962feef34b0c\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{qwer}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x338962feef34b0c",
        "p": 3031367881,
        "q": 184130339,
        "N": 558166795562241659,
        "e": 488780328543221159,
        "plaintext": "qwer",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0xbb9a5119cb362e8 and the public key parameters are known: \nN=873285941067450667 e=61108698652449653\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 873285941067450667\ne = 61108698652449653\nc = 0xbb9a5119cb362e8\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{rty}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0xbb9a5119cb362e8",
        "p": 285104653,
        "q": 3063036439,
        "N": 873285941067450667,
        "e": 61108698652449653,
        "plaintext": "rty",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x4005a06c6a6d0ae5 and the public key parameters are known: \nN=7564107145311768781 e=472103231368953333\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 7564107145311768781\ne = 472103231368953333\nc = 0x4005a06c6a6d0ae5\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{asdz}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x4005a06c6a6d0ae5",
        "p": 2331490793,
        "q": 3244322117,
        "N": 7564107145311768781,
        "e": 472103231368953333,
        "plaintext": "asdz",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x4ad31e7d1d488da and the public key parameters are known: \nN=1672734280188274169 e=633465874940755543\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 1672734280188274169\ne = 633465874940755543\nc = 0x4ad31e7d1d488da\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{zxcv}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x4ad31e7d1d488da",
        "p": 536832293,
        "q": 3115934533,
        "N": 1672734280188274169,
        "e": 633465874940755543,
        "plaintext": "zxcv",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x48bf113d0575a80 and the public key parameters are known: \nN=7603459746528470831 e=2022438896773339375\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 7603459746528470831\ne = 2022438896773339375\nc = 0x48bf113d0575a80\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{jklm}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x48bf113d0575a80",
        "p": 4239652687,
        "q": 1793415713,
        "N": 7603459746528470831,
        "e": 2022438896773339375,
        "plaintext": "jklm",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x3e745d3c3cfc7e and the public key parameters are known: \nN=128546131875921181 e=34990458513894337\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 128546131875921181\ne = 34990458513894337\nc = 0x3e745d3c3cfc7e\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{mnop}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x3e745d3c3cfc7e",
        "p": 109764719,
        "q": 1171106099,
        "N": 128546131875921181,
        "e": 34990458513894337,
        "plaintext": "mnop",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The ciphertext of an RSA encryption is given as: 0x72440ce025a018c and the public key parameters are known: \nN=768521589556422607 e=496845081789396363\nPlease decrypt the message and submit the result in ASCII code format.\nSubmission format: PCTF{plaintext string}",
    "rationale": "\nimport gmpy2\nfrom sympy import continued_fraction_convergents, continued_fraction, Rational\n\nN = 768521589556422607\ne = 496845081789396363\nc = 0x72440ce025a018c\n\ndef wiener_attack(e, N):\n    cf = continued_fraction(Rational(e, N))  # Calculate the continued fraction expansion of e/N\n    for conv in continued_fraction_convergents(cf):  # Compute the convergent sequence\n        k, d = conv.p, conv.q  # Extract k and d\n        if k == 0:\n            continue\n        if (e * d - 1) % k == 0:\n            phi_n = (e * d - 1) // k\n            b = N - phi_n + 1\n            delta = b * b - 4 * N\n            if delta >= 0 and gmpy2.is_square(delta):\n                return d\n    return None\nd = wiener_attack(e, N)\nif d:\n    m = gmpy2.powmod(c, d, N)\n    hex_str = format(int(m), 'x')\n    if len(hex_str) % 2:\n        hex_str = '0' + hex_str\n    plaintext = bytes.fromhex(hex_str).decode('ascii')\n    print(f'PCTF{{{plaintext}}}')\nelse:\n    print(\"Wiener's attack failed\")\n",
    "final_answer": "PCTF{pqrs}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Wieners_Attack",
      "change_detail": "When the private exponent d is too small, Wiener's attack can efficiently recover d using continued fractions.",
      "synthesis_code": "import gmpy2\nN = {N}  # RSA modulus\np, q = {p}, {q}  # Poorly chosen prime factors\ne = {e}  # Public exponent\nplaintext = \"{plaintext}\"\nhex_str = plaintext.encode('ascii').hex()\nm = int(hex_str, 16)\nc = gmpy2.powmod(m, e, N)\nprint(hex(c))",
      "original_data": {
        "ciphertext": "0x72440ce025a018c",
        "p": 373816733,
        "q": 2055877979,
        "N": 768521589556422607,
        "e": 496845081789396363,
        "plaintext": "pqrs",
        "compute": "2"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 83249227033664945668565579002516042735832192610502339059639024356524339261181740909525236105939886377590609909513269438077725879198992410884415165017737555706054388286396884844754037026808317772799585933530683636745574725461765291838816853044258689962708937944317669576289241330912429641362624853900652213611\ne = 65537\nc = 82301453803504239149401039524135538368906874141033146082233252227440804298749999926184480957207467258949394945203215058425458705882685994607068489073398007402307073543226521727248486491281377637285396517809174757364629329851106231325370098795941290418622999470801250174002781457062932161489864977127636026888\nknown_high_bits_of_p = 0xbb0124f68f4ab74dd3010fb97062845f\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 83249227033664945668565579002516042735832192610502339059639024356524339261181740909525236105939886377590609909513269438077725879198992410884415165017737555706054388286396884844754037026808317772799585933530683636745574725461765291838816853044258689962708937944317669576289241330912429641362624853900652213611\ne = 65537\nc = 82301453803504239149401039524135538368906874141033146082233252227440804298749999926184480957207467258949394945203215058425458705882685994607068489073398007402307073543226521727248486491281377637285396517809174757364629329851106231325370098795941290418622999470801250174002781457062932161489864977127636026888\np_high = 248571577209858195573576698195001640031\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{9ask07}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 83249227033664945668565579002516042735832192610502339059639024356524339261181740909525236105939886377590609909513269438077725879198992410884415165017737555706054388286396884844754037026808317772799585933530683636745574725461765291838816853044258689962708937944317669576289241330912429641362624853900652213611,
        "e": 65537,
        "ciphertext": 82301453803504239149401039524135538368906874141033146082233252227440804298749999926184480957207467258949394945203215058425458705882685994607068489073398007402307073543226521727248486491281377637285396517809174757364629329851106231325370098795941290418622999470801250174002781457062932161489864977127636026888,
        "p_high_hex": "0xbb0124f68f4ab74dd3010fb97062845f",
        "known_bits": 128,
        "plaintext": "PCTF{9ask07}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 82926110537696655861346028919121723182010612701338770561101740294998143274423057746161362051925443587427712837957075288277409635818950674165598216178265232682242863395135984752410626988019508762159790566300867889142858166379194803867878853731544352125522476402724613261766149101703232890613697405711338489541\ne = 65537\nc = 33166888118900606824810589978162590460759436701705177874409122840428743817586981896705074603689106200884279763001568160043806778318495610150645297844610859644879433781271393330442211345096343585284426517705056355945636069691720695323041329407466474055757550986499424223428498470358600455551133461373064139978\nknown_high_bits_of_p = 0x9c46a60cad4a2b7147db8c7f9caebcb1\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 82926110537696655861346028919121723182010612701338770561101740294998143274423057746161362051925443587427712837957075288277409635818950674165598216178265232682242863395135984752410626988019508762159790566300867889142858166379194803867878853731544352125522476402724613261766149101703232890613697405711338489541\ne = 65537\nc = 33166888118900606824810589978162590460759436701705177874409122840428743817586981896705074603689106200884279763001568160043806778318495610150645297844610859644879433781271393330442211345096343585284426517705056355945636069691720695323041329407466474055757550986499424223428498470358600455551133461373064139978\np_high = 207726396006907042816616372361568894129\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{chvmo2}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 82926110537696655861346028919121723182010612701338770561101740294998143274423057746161362051925443587427712837957075288277409635818950674165598216178265232682242863395135984752410626988019508762159790566300867889142858166379194803867878853731544352125522476402724613261766149101703232890613697405711338489541,
        "e": 65537,
        "ciphertext": 33166888118900606824810589978162590460759436701705177874409122840428743817586981896705074603689106200884279763001568160043806778318495610150645297844610859644879433781271393330442211345096343585284426517705056355945636069691720695323041329407466474055757550986499424223428498470358600455551133461373064139978,
        "p_high_hex": "0x9c46a60cad4a2b7147db8c7f9caebcb1",
        "known_bits": 128,
        "plaintext": "PCTF{chvmo2}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 76551838121600491387991119716791306422282290642909896649792262641291961897563646819454969504743425759708752763198519303829690562553091405735229993099418829118478634643771665907722445932447843886743992049345963213740519057293892103439997985412663849721704014079691559551573585169396554579093860896723929092221\ne = 65537\nc = 49616339230130874596295362634621255189940934021888989054922190774828752206263582853735679798174147247903037765990031352890766672121809484165635323331886583118346754890335566564724441578804107886700357351862505818035125242351159008300084949877435678376397107355680937559605295801697931890802024314429146318779\nknown_high_bits_of_p = 0xb1dc2b22cfbb5ecdeb0c641b753da1a7\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 76551838121600491387991119716791306422282290642909896649792262641291961897563646819454969504743425759708752763198519303829690562553091405735229993099418829118478634643771665907722445932447843886743992049345963213740519057293892103439997985412663849721704014079691559551573585169396554579093860896723929092221\ne = 65537\nc = 49616339230130874596295362634621255189940934021888989054922190774828752206263582853735679798174147247903037765990031352890766672121809484165635323331886583118346754890335566564724441578804107886700357351862505818035125242351159008300084949877435678376397107355680937559605295801697931890802024314429146318779\np_high = 236416535464468167951321578880884384167\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{9fuppg}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 76551838121600491387991119716791306422282290642909896649792262641291961897563646819454969504743425759708752763198519303829690562553091405735229993099418829118478634643771665907722445932447843886743992049345963213740519057293892103439997985412663849721704014079691559551573585169396554579093860896723929092221,
        "e": 65537,
        "ciphertext": 49616339230130874596295362634621255189940934021888989054922190774828752206263582853735679798174147247903037765990031352890766672121809484165635323331886583118346754890335566564724441578804107886700357351862505818035125242351159008300084949877435678376397107355680937559605295801697931890802024314429146318779,
        "p_high_hex": "0xb1dc2b22cfbb5ecdeb0c641b753da1a7",
        "known_bits": 128,
        "plaintext": "PCTF{9fuppg}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 97079201404294395663814984540870476966762530306490828354664237200661910398320007211575941245890188345406298743784683988163100892314689014282384231535021739564194826922237426991701414547655694947064214316803406757383601652819729871769960197351176909835902366402646234225684826935187183315063358050169985615919\ne = 65537\nc = 76423327450948246483301258978031188353691735096512100382259178512327956481007839639761508596349266098511975898025138002856672841605173383483843667730643178634064509922938988808959075144892777404410653254372394551475222206987992706019780232981097095297891298088615514413195137844509629742910687843362876815974\nknown_high_bits_of_p = 0xc7994deac66a391a58a7b8bf0b6012e3\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 97079201404294395663814984540870476966762530306490828354664237200661910398320007211575941245890188345406298743784683988163100892314689014282384231535021739564194826922237426991701414547655694947064214316803406757383601652819729871769960197351176909835902366402646234225684826935187183315063358050169985615919\ne = 65537\nc = 76423327450948246483301258978031188353691735096512100382259178512327956481007839639761508596349266098511975898025138002856672841605173383483843667730643178634064509922938988808959075144892777404410653254372394551475222206987992706019780232981097095297891298088615514413195137844509629742910687843362876815974\np_high = 265312372926890044593899033275161121507\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{daqpwk}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 97079201404294395663814984540870476966762530306490828354664237200661910398320007211575941245890188345406298743784683988163100892314689014282384231535021739564194826922237426991701414547655694947064214316803406757383601652819729871769960197351176909835902366402646234225684826935187183315063358050169985615919,
        "e": 65537,
        "ciphertext": 76423327450948246483301258978031188353691735096512100382259178512327956481007839639761508596349266098511975898025138002856672841605173383483843667730643178634064509922938988808959075144892777404410653254372394551475222206987992706019780232981097095297891298088615514413195137844509629742910687843362876815974,
        "p_high_hex": "0xc7994deac66a391a58a7b8bf0b6012e3",
        "known_bits": 128,
        "plaintext": "PCTF{daqpwk}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 139458934632838546988240967740854467865535508326794323999574468672802173522460894157079451355150981843591276177571656999225961281561590811199217321998499390582376620620516131623898313457228015587277159547375823531080739525905794483313431632268850541225843198820097310000228835491175379664850169653839432574761\ne = 65537\nc = 67120657289876473082841203243596577859713784644141796660801884502206308806783049528304967288234374573475538891422182875102361351004506718923614764367254160777254705372428857609007523698677150144198147401000091903984874612381460212903645394324209323937895975096008124166793986657770102395183866810734141148357\nknown_high_bits_of_p = 0xe043a829efb8a9406e1ec74ad37d5599\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 139458934632838546988240967740854467865535508326794323999574468672802173522460894157079451355150981843591276177571656999225961281561590811199217321998499390582376620620516131623898313457228015587277159547375823531080739525905794483313431632268850541225843198820097310000228835491175379664850169653839432574761\ne = 65537\nc = 67120657289876473082841203243596577859713784644141796660801884502206308806783049528304967288234374573475538891422182875102361351004506718923614764367254160777254705372428857609007523698677150144198147401000091903984874612381460212903645394324209323937895975096008124166793986657770102395183866810734141148357\np_high = 298098365712701224513606176828857079193\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{yfnx92}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 139458934632838546988240967740854467865535508326794323999574468672802173522460894157079451355150981843591276177571656999225961281561590811199217321998499390582376620620516131623898313457228015587277159547375823531080739525905794483313431632268850541225843198820097310000228835491175379664850169653839432574761,
        "e": 65537,
        "ciphertext": 67120657289876473082841203243596577859713784644141796660801884502206308806783049528304967288234374573475538891422182875102361351004506718923614764367254160777254705372428857609007523698677150144198147401000091903984874612381460212903645394324209323937895975096008124166793986657770102395183866810734141148357,
        "p_high_hex": "0xe043a829efb8a9406e1ec74ad37d5599",
        "known_bits": 128,
        "plaintext": "PCTF{yfnx92}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 77716696894812464090908931298003160551160577512531073524960630113450854747282811603656941746507576632033914645893727532855840663697830254433405180618525314436014625128861440084697629378007737946890648744069814922423549973143046193673386221515329207631988357155661072691749059472387390432873075222057269466649\ne = 65537\nc = 32270210353079115250996132272387717310286103160220495157539472419545612415705862437294330833652034524461853302692892328856372052021178502117526068754787647595756185479848554598293327643068348826316496515404016956598115658868595294136314080886198953820514840514470508183735866938540467247568726588105046620473\nknown_high_bits_of_p = 0x8f8246cbad9267ca0ea91ba97e2b9725\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 77716696894812464090908931298003160551160577512531073524960630113450854747282811603656941746507576632033914645893727532855840663697830254433405180618525314436014625128861440084697629378007737946890648744069814922423549973143046193673386221515329207631988357155661072691749059472387390432873075222057269466649\ne = 65537\nc = 32270210353079115250996132272387717310286103160220495157539472419545612415705862437294330833652034524461853302692892328856372052021178502117526068754787647595756185479848554598293327643068348826316496515404016956598115658868595294136314080886198953820514840514470508183735866938540467247568726588105046620473\np_high = 190756037894559643429346459153955788581\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{d7a1bw}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 77716696894812464090908931298003160551160577512531073524960630113450854747282811603656941746507576632033914645893727532855840663697830254433405180618525314436014625128861440084697629378007737946890648744069814922423549973143046193673386221515329207631988357155661072691749059472387390432873075222057269466649,
        "e": 65537,
        "ciphertext": 32270210353079115250996132272387717310286103160220495157539472419545612415705862437294330833652034524461853302692892328856372052021178502117526068754787647595756185479848554598293327643068348826316496515404016956598115658868595294136314080886198953820514840514470508183735866938540467247568726588105046620473,
        "p_high_hex": "0x8f8246cbad9267ca0ea91ba97e2b9725",
        "known_bits": 128,
        "plaintext": "PCTF{d7a1bw}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 144258773424571497302063577371945577552272143612651636769467591427294891353164551064322922673449578411370392982410700857915835382484904778056214652182103314555166220704363906540191723141056259952391333330375729438717362710593346079412149712954935427995168599135361039781519704043157828308894003421944750844949\ne = 65537\nc = 80690351464522422745654909459714725129301216686207655894761816635777514460787206818318624405679796065518933571606333190916560560172237615766252570428883974719465466195156576831693965494877554595793407482674044148688822729995252726957419573144560601293819885796334939434289959658710675235028747370779082493424\nknown_high_bits_of_p = 0xe04f3dac9b3b3c965370c6730b165251\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 144258773424571497302063577371945577552272143612651636769467591427294891353164551064322922673449578411370392982410700857915835382484904778056214652182103314555166220704363906540191723141056259952391333330375729438717362710593346079412149712954935427995168599135361039781519704043157828308894003421944750844949\ne = 65537\nc = 80690351464522422745654909459714725129301216686207655894761816635777514460787206818318624405679796065518933571606333190916560560172237615766252570428883974719465466195156576831693965494877554595793407482674044148688822729995252726957419573144560601293819885796334939434289959658710675235028747370779082493424\np_high = 298158513409916971379147473293436932689\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{x4yc6l}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 144258773424571497302063577371945577552272143612651636769467591427294891353164551064322922673449578411370392982410700857915835382484904778056214652182103314555166220704363906540191723141056259952391333330375729438717362710593346079412149712954935427995168599135361039781519704043157828308894003421944750844949,
        "e": 65537,
        "ciphertext": 80690351464522422745654909459714725129301216686207655894761816635777514460787206818318624405679796065518933571606333190916560560172237615766252570428883974719465466195156576831693965494877554595793407482674044148688822729995252726957419573144560601293819885796334939434289959658710675235028747370779082493424,
        "p_high_hex": "0xe04f3dac9b3b3c965370c6730b165251",
        "known_bits": 128,
        "plaintext": "PCTF{x4yc6l}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 89062644502829858392706931750634560627701313535402185409614319608364587273479239735946635494274244357435174876362535191946021381571018573358598492971459835952985116469583105287172605524003713107270259768118671134637147369259457787754830643541934633787879406206720022883085673969736694282061373261462984098913\ne = 65537\nc = 44987644214738487785343759963310188480260786844497639958053881134819192623577127340403123466329150056771058914068186027539747478623069928978696084521520456479331845124216630047093152378282587193535641533541458427937795708434954168592251584636419330602327676519122622366972521659441409963967670388233797328589\nknown_high_bits_of_p = 0xc2dc9ea29cf88b69b0401be464ad4145\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 89062644502829858392706931750634560627701313535402185409614319608364587273479239735946635494274244357435174876362535191946021381571018573358598492971459835952985116469583105287172605524003713107270259768118671134637147369259457787754830643541934633787879406206720022883085673969736694282061373261462984098913\ne = 65537\nc = 44987644214738487785343759963310188480260786844497639958053881134819192623577127340403123466329150056771058914068186027539747478623069928978696084521520456479331845124216630047093152378282587193535641533541458427937795708434954168592251584636419330602327676519122622366972521659441409963967670388233797328589\np_high = 259015753995411179190308639700159381829\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{n3foi6}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 89062644502829858392706931750634560627701313535402185409614319608364587273479239735946635494274244357435174876362535191946021381571018573358598492971459835952985116469583105287172605524003713107270259768118671134637147369259457787754830643541934633787879406206720022883085673969736694282061373261462984098913,
        "e": 65537,
        "ciphertext": 44987644214738487785343759963310188480260786844497639958053881134819192623577127340403123466329150056771058914068186027539747478623069928978696084521520456479331845124216630047093152378282587193535641533541458427937795708434954168592251584636419330602327676519122622366972521659441409963967670388233797328589,
        "p_high_hex": "0xc2dc9ea29cf88b69b0401be464ad4145",
        "known_bits": 128,
        "plaintext": "PCTF{n3foi6}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 89479138270622202908272232008400284364852905422878037679534328348950033351311660954829545613220878526686461366903668174945153328341228151516967406637951754146208238215382085739714276517462119200582783794698248362050777049206790539221452337814201271791422823579885518577392607647220247029973703227726208745433\ne = 65537\nc = 38808202162690995763745099613560647748013345205914043568864506515837635193611265665546229417171934092659153793674592323683548839249015567319120916359838813965308427149646328424981564318374327541414072937809408642257827792257437012099035990205796363955815360416084333198573009809125531797359719869982390252039\nknown_high_bits_of_p = 0xb6a7ac5d31e2f5775ca2b1e9efbb91c7\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 89479138270622202908272232008400284364852905422878037679534328348950033351311660954829545613220878526686461366903668174945153328341228151516967406637951754146208238215382085739714276517462119200582783794698248362050777049206790539221452337814201271791422823579885518577392607647220247029973703227726208745433\ne = 65537\nc = 38808202162690995763745099613560647748013345205914043568864506515837635193611265665546229417171934092659153793674592323683548839249015567319120916359838813965308427149646328424981564318374327541414072937809408642257827792257437012099035990205796363955815360416084333198573009809125531797359719869982390252039\np_high = 242790104766340088894458548596346950087\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{o3xwyc}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 89479138270622202908272232008400284364852905422878037679534328348950033351311660954829545613220878526686461366903668174945153328341228151516967406637951754146208238215382085739714276517462119200582783794698248362050777049206790539221452337814201271791422823579885518577392607647220247029973703227726208745433,
        "e": 65537,
        "ciphertext": 38808202162690995763745099613560647748013345205914043568864506515837635193611265665546229417171934092659153793674592323683548839249015567319120916359838813965308427149646328424981564318374327541414072937809408642257827792257437012099035990205796363955815360416084333198573009809125531797359719869982390252039,
        "p_high_hex": "0xb6a7ac5d31e2f5775ca2b1e9efbb91c7",
        "known_bits": 128,
        "plaintext": "PCTF{o3xwyc}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted a message with RSA, but leaked high bits of one prime.\n\nn = 82519031182969749884060732585089731685922085409472710926264903477269487083172620642214041331510320739864963690004430991441113147411961820228001130229174061213656329212311382074815008363696508983266226083161153077677558985644516560335285443957959707706802805913729708281006054948779327013238929951092596777317\ne = 65537\nc = 42684746789239611338430504235409812823545272188462404499763965237403904151955829333336495762685132972742476859605029647170427642901315283730202971395167581851028555865432305007158018422343267903127723024296775288318729702414472923364467872795697381583709492341401337469064026860312261076663106395182777513862\nknown_high_bits_of_p = 0xc11166055b94c1e1dd2a792d85579bbf\nknown_bit_length = 128\n\nRecover the original message. Submit in format: PCTF{...}",
    "rationale": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = 82519031182969749884060732585089731685922085409472710926264903477269487083172620642214041331510320739864963690004430991441113147411961820228001130229174061213656329212311382074815008363696508983266226083161153077677558985644516560335285443957959707706802805913729708281006054948779327013238929951092596777317\ne = 65537\nc = 42684746789239611338430504235409812823545272188462404499763965237403904151955829333336495762685132972742476859605029647170427642901315283730202971395167581851028555865432305007158018422343267903127723024296775288318729702414472923364467872795697381583709492341401337469064026860312261076663106395182777513862\np_high = 256631341463347213080055371924862639039\nknown_bits = 128\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
    "final_answer": "PCTF{kg5vgf}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "RSA_Coppersmith_HighBits",
      "change_detail": "This challenge demonstrates RSA factorization when the high bits of one prime factor are known.",
      "synthesis_code": "from Crypto.Util.number import long_to_bytes, inverse\n\nn = {n}\ne = {e}\nc = {c}\np_high = {p_high}\nknown_bits = {known_bits}\n\nshift = 512 - known_bits\nfor x in range(2**20):\n    p = (p_high << shift) + x\n    if n % p == 0:\n        q = n // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(e, phi)\n        m = pow(c, d, n)\n        print(long_to_bytes(m).decode())\n        break\n",
      "compute": "5",
      "original_data": {
        "n": 82519031182969749884060732585089731685922085409472710926264903477269487083172620642214041331510320739864963690004430991441113147411961820228001130229174061213656329212311382074815008363696508983266226083161153077677558985644516560335285443957959707706802805913729708281006054948779327013238929951092596777317,
        "e": 65537,
        "ciphertext": 42684746789239611338430504235409812823545272188462404499763965237403904151955829333336495762685132972742476859605029647170427642901315283730202971395167581851028555865432305007158018422343267903127723024296775288318729702414472923364467872795697381583709492341401337469064026860312261076663106395182777513862,
        "p_high_hex": "0xc11166055b94c1e1dd2a792d85579bbf",
        "known_bits": 128,
        "plaintext": "PCTF{kg5vgf}",
        "compute": "5"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0xad, 0x96, 0x41)\n(0xb, 0x37, 0xb8)\n(0x1, 0x83, 0xb2)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(173, 150, 65), (11, 55, 184), (1, 131, 178)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{634E}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "634E",
        "plaintext": "PCTF{634E}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x8c, 0x8, 0x53)\n(0x26, 0xe5, 0xb5)\n(0xb4, 0x60, 0xfc)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(140, 8, 83), (38, 229, 181), (180, 96, 252)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{22CD}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "22CD",
        "plaintext": "PCTF{22CD}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x1e, 0x6f, 0x4)\n(0x96, 0xce, 0x7c)\n(0xe0, 0x46, 0xab)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(30, 111, 4), (150, 206, 124), (224, 70, 171)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{03EF}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "03EF",
        "plaintext": "PCTF{03EF}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0xf0, 0x40, 0x70)\n(0x42, 0x69, 0x1b)\n(0x9b, 0x58, 0x6d)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(240, 64, 112), (66, 105, 27), (155, 88, 109)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{6D7B}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "6D7B",
        "plaintext": "PCTF{6D7B}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x74, 0xc0, 0x60)\n(0xe, 0xb2, 0x31)\n(0xed, 0x8c, 0x43)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(116, 192, 96), (14, 178, 49), (237, 140, 67)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{1C04}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "1C04",
        "plaintext": "PCTF{1C04}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0xb5, 0xbf, 0x20)\n(0xf6, 0x5f, 0x4e)\n(0x7a, 0x6b, 0xaf)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(181, 191, 32), (246, 95, 78), (122, 107, 175)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{BE32}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "BE32",
        "plaintext": "PCTF{BE32}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x2f, 0x29, 0x5c)\n(0x0, 0x72, 0xd8)\n(0x94, 0xf6, 0xf3)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(47, 41, 92), (0, 114, 216), (148, 246, 243)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{9A4D}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "9A4D",
        "plaintext": "PCTF{9A4D}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x54, 0x92, 0x5c)\n(0xcd, 0xe2, 0xb1)\n(0x95, 0x7a, 0x0)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(84, 146, 92), (205, 226, 177), (149, 122, 0)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{056D}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "056D",
        "plaintext": "PCTF{056D}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0xde, 0xa1, 0x26)\n(0x6c, 0x96, 0x7a)\n(0xb3, 0xf0, 0xa4)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(222, 161, 38), (108, 150, 122), (179, 240, 164)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{B670}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "B670",
        "plaintext": "PCTF{B670}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Alice encrypted multiple 8-bit plaintext pairs using a simplified IDEA-style cipher:\n\n```python\ndef mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n```\n\nYou are given the following (p1, p2, cipher) triples:\n\n(0x13, 0x35, 0x66)\n(0x42, 0x33, 0x37)\n(0xde, 0x49, 0xf3)\n\nRecover the two 8-bit keys. Format: `PCTF{{XXYY}}`",
    "rationale": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = [(19, 53, 102), (66, 51, 55), (222, 73, 243)]\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
    "final_answer": "PCTF{BC4C}",
    "metadata": {
      "class1": "Modern_Cryptography",
      "class2": "IDEA_FastKeyRecovery",
      "change_detail": "Recover two 8-bit keys from a simplified IDEA-style cipher using mod 257 multiplication.",
      "synthesis_code": "def mul(x, y):\n    if x == 0: x = 256\n    if y == 0: y = 256\n    return (x * y) % 257 & 0xFF\n\ndef idea_round(p1, p2, k1, k2):\n    c1 = mul(p1, k1)\n    c2 = (p2 + k2) & 0xFF\n    return c1 ^ c2\n\npairs = __PAIRS__\n\n# 爆破 key\nfor k1 in range(256):\n    for k2 in range(256):\n        match = True\n        for p1, p2, c in pairs:\n            if idea_round(p1, p2, k1, k2) != c:\n                match = False\n                break\n        if match:\n            print(f\"PCTF{{{k1:02X}{k2:02X}}}\")\n            exit()\n",
      "compute": "1",
      "original_data": {
        "key_hex": "BC4C",
        "plaintext": "PCTF{BC4C}",
        "compute": "1"
      },
      "difficulty": "easy",
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %48%65%6C%6C%6F%5F%57%6F%72%6C%64%7E\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%48%65%6C%6C%6F%5F%57%6F%72%6C%64%7E\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{Hello_World~}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%48%65%6C%6C%6F%5F%57%6F%72%6C%64%7E",
        "decode_string": "Hello_World~",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %E6%90%9C%E7%B4%A2%3Fq%3DCTF%E6%8C%91%E6%88%98\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%E6%90%9C%E7%B4%A2%3Fq%3DCTF%E6%8C%91%E6%88%98\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{搜索?q=CTF挑战}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%E6%90%9C%E7%B4%A2%3Fq%3DCTF%E6%8C%91%E6%88%98",
        "decode_string": "搜索?q=CTF挑战",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %75%73%65%72%40%65%78%61%6D%70%6C%65%2E%63%6F%6D\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%75%73%65%72%40%65%78%61%6D%70%6C%65%2E%63%6F%6D\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{user@example.com}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%75%73%65%72%40%65%78%61%6D%70%6C%65%2E%63%6F%6D",
        "decode_string": "user@example.com",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %6B%65%79%3D%76%61%6C%75%65%26%69%64%3D%31%32%33\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%6B%65%79%3D%76%61%6C%75%65%26%69%64%3D%31%32%33\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{key=value&id=123}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%6B%65%79%3D%76%61%6C%75%65%26%69%64%3D%31%32%33",
        "decode_string": "key=value&id=123",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %24%31%32%33%2E%34%35%25%5E%2A%28%29\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%24%31%32%33%2E%34%35%25%5E%2A%28%29\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{$123.45%^*()}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%24%31%32%33%2E%34%35%25%5E%2A%28%29",
        "decode_string": "$123.45%^*()",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %5B%7B%22%6E%61%6D%65%22%3A%22%74%65%73%74%22%7D%5D\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%5B%7B%22%6E%61%6D%65%22%3A%22%74%65%73%74%22%7D%5D\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{[{\"name\":\"test\"}]}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%5B%7B%22%6E%61%6D%65%22%3A%22%74%65%73%74%22%7D%5D",
        "decode_string": "[{\"name\":\"test\"}]",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %27OR%201%3D1--\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%27OR%201%3D1--\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{'OR 1=1--}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%27OR%201%3D1--",
        "decode_string": "'OR 1=1--",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %2520special%2521\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%2520special%2521\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{%20special%21}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%2520special%2521",
        "decode_string": "%20special%21",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %3C%68%31%3E%54%69%74%6C%65%3C%2F%68%31%3E\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%3C%68%31%3E%54%69%74%6C%65%3C%2F%68%31%3E\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{<h1>Title</h1>}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%3C%68%31%3E%54%69%74%6C%65%3C%2F%68%31%3E",
        "decode_string": "<h1>Title</h1>",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " \n    A URL-encoded string is known to be: %66%69%6C%65%3A%2F%2F%2F%70%61%74%68%2F%74%6F%2F%66%69%6C%65\n    Please decode the plain text and submit it according to the format\n    Submission format: PCTF{decode_string}\n    ",
    "rationale": "from urllib.parse import unquote\nencode_string = \"%66%69%6C%65%3A%2F%2F%2F%70%61%74%68%2F%74%6F%2F%66%69%6C%65\"  \ndecode_string = unquote(encode_string, encoding='utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{file:///path/to/file}",
    "metadata": {
      "class1": "MISC",
      "class2": "Url",
      "change_detail": "In misc, The characters are encoded in URL format and need to be decoded to get the plain text",
      "synthesis_code": "from urllib.parse import quote\n    decode_string = \"{decode_string}\"\n    encode_string = quote(decode_string, safe='', encoding='utf-8')\n    print(encode_string)",
      "original_data": {
        "encode_string": "%66%69%6C%65%3A%2F%2F%2F%70%61%74%68%2F%74%6F%2F%66%69%6C%65",
        "decode_string": "file:///path/to/file",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0048\\u0065\\u006c\\u006c\\u006f\\u0020\\u0043\\u0054\\u0046\\u0021\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0048\\u0065\\u006c\\u006c\\u006f\\u0020\\u0043\\u0054\\u0046\\u0021\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{Hello CTF!}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0048\\u0065\\u006c\\u006c\\u006f\\u0020\\u0043\\u0054\\u0046\\u0021",
        "decode_string": "Hello CTF!",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: whois\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"whois\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{whois}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "whois",
        "decode_string": "whois",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u006b\\u0072\\u0079\\u0070\\u0074\\u006f\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u006b\\u0072\\u0079\\u0070\\u0074\\u006f\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{krypto}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u006b\\u0072\\u0079\\u0070\\u0074\\u006f",
        "decode_string": "krypto",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0031\\u002b\\u0032\\u003d\\u0033\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0031\\u002b\\u0032\\u003d\\u0033\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{1+2=3}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0031\\u002b\\u0032\\u003d\\u0033",
        "decode_string": "1+2=3",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0041\\u0042\\u0043\\u0044\\u0045\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0041\\u0042\\u0043\\u0044\\u0045\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{ABCDE}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0041\\u0042\\u0043\\u0044\\u0045",
        "decode_string": "ABCDE",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0048\\u0069\\u0020\\u0057\\u006f\\u0072\\u006c\\u0064\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0048\\u0069\\u0020\\u0057\\u006f\\u0072\\u006c\\u0064\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{Hi World}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0048\\u0069\\u0020\\u0057\\u006f\\u0072\\u006c\\u0064",
        "decode_string": "Hi World",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u007b\\u005f\\u005f\\u007d\\u0021\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u007b\\u005f\\u005f\\u007d\\u0021\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{{__}!}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u007b\\u005f\\u005f\\u007d\\u0021",
        "decode_string": "{__}!",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0041\\u0045\\u0053\\u002d\\u0032\\u0035\\u0036\\u0020\\u0053\\u0048\\u0041\\u0033\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0041\\u0045\\u0053\\u002d\\u0032\\u0035\\u0036\\u0020\\u0053\\u0048\\u0041\\u0033\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{AES-256 SHA3}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0041\\u0045\\u0053\\u002d\\u0032\\u0035\\u0036\\u0020\\u0053\\u0048\\u0041\\u0033",
        "decode_string": "AES-256 SHA3",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u002f\\u0065\\u0074\\u0063\\u002f\\u0070\\u0061\\u0073\\u0073\\u0077\\u0064\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u002f\\u0065\\u0074\\u0063\\u002f\\u0070\\u0061\\u0073\\u0073\\u0077\\u0064\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{/etc/passwd}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u002f\\u0065\\u0074\\u0063\\u002f\\u0070\\u0061\\u0073\\u0073\\u0077\\u0064",
        "decode_string": "/etc/passwd",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "A Unicode-encoded string is known as: \\u0032\\u0030\\u0032\\u0034\\u002d\\u0030\\u0036\\u002d\\u0031\\u0034\\u0020\\u0031\\u0034\\u003a\\u0033\\u0030\nPlease decode the plain text and submit it according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "\nencode_string = \"\\u0032\\u0030\\u0032\\u0034\\u002d\\u0030\\u0036\\u002d\\u0031\\u0034\\u0020\\u0031\\u0034\\u003a\\u0033\\u0030\"  \ndecode_string = encode_string.encode().decode('unicode_escape')\nprint(decode_string)\n",
    "final_answer": "PCTF{2024-06-14 14:30}",
    "metadata": {
      "class1": "MISC",
      "class2": "Unicode",
      "change_detail": "In misc, The characters are encoded in unicode format and need to be decoded to get the string",
      "synthesis_code": "decode_string = \"{decode_string}\"  \n    encoded_string =  decode_string.encode('unicode_escape').decode()\n    print(encoded_string)",
      "original_data": {
        "encode_string": "\\u0032\\u0030\\u0032\\u0034\\u002d\\u0030\\u0036\\u002d\\u0031\\u0034\\u0020\\u0031\\u0034\\u003a\\u0033\\u0030",
        "decode_string": "2024-06-14 14:30",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: NzA5YzNlOGU4NDQ5Y2M1YjJkOWFlNTY3MDdjYzJjZGI=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"NzA5YzNlOGU4NDQ5Y2M1YjJkOWFlNTY3MDdjYzJjZGI=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{709c3e8e8449cc5b2d9ae56707cc2cdb}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "NzA5YzNlOGU4NDQ5Y2M1YjJkOWFlNTY3MDdjYzJjZGI=",
        "original_string": "709c3e8e8449cc5b2d9ae56707cc2cdb",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: ZDQxZDhjZDk4ZjAwYjIwNGU5ODAwOTk4ZWNmODQyN2U=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"ZDQxZDhjZDk4ZjAwYjIwNGU5ODAwOTk4ZWNmODQyN2U=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{d41d8cd98f00b204e9800998ecf8427e}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "ZDQxZDhjZDk4ZjAwYjIwNGU5ODAwOTk4ZWNmODQyN2U=",
        "original_string": "d41d8cd98f00b204e9800998ecf8427e",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: YjRhM2Q4YzFlN2YyYTliNg==\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"YjRhM2Q4YzFlN2YyYTliNg==\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{b4a3d8c1e7f2a9b6}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "YjRhM2Q4YzFlN2YyYTliNg==",
        "original_string": "b4a3d8c1e7f2a9b6",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: MjAyMy0xMC0wNSAxNDozMDowMCBVVEM=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"MjAyMy0xMC0wNSAxNDozMDowMCBVVEM=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{2023-10-05 14:30:00 UTC}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "MjAyMy0xMC0wNSAxNDozMDowMCBVVEM=",
        "original_string": "2023-10-05 14:30:00 UTC",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: ZTY0NWY4MzJhYmViOWQyMDQxYzRiYTE3MjRmMzBlOGQ=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"ZTY0NWY4MzJhYmViOWQyMDQxYzRiYTE3MjRmMzBlOGQ=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{e645f832abeb9d2041c4ba1724f30e8d}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "ZTY0NWY4MzJhYmViOWQyMDQxYzRiYTE3MjRmMzBlOGQ=",
        "original_string": "e645f832abeb9d2041c4ba1724f30e8d",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: M2Q2ODRmOTBlYTRkY2UyYjI0ZjgxM2M0OTJiNDE0YjI=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"M2Q2ODRmOTBlYTRkY2UyYjI0ZjgxM2M0OTJiNDE0YjI=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{3d684f90ea4dce2b24f813c492b414b2}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "M2Q2ODRmOTBlYTRkY2UyYjI0ZjgxM2M0OTJiNDE0YjI=",
        "original_string": "3d684f90ea4dce2b24f813c492b414b2",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{123456789012345678901234567890}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw",
        "original_string": "123456789012345678901234567890",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: YjJlMDVlZjRjOTAyNGY1MGIyZWVkZGU1ZGUyMTUwY2M=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"YjJlMDVlZjRjOTAyNGY1MGIyZWVkZGU1ZGUyMTUwY2M=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{b2e05ef4c9024f50b2eedde5de2150cc}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "YjJlMDVlZjRjOTAyNGY1MGIyZWVkZGU1ZGUyMTUwY2M=",
        "original_string": "b2e05ef4c9024f50b2eedde5de2150cc",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{00000000000000000000000000000000}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA=",
        "original_string": "00000000000000000000000000000000",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "Here is important information encrypted by base64: ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg=\nPlease decrypt to get the original string\nSubmission format: PCTF{plaintext string}",
    "rationale": "import base64\nbase64_str = \"ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg=\"  \ndecoded_bytes = base64.b64decode(base64_str)\ndecoded_text = decoded_bytes.decode('utf-8')\nprint(decoded_text)\n",
    "final_answer": "PCTF{88888888888888888888888888888888}",
    "metadata": {
      "class1": "MISC",
      "class2": "BASE64",
      "change_detail": "In misc, first determine whether the given text is base64 encoded, then decode it to get the original text",
      "synthesis_code": "import base64\n    original_str = \"{original_str}\"\n    byte_data = original_str.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_data)\n    print(base64_bytes.decode('utf-8'))",
      "original_data": {
        "base64_string": "ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg=",
        "original_string": "88888888888888888888888888888888",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 72 101 108 108 111\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"72 101 108 108 111\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Hello}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "72 101 108 108 111",
        "decode_string": "Hello",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 87 111 114 108 100\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"87 111 114 108 100\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{World}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "87 111 114 108 100",
        "decode_string": "World",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 67 104 97 116 71 80 84\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"67 104 97 116 71 80 84\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{ChatGPT}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "67 104 97 116 71 80 84",
        "decode_string": "ChatGPT",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 65 73\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"65 73\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{AI}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "65 73",
        "decode_string": "AI",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 67 111 100 101\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"67 111 100 101\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Code}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "67 111 100 101",
        "decode_string": "Code",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 68 97 116 97\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"68 97 116 97\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Data}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "68 97 116 97",
        "decode_string": "Data",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 76 111 103 105 99\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"76 111 103 105 99\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Logic}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "76 111 103 105 99",
        "decode_string": "Logic",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 66 105 110 97 114 121\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"66 105 110 97 114 121\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Binary}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "66 105 110 97 114 121",
        "decode_string": "Binary",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 80 121 116 104 111 110\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"80 121 116 104 111 110\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Python}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "80 121 116 104 111 110",
        "decode_string": "Python",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " The text obtained is: 78 117 109 98 101 114\n    This text may be the output after encoding. Please decode it into plain text. Please submit it according to the format when submitting it.\n    Submission format: PCTF{plain text string}",
    "rationale": "encode_string = \"78 117 109 98 101 114\"  \ncodes = [int(code) for code in encode_string.split()]\ndecode_string = \"\".join(chr(code) for code in codes)\nprint(decode_string)\n",
    "final_answer": "PCTF{Number}",
    "metadata": {
      "class1": "MISC",
      "class2": "ASCII",
      "change_detail": "In MISC challenges, ASCII decoding is often used to interpret encoded messages, where the solution involves converting numerical ASCII values back to characters to reveal hidden text. ",
      "synthesis_code": "\n    decode_string = \"{decode_string}\"\n    encode_string = \" \".join(str(ord(char)) for char in decode_string)\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "78 117 109 98 101 114",
        "decode_string": "Number",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 01 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"01\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{0}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "01",
        "decode_string": "0",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 10 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"10\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{1}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "10",
        "decode_string": "1",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 0110 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"0110\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{01}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "0110",
        "decode_string": "01",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 1001 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"1001\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{10}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "1001",
        "decode_string": "10",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 01010101 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"01010101\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{0000}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "01010101",
        "decode_string": "0000",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 10101010 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"10101010\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{1111}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "10101010",
        "decode_string": "1111",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 0110011001100110 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"0110011001100110\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{01010101}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "0110011001100110",
        "decode_string": "01010101",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 10011001 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"10011001\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{1010}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "10011001",
        "decode_string": "1010",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 01011010 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"01011010\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{0011}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "01011010",
        "decode_string": "0011",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": " A signal has been processed into Manchester code 10100101 . \n    Please restore this signal. Please submit according to the format. \n    Submission format: PCTF{plaintext string}\n    ",
    "rationale": "encode_string = \"10100101\"  \ndecoded = []\nfor i in range(0, len(encode_string), 2):\n    pair = encode_string[i:i+2]\n    if pair == '01':\n        decoded.append('0')\n    elif pair == '10':\n        decoded.append('1')\n\ndecode_string =  ''.join(decoded)\nprint(decode_string)\n",
    "final_answer": "PCTF{1100}",
    "metadata": {
      "class1": "MISC",
      "class2": "Manchester",
      "change_detail": "In MISC, Manchester encoding problems involve decoding binary signals where each bit is represented by a transition, and the solution requires interpreting these transitions to reconstruct the original binary data. ",
      "synthesis_code": "decode_string = \"{decode_string}\"\n    encoded = []\n    for bit in decode_string:\n        if bit == '0':\n            encoded.append('01')\n        elif bit == '1':\n            encoded.append('10')\n        \n    return ''.join(encoded) ",
      "original_data": {
        "encode_string": "10100101",
        "decode_string": "1100",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message ... --- .... The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \"... --- ...\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{SOS}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": "... --- ...",
        "decode_string": "SOS",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .... . .-.. .-.. --- / .-- --- .-. .-.. -... The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".... . .-.. .-.. --- / .-- --- .-. .-.. -..\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{HELLO WORLD}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".... . .-.. .-.. --- / .-- --- .-. .-.. -..",
        "decode_string": "HELLO WORLD",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message -.-. - ..-. / ..-. .-.. .- --.. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \"-.-. - ..-. / ..-. .-.. .- --.\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{CTF FLAG}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": "-.-. - ..-. / ..-. .-.. .- --.",
        "decode_string": "CTF FLAG",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .---- ..--- ...-- ....- ..... -.... --... ---.. ----. -----. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".---- ..--- ...-- ....- ..... -.... --... ---.. ----. -----\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{1234567890}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".---- ..--- ...-- ....- ..... -.... --... ---.. ----. -----",
        "decode_string": "1234567890",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .- .-.. .--. .... .- / -... .-. .- ...- ---. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".- .-.. .--. .... .- / -... .-. .- ...- ---\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{ALPHA BRAVO}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".- .-.. .--. .... .- / -... .-. .- ...- ---",
        "decode_string": "ALPHA BRAVO",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .--. -.-- - .... --- -.. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".--. -.-- - .... --- -.\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{PYTHON}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".--. -.-- - .... --- -.",
        "decode_string": "PYTHON",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message ...- .. .-. - ..- .- .-... The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \"...- .. .-. - ..- .- .-..\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{VIRTUAL}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": "...- .. .-. - ..- .- .-..",
        "decode_string": "VIRTUAL",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .-- .... . .-. . / .. ... / - .... . / ..-. .-.. .- --. ..--... The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".-- .... . .-. . / .. ... / - .... . / ..-. .-.. .- --. ..--..\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{WHERE IS THE FLAG?}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".-- .... . .-. . / .. ... / - .... . / ..-. .-.. .- --. ..--..",
        "decode_string": "WHERE IS THE FLAG?",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message .--. .-. --- --- ..-. / --- ..-. / -.-. --- -. -.-. . .--. -. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \".--. .-. --- --- ..-. / --- ..-. / -.-. --- -. -.-. . .--. -\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{PROOF OF CONCEPT}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": ".--. .-. --- --- ..-. / --- ..-. / -.-. --- -. -.-. . .--. -",
        "decode_string": "PROOF OF CONCEPT",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "This is an intercepted message ...- ..- .-.. -. ..--.- ... -.-. --- .-. .. The content seems to be Morse code. Please restore the original content.\nSubmission format: PCTF{plaintext string}  ",
    "rationale": "\nMORSE_CODE_DICT = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n    'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n    '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n    '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n    '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n    ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n    '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n    '@': '.--.-.'\n}\nMORSE_DECODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()}\n\nencode_string = \"...- ..- .-.. -. ..--.- ... -.-. --- .-. .\"  \ndecode_string = ''.join(MORSE_DECODE_DICT[code] for code in encode_string.split(' '))\nprint(decode_string)\n",
    "final_answer": "PCTF{VULN_SCORE}",
    "metadata": {
      "class1": "MISC",
      "class2": "Morse",
      "change_detail": "In MISC challenges, Morse code problems involve decoding sequences of dots and dashes into text, where the solution requires mapping each Morse symbol to its corresponding letter or number based on the Morse code chart.",
      "synthesis_code": "MORSE_CODE_DICT = {{\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': '/', '.': '.-.-.-', ',': '--..--',\n        '?': '..--..', \"'\": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.',\n        ')': '-.--.-', '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',\n        '+': '.-.-.', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '$': '...-..-',\n        '@': '.--.-.'\n    }}\n    decode_string = \"{decode_string}\"\n    encoder_string = ' '.join(MORSE_CODE_DICT[c.upper()] for c in decode_string)\n    print(encoder_string)\n    ",
      "original_data": {
        "encode_string": "...- ..- .-.. -. ..--.- ... -.-. --- .-. .",
        "decode_string": "VULN_SCORE",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : Hello=20World, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"Hello=20World\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{Hello World}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "Hello=20World",
        "decode_string": "Hello World",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : CTF=3DChallenge=3D2024, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"CTF=3DChallenge=3D2024\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{CTF=Challenge=2024}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "CTF=3DChallenge=3D2024",
        "decode_string": "CTF=Challenge=2024",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : Caf=C3=A9_=E2=98=83, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"Caf=C3=A9_=E2=98=83\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{Café_☃}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "Caf=C3=A9_=E2=98=83",
        "decode_string": "Café_☃",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =5B=5BImportant=21=5D=5D, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=5B=5BImportant=21=5D=5D\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{[[Important!]]}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=5B=5BImportant=21=5D=5D",
        "decode_string": "[[Important!]]",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : Line=20break=0D=0A=54=68=69=73=20=69=73=20=6E=65=77=20=6C=69=6E=65, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"Line=20break=0D=0A=54=68=69=73=20=69=73=20=6E=65=77=20=6C=69=6E=65\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{Line break\r\nThis is new line}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "Line=20break=0D=0A=54=68=69=73=20=69=73=20=6E=65=77=20=6C=69=6E=65",
        "decode_string": "Line break\r\nThis is new line",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =24=26=40=23=25=2A, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=24=26=40=23=25=2A\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{$&@#%*}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=24=26=40=23=25=2A",
        "decode_string": "$&@#%*",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =41=42=43=44=45=46=47=48=49=4A=4B=4C=4D=4E=4F=50=51=52=53=54=55=56=57=58=59=5A=0A=61=62=63=64=65=66=67=68=69=6A=6B=6C=6D=6E=6F=70=71=72=73=74=75=76=77=78=79=7A, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=41=42=43=44=45=46=47=48=49=4A=4B=4C=4D=4E=4F=50=51=52=53=54=55=56=57=58=59=5A=0A=61=62=63=64=65=66=67=68=69=6A=6B=6C=6D=6E=6F=70=71=72=73=74=75=76=77=78=79=7A\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{ABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=41=42=43=44=45=46=47=48=49=4A=4B=4C=4D=4E=4F=50=51=52=53=54=55=56=57=58=59=5A=0A=61=62=63=64=65=66=67=68=69=6A=6B=6C=6D=6E=6F=70=71=72=73=74=75=76=77=78=79=7A",
        "decode_string": "ABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =E3=81=82=E3=81=84=E3=81=86=E3=81=88=E3=81=8A, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=E3=81=82=E3=81=84=E3=81=86=E3=81=88=E3=81=8A\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{あいうえお}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=E3=81=82=E3=81=84=E3=81=86=E3=81=88=E3=81=8A",
        "decode_string": "あいうえお",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =22Quoted=20Print=20Encoding=22=20=28QP=29, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=22Quoted=20Print=20Encoding=22=20=28QP=29\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{\"Quoted Print Encoding\" (QP)}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=22Quoted=20Print=20Encoding=22=20=28QP=29",
        "decode_string": "\"Quoted Print Encoding\" (QP)",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  },
  {
    "question": "The following is a quoted_printable encoded data : =54=68=69=73=20=69=73=20=61=20=76=65=72=79=20=6C=6F=6E=67=20=73=65=6E=74=65=6E=63=65=20=74=68=61=74=20=6E=65=65=64=73=20=74=6F=20=62=65=20=77=72=61=70=70=65=64=20=61=75=74=6F=6D=61=74=69=63=61=6C=6C=79=20=62=79=20=51=50=20=65=6E=63=6F=64=69=6E=67=2E, please output the original text. Please submit according to the format\nSubmission format: PCTF{plain text string} ",
    "rationale": "import quopri\nencode_string = \"=54=68=69=73=20=69=73=20=61=20=76=65=72=79=20=6C=6F=6E=67=20=73=65=6E=74=65=6E=63=65=20=74=68=61=74=20=6E=65=65=64=73=20=74=6F=20=62=65=20=77=72=61=70=70=65=64=20=61=75=74=6F=6D=61=74=69=63=61=6C=6C=79=20=62=79=20=51=50=20=65=6E=63=6F=64=69=6E=67=2E\"  \ndecode_string = quopri.decodestring(encode_string.encode('utf-8')).decode('utf-8')\nprint(decode_string)\n",
    "final_answer": "PCTF{This is a very long sentence that needs to be wrapped automatically by QP encoding.}",
    "metadata": {
      "class1": "MISC",
      "class2": "Quoted_printable",
      "change_detail": "In MISC challenges, Quoted-Printable encoding problems involve decoding text where special characters are represented as `=XX` hexadecimal values, and the solution requires converting these encoded sequences back to their original ASCII characters.",
      "synthesis_code": "import quopri\n    encode_string = \"{encode_string}\"  \n    encode_string =  quopri.encodestring(encode_string.encode('utf-8'), header=False).decode('utf-8')\n    print(encode_string)\n    ",
      "original_data": {
        "encode_string": "=54=68=69=73=20=69=73=20=61=20=76=65=72=79=20=6C=6F=6E=67=20=73=65=6E=74=65=6E=63=65=20=74=68=61=74=20=6E=65=65=64=73=20=74=6F=20=62=65=20=77=72=61=70=70=65=64=20=61=75=74=6F=6D=61=74=69=63=61=6C=6C=79=20=62=79=20=51=50=20=65=6E=63=6F=64=69=6E=67=2E",
        "decode_string": "This is a very long sentence that needs to be wrapped automatically by QP encoding.",
        "compute": "1"
      },
      "source_url": [
        "https://ctf-wiki.org/crypto/introduction/",
        "https://github.com/ctf-wiki/ctf-challenges/tree/master/crypto"
      ],
      "license": "CC-BY-NC 4.0"
    }
  }
]